

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/cat.png">
  <link rel="icon" href="/img/cat.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Yifan Xie">
  <meta name="keywords" content="">
  
    <meta name="description" content="根据各类网络教程总结的JAVA语言基础知识点，仍在持续更新中…">
<meta property="og:type" content="article">
<meta property="og:title" content="JAVA基础">
<meta property="og:url" content="http://example.com/2025/06/02/JAVA%E5%9F%BA%E7%A1%80/index.html">
<meta property="og:site_name" content="harker-xm">
<meta property="og:description" content="根据各类网络教程总结的JAVA语言基础知识点，仍在持续更新中…">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/assets/image-20220706104753-pdrchly.png">
<meta property="og:image" content="http://example.com/assets/image-20220706105817-s13yt87.png">
<meta property="og:image" content="http://example.com/assets/image-20220709235842-apfpixe.png">
<meta property="og:image" content="http://example.com/assets/image-20220713204009-rqf8907.png">
<meta property="og:image" content="http://example.com/assets/image-20220723155911-tg5026n.png">
<meta property="og:image" content="http://example.com/assets/image-20220731160921-nvebuyu.png">
<meta property="og:image" content="http://example.com/assets/image-20220720100427-v0oqzuh.png">
<meta property="og:image" content="http://example.com/assets/image-20220720101631-8ykfzxj.png">
<meta property="og:image" content="http://example.com/assets/image-20220721101716-haizfcz.png">
<meta property="og:image" content="http://example.com/assets/image-20220720105025-25cea3l.png">
<meta property="og:image" content="http://example.com/assets/image-20220720121209-6m6cwib.png">
<meta property="og:image" content="http://example.com/assets/image-20220721115721-mngpsif.png">
<meta property="og:image" content="http://example.com/assets/image-20220721151606-e83l1ev.png">
<meta property="og:image" content="http://example.com/assets/image-20220721152132-bl3cg9n.png">
<meta property="og:image" content="http://example.com/assets/image-20220721155922-3m1wuvz.png">
<meta property="og:image" content="http://example.com/assets/image-20220721160346-dxvlw2i.png">
<meta property="og:image" content="http://example.com/assets/image-20220710170132-y8mpebm.png">
<meta property="og:image" content="http://example.com/assets/image-20220710170144-0rny6m1.png">
<meta property="og:image" content="http://example.com/assets/image-20220802155852-f8erj8f.png">
<meta property="og:image" content="http://example.com/assets/image-20220731105938-tnp12jm.png">
<meta property="og:image" content="http://example.com/assets/image-20220731164725-2y2ej48.png">
<meta property="og:image" content="http://example.com/assets/image-20220801115235-ipy2rbo.png">
<meta property="og:image" content="http://example.com/assets/image-20220801115648-sbn7zzf.png">
<meta property="og:image" content="http://example.com/assets/image-20220801115933-m4y6xjf.png">
<meta property="og:image" content="http://example.com/assets/image-20220801140514-yckzx4d.png">
<meta property="og:image" content="http://example.com/assets/image-20220802153814-iavkcf3.png">
<meta property="og:image" content="http://example.com/assets/image-20220802154703-m6a8jg2.png">
<meta property="og:image" content="http://example.com/assets/image-20220802154937-t9ekqny.png">
<meta property="og:image" content="http://example.com/assets/image-20220806164524-ekumbs3.png">
<meta property="og:image" content="http://example.com/assets/image-20220806164828-szdvexz.png">
<meta property="og:image" content="http://example.com/assets/image-20220806164718-0f5mfwq.png">
<meta property="og:image" content="http://example.com/assets/image-20220802161516-3vs7mbp.png">
<meta property="og:image" content="http://example.com/assets/image-20220802161653-ize6dfk.png">
<meta property="og:image" content="http://example.com/assets/image-20220806171516-grgj1sf.png">
<meta property="og:image" content="http://example.com/assets/image-20220807173135-7qmk6i4.png">
<meta property="og:image" content="http://example.com/assets/image-20220807173231-qurlsxs.png">
<meta property="og:image" content="http://example.com/assets/image-20220809103437-xbqysho.png">
<meta property="og:image" content="http://example.com/assets/image-20220811211111-nsuoy6g.png">
<meta property="og:image" content="http://example.com/assets/image-20220815213502-pnk172y.png">
<meta property="og:image" content="http://example.com/assets/image-20220821090533-j670u2d.png">
<meta property="og:image" content="http://example.com/assets/image-20220821224054-yqfu1t8.png">
<meta property="og:image" content="http://example.com/assets/image-20220825150235-ts9sija.png">
<meta property="article:published_time" content="2025-06-01T16:21:56.000Z">
<meta property="article:modified_time" content="2025-06-14T18:04:03.680Z">
<meta property="article:author" content="Yifan Xie">
<meta property="article:tag" content="开发技术">
<meta property="article:tag" content="笔记">
<meta property="article:tag" content="后端">
<meta property="article:tag" content="更新中">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/assets/image-20220706104753-pdrchly.png">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>JAVA基础 / harker-xm</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"|","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>harker-xm的Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="JAVA基础"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-06-02 00:21" pubdate>
          2025年6月2日 凌晨
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          13k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          79 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">JAVA基础</h1>
            
              <p id="updated-time" class="note note-info" style="display: none">
                
                  
                    本文最后更新于 2025-06-15T02:04:03+08:00
                  
                  

                
              </p>
            
            
              <div class="markdown-body">
                
                <p>根据各类网络教程总结的JAVA语言基础知识点，仍在持续更新中…</p>
<span id="more"></span>

<h1 id="·-入门"><a href="#·-入门" class="headerlink" title="· 入门"></a><strong>· 入门</strong></h1><p><img src="/assets/image-20220706104753-pdrchly.png" srcset="/img/loading.gif" lazyload alt="image.png">java11之后不单独提供JRE</p>
<p><strong>编译运行步骤</strong>                                                      字节码                                                     机器码<br>​<img src="/assets/image-20220706105817-s13yt87.png" srcset="/img/loading.gif" lazyload alt="image.png">&#x3D;&#x3D;不同操作系统的机器码不通用，所以中间借用字节码&#x3D;&#x3D;</p>
<p>‍</p>
<h1 id="·-类设计"><a href="#·-类设计" class="headerlink" title="· 类设计"></a><strong>· 类设计</strong></h1><p>‍</p>
<p><strong>成员变量+成员方法+构造器+代码块+内部类</strong></p>
<p>Java文件定义多个类中只能有一个由public修饰，且该类名必须是文件名</p>
<p><img src="/assets/image-20220709235842-apfpixe.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<ol>
<li><h3 id="this的使用"><a href="#this的使用" class="headerlink" title="this的使用"></a><strong>this的使用</strong></h3> this用来在成员方法中访问类域，不同名时无所谓</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span>&#123;<br>    <span class="hljs-type">int</span> x,y;  <span class="hljs-comment">//域</span><br>    Point()<br>    &#123;<br>        x=<span class="hljs-number">0</span>:<br>        y=<span class="hljs-number">0</span>;<span class="hljs-comment">//this.x,this.y也可</span><br>    &#125;<br>    Point(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)<br>    &#123;<br>        <span class="hljs-built_in">this</span>.x=x;<br>        <span class="hljs-built_in">this</span>.y=y;  <span class="hljs-comment">//必须写，不然不能区分参数和类域</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ol start="2">
<li><h3 id="对象数组"><a href="#对象数组" class="headerlink" title="对象数组"></a><strong>对象数组</strong></h3><p> 数组中元素使用自己创造的对象，而不是常规的INT等变量</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span>&#123;...&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">example</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span><br>    &#123;<br>        <span class="hljs-type">Point</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Point</span>(<span class="hljs-number">10</span>,<span class="hljs-number">11</span>);<br>        <span class="hljs-type">Point</span> <span class="hljs-variable">p2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Point</span>(<span class="hljs-number">20</span>,<span class="hljs-number">21</span>);<br>        <span class="hljs-type">Point</span> <span class="hljs-variable">p3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Point</span>(<span class="hljs-number">30</span>,<span class="hljs-number">31</span>);<br>        <span class="hljs-comment">//初始化的多种方法</span><br>        <span class="hljs-type">Point</span> <span class="hljs-variable">point1</span> <span class="hljs-operator">=</span> &#123;p1,p2,p3,<span class="hljs-keyword">new</span> <span class="hljs-title class_">Point</span>(<span class="hljs-number">40</span>,<span class="hljs-number">41</span>)&#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p> 域中定义变量 static int才能发挥全局作用</p>
</li>
<li><h3 id="访问权限-封装Encapsulation"><a href="#访问权限-封装Encapsulation" class="headerlink" title="访问权限 (封装Encapsulation)"></a><strong>访问权限</strong> (封装Encapsulation)</h3><p> Java的封装可以使用保护修饰词，有private, protected, public</p>
<table>
<thead>
<tr>
<th>访问权限</th>
<th>本类</th>
<th>本包的类</th>
<th>子类</th>
<th>非子类的外包类</th>
</tr>
</thead>
<tbody><tr>
<td>public</td>
<td>是</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>protected</td>
<td>是</td>
<td>是</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>default</td>
<td>是</td>
<td>是</td>
<td>否</td>
<td>否</td>
</tr>
<tr>
<td>private</td>
<td>是</td>
<td>否</td>
<td>否</td>
<td>否</td>
</tr>
</tbody></table>
</li>
<li><h3 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a><strong>类的继承</strong></h3> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">father</span><br>&#123;<br>    <span class="hljs-comment">//无参构造器</span><br>    father()&#123;...&#125;<br>    <span class="hljs-comment">//有参构造器</span><br>    father(a,b,c)&#123;...&#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">son</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">father</span><br>&#123;<br>    son()&#123;...&#125;<br>    son(a,b,c)<br>    &#123;<br>        <span class="hljs-comment">//先初始化父类构造器，不写也是隐式调用无参的，如要有参必须写</span><br>        <span class="hljs-built_in">super</span>();<br>        <span class="hljs-comment">//再构造自己</span><br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br>    <span class="hljs-comment">//子类域</span><br>    <span class="hljs-comment">//子类方法</span><br>&#125;<br>main:<br>    <span class="hljs-type">son</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">son</span>();<br>    <span class="hljs-comment">//先执行父类无参构造器，再执行子类相应(有参或无参构造器)！！</span><br></code></pre></td></tr></table></figure>

<p> 子类可以继承父类的域和方法，就当作自身定义的一样使用</p>
<p> 子类可能不适用父类的域或方法，重新定义父类的域称为&#x3D;&#x3D;域的隐藏&#x3D;&#x3D;，重新定义继承自父类的方法称为&#x3D;&#x3D;方法的重写&#x3D;&#x3D;</p>
<p> <strong>域的隐藏</strong>：在子类域中取域父类域相同名称的变量</p>
<p> <strong>方法的重写</strong>：在子类方法中写相同名称的函数</p>
<p> <strong>super关键字</strong><br> 若子类隐藏了父类的域，或重写了父类的方法，但仍想引用这些方法，可通过super关键字访问</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-built_in">super</span>.域<br><span class="hljs-built_in">super</span>.方法([para])<br><span class="hljs-comment">//调用父类的构造方法</span><br><span class="hljs-built_in">super</span>([para])<br></code></pre></td></tr></table></figure>

<p> <strong>Object类</strong>（类的大爹）<br> 我们创建一个类时，如果没有明确继承一个父类，那么它就会自动继承 Object，成为 Object 的子类。<br> <strong>Object</strong>类中有很多方法可以用以重写，如clone、equals、toString…<br> <a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43232955/article/details/89705350">https://blog.csdn.net/weixin_43232955&#x2F;article&#x2F;details&#x2F;89705350</a></p>
<p> 用<strong>final关键字</strong>标记的域或方法不能被重写<br> public static final double PI &#x3D; 3.1415926<br> public final int getA()</p>
<p>  <strong>@Override注解</strong></p>
<p> 它标注的方法必须是对父类的重写，若父类没有则报错</p>
<p> ‍</p>
</li>
<li><h3 id="组合类-派生类"><a href="#组合类-派生类" class="headerlink" title="组合类&amp;派生类"></a><strong>组合类&amp;派生类</strong></h3><p> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/wft1990/p/5995416.html">https://www.cnblogs.com/wft1990/p/5995416.html</a></p>
</li>
<li><h3 id="类的多态"><a href="#类的多态" class="headerlink" title="类的多态"></a><strong>类的多态</strong></h3><p> 多态指的是同一类对象的不同行为，eg.飞机&amp;汽车都属于交通工具类，但运行方式不同</p>
<p> 多态更强调行为的多态，而不是变量的多态</p>
<p> <strong>赋值兼容规则</strong></p>
<p> 类Circle是类Point1的子类，则可以有<code>Point p = new Circle(15,25,10);</code>称p(父类对象)为子类对象的<strong>上转型对象</strong></p>
<p> &#x3D;&#x3D;多态的优势&#x3D;&#x3D;</p>
<ol>
<li><pre><code class="language-java"> Animal a = new Dog()
 Animal a = new Tiger()
 //多态使得右边对象可以解耦合，便于扩展和维护
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><br>    ‍<br><span class="hljs-number">2.</span> 定义方法的时候用父类型作为参数，所有子类型都可以传参<br><br>==多态的劣势==<br><br><span class="hljs-number">1.</span> 多态下不能访问子类的独有功能---》**sol.**  **引用数据类型的类型转换**<br><br>==引用数据类型的类型转换==<br><br><span class="hljs-number">1.</span> 自动类型转换（子👉父）<br><span class="hljs-number">2.</span> 强制类型转换（父👉子）<br><br>    ```java<br>    <span class="hljs-type">Animal</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Tiger</span>();<br>    <span class="hljs-comment">//此时不能调用Tiger类独有function</span><br>    <span class="hljs-type">Tiger</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> (Tiger)a;<br>    <span class="hljs-comment">//强制类型转换后可以调用独有功能</span><br>    <span class="hljs-comment">//!下面写法是运行时报错的</span><br>    <span class="hljs-type">Dog</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> (Dog)a;<span class="hljs-comment">//上面new的是Tiger，不能转Dog，异常：ClassCastException</span><br></code></pre></td></tr></table></figure>

 因此，JAVA推荐在强转前用**instanceof**判断对象真实类型再进行强转

 `if(t instanceof Tiger)&#123;//强转&#125;`
</code></pre>
</li>
</ol>
</li>
</ol>
<p>‍</p>
<ol start="7">
<li><h3 id="抽象类-方法-接口"><a href="#抽象类-方法-接口" class="headerlink" title="抽象类&#x2F;方法&amp;接口"></a><strong>抽象类&#x2F;方法&amp;接口</strong></h3> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span><span class="hljs-comment">//抽象类</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-type">double</span> <span class="hljs-title function_">area</span><span class="hljs-params">()</span>;<span class="hljs-comment">//抽象方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-type">double</span> <span class="hljs-title function_">perimeter</span><span class="hljs-params">()</span>;<span class="hljs-comment">//抽象方法</span><br>&#125;<br><span class="hljs-comment">//重写抽象类的方法以适应子类特征（必须重写抽象方法）</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Shape</span>&#123;...&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rectangle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Shape</span>&#123;...&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">example</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span>&#123;<br>        Shape aShape;声明抽象类的对象<br>        <span class="hljs-comment">//aShape = new Shape是不被允许的，即实例化抽象类是不允许的</span><br>        aShape = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Circle</span>(<span class="hljs-number">10</span>);<br>        aShape = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Rectangle</span>(<span class="hljs-number">15.2</span>,<span class="hljs-number">10.8</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p> <strong>接口</strong>可看作特殊的抽象类，但interface与class不同，class是对一类事物的描述，而interface可以描述不同类型的事物</p>
<p> 接口 弥补了单继承的不足</p>
<p> <strong>接口的域只能是不可重新赋值的常量；接口只能声明方法，不能定义方法</strong></p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Shape</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">double</span> <span class="hljs-variable">PI</span> <span class="hljs-operator">=</span> <span class="hljs-number">3.1415926</span>;<br>    <span class="hljs-comment">//interface中必须100%的抽象类</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-type">double</span> <span class="hljs-title function_">area</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-type">double</span> <span class="hljs-title function_">perimeter</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Shape</span>&#123;<br>    <span class="hljs-comment">//构造函数</span><br>    <span class="hljs-comment">//接口方法实现的函数</span><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><p><strong>如何选择使用抽象类还是接口呢？</strong></p>
<ol>
<li>抽象类可以定义类的全部普通成员，接口只能定义常量和抽象方法；</li>
<li>抽象类只能单继承，接口可以多实现；</li>
<li>抽象类适合写模板，提高代码的复用性；接口更适合给功能做解耦。</li>
</ol>
</li>
</ul>
</li>
</ol>
<p>‍</p>
<ol start="8">
<li><h3 id="static关键字的使用"><a href="#static关键字的使用" class="headerlink" title="static关键字的使用"></a>static关键字的使用</h3><p> &#x3D;&#x3D;静态成员变量&#x3D;&#x3D;<br> <code>static int a = 0</code>可以用 <code>类名.a</code> 的方式访问</p>
<p> &#x3D;&#x3D;实例成员变量&#x3D;&#x3D;<br> <code>private int b = 1</code> 只能用实例化后的对象访问，即<code>类名 c = new 类名()；c.b = 1</code></p>
<p> <img src="/assets/image-20220713204009-rqf8907.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p> &#x3D;&#x3D;静态成员方法&#x3D;&#x3D;<br> 属于类，<code>public static int get()&#123;...&#125;</code>,共享调用</p>
<p> &#x3D;&#x3D;实例方法&#x3D;&#x3D;<br> 属于实例，<code>public void get()&#123;...&#125;</code>,实例调用</p>
</li>
</ol>
<p>‍</p>
<ol start="9">
<li><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//用以初始化</span><br>&#123;...&#125;<span class="hljs-comment">//实例代码块</span><br><span class="hljs-keyword">static</span> &#123;...&#125;<span class="hljs-comment">//静态代码块</span><br></code></pre></td></tr></table></figure>

 静态代码块会在类加载时执行一次，可将类的初始化操作置于其中</li>
</ol>
<p>‍</p>
<ol start="10">
<li><h3 id="内部类（lambda表达式）"><a href="#内部类（lambda表达式）" class="headerlink" title="内部类（lambda表达式）"></a>内部类（lambda表达式）</h3><p> 静态内部类、成员内部类、<strong>匿名内部类</strong></p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//静态内部类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Outer</span>&#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">inner</span>&#123;...&#125;<br>&#125;<br><span class="hljs-comment">//成员内部类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Outer</span>&#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">inner</span>&#123;...&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p> &#x3D;&#x3D;匿名内部类&#x3D;&#x3D;：方便创建子类对象，简化代码的书写  (可以将构造器作为参数直接传入方法)</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Employee</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Employee</span>()&#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">work</span><span class="hljs-params">()</span>&#123;...&#125;<br>&#125;;<br>a.work();<br></code></pre></td></tr></table></figure>

<p> &#x3D;&#x3D;Lambda表达式&#x3D;&#x3D;：<strong>简化匿名内部类的代码写法</strong>！！<br>                     (只能简化&#x3D;&#x3D;函数式接口&#x3D;&#x3D;的匿名内部类的写法)<br> 函数式接口：接口中只有一个抽象方法的形式  <strong>@FunctionalInterface</strong></p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Lambda的格式</span><br><span class="hljs-comment">//(匿名内部类被重写方法的形参列表) -&gt; &#123;</span><br><span class="hljs-comment">//	重写的方法体；</span><br><span class="hljs-comment">//&#125;</span><br><br><span class="hljs-comment">//简化Arrays.sort Comparator接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Lambda</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Integer[] ages = &#123;<span class="hljs-number">34</span>,<span class="hljs-number">12</span>,<span class="hljs-number">42</span>,<span class="hljs-number">23</span>&#125;;<br>        Arrays.sort(ages, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Integer&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Integer o1, Integer o2)</span> &#123;<br>                <span class="hljs-keyword">return</span> o1-o2;<span class="hljs-comment">//升序</span><br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;<br>简化为👇<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Lambda</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Integer[] ages = &#123;<span class="hljs-number">34</span>,<span class="hljs-number">12</span>,<span class="hljs-number">42</span>,<span class="hljs-number">23</span>&#125;;<br>        Arrays.sort(ages, (o1, o2) -&gt; &#123;<br>            <span class="hljs-keyword">return</span> o1-o2;<span class="hljs-comment">//升序</span><br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p> <img src="/assets/image-20220723155911-tg5026n.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p> ‍</p>
<p> ‍</p>
</li>
<li><h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span>&#123;<br>   sum(<span class="hljs-number">10</span>);<br>   sum(<span class="hljs-number">10</span>,<span class="hljs-number">20</span>)<br>   ...<span class="hljs-comment">//都是合理的</span><br>&#125;<br><span class="hljs-comment">//传入就是一个数组</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> ... sum)</span>&#123;...&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<h1 id="·-核心类库-API"><a href="#·-核心类库-API" class="headerlink" title="· 核心类库(API)"></a>· <strong>核心类库</strong>(API)</h1><ol>
<li><h3 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h3><p> 使用构造器创建 <code>new String()</code> 👉 堆内存 👉 不同地址</p>
<p> 使用<code>“str”</code>​创建 👉 常量池 👉 相同地址</p>
<p> &#x3D;&#x3D;String类API&#x3D;&#x3D;</p>
<p> <strong>和长度有关的方法</strong><br> 返回类型      方法名               作用<br>  int        length()        得到一个字符串的字符个数（一个中文是一个字符，一个英文是一个字符，一个转义字符是一个字符）</p>
<p> <strong>和数组有关的方法</strong><br> 返回类型        方法名             作用<br> byte[]        getBytes()       将一个字符串转换成字节数组<br> char[]        toCharArray()    将一个字符串转换成字符数组<br> String[]      split(String)    将一个字符串按照指定内容劈开</p>
<p> <strong>和判断有关的方法</strong><br> 返回类型        方法名                         作用<br> boolean       equals(String)                判断两个字符串的内容是否一模一样<br> boolean       equalsIgnoreCase(String)      忽略大小写的比较两个字符串的内容是否一模一样<br> boolean       contains(String)              判断一个字符串里面是否包含指定的内容<br> boolean       startsWith(String)            判断一个字符串是否以指定的内容开头<br> boolean       endsWith(String)              判断一个字符串是否以指定的内容结尾</p>
<p> <strong>和改变内容有关的方法</strong><br>  <strong>和改变内容有关的方法，都不会直接操作原本的字符串<br> 而是将符合条件的字符串返回给我们，所以注意接收</strong><br> 返回类型        方法名                         作用<br> String        toUpperCase()                 将一个字符串全部转换成大写<br> String        toLowerCase()                 将一个字符串全部转换成小写<br> String        replace(String,String)        将某个内容全部替换成指定内容<br> String        replaceAll(String,String)     将某个内容全部替换成指定内容，支持正则<br> String        repalceFirst(String,String)   将第一次出现的某个内容替换成指定的内容<br> String        substring(int)                从指定下标开始一直截取到字符串的最后<br> String        substring(int,int)            从下标x截取到下标y-1对应的元素<br> String        trim()                        去除一个字符串的前后空格</p>
<p> <strong>和位置有关的方法</strong><br> 返回类型        方法名                     作用<br> char          charAt(int)               得到指定下标位置对应的字符<br> int           indexOf(String)           得到指定内容第一次出现的下标<br> int           lastIndexOf(String)       得到指定内容最后一次出现的下标</p>
</li>
<li><h3 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h3><ol>
<li><p><strong>toString</strong>​ <strong>()</strong></p>
<p> 返回当前对象的地址<br> 需要自己重写方法来实现具体功能</p>
</li>
<li><p><strong>equals()</strong></p>
<p> 判断对象是否相等(基本类型&amp;String-compare value；引用类型-compare LOC)，instanceof&#x2F;强转等</p>
<p> 重写后一般连着<code>hashcode()</code>一块重写，因为equals不再具有’&#x3D;&#x3D;’的从地址判断的功能，而两个对象hashcode相同<br> 对象并不一定相同(也就是hashcode相同，equals的结果可能仍不同)</p>
</li>
</ol>
</li>
<li><h3 id="Objects类"><a href="#Objects类" class="headerlink" title="Objects类"></a>Objects类</h3><p> 继承于Object类，<code>Objects.equals(a,b)</code>写法更安全（null不报错）</p>
</li>
<li><h3 id="StringBuilder-StringBuffer类"><a href="#StringBuilder-StringBuffer类" class="headerlink" title="StringBuilder&amp;&amp;StringBuffer类"></a>StringBuilder&amp;&amp;StringBuffer类</h3><p> 可变string类，可看作对象容器，好处就是不用创建新的string对象</p>
<p> <code>StringBuilder a = new StringBuilder()</code>,append()、reverse()、length()</p>
<ol>
<li><h4 id="字符修改上的区别"><a href="#字符修改上的区别" class="headerlink" title="字符修改上的区别"></a>字符修改上的区别</h4><p> StringBuilder的<strong>修改效率高</strong>，但<strong>非线程安全</strong>（不能同步访问）；StringBuffer恰恰相反</p>
</li>
<li><h4 id="继承结构"><a href="#继承结构" class="headerlink" title="继承结构"></a>继承结构</h4><p> <img src="/assets/image-20220731160921-nvebuyu.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
</li>
<li><h4 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h4><p> StringBuffer 每次获取 toString 都会直接使用缓存区的 toStringCache 值来构造一个字符串。</p>
<p> 而 StringBuilder 则每次都需要复制一次字符数组，再构造一个字符串。</p>
</li>
</ol>
</li>
<li><h3 id="Math类"><a href="#Math类" class="headerlink" title="Math类"></a>Math类</h3><p> <strong>都是静态方法，可以通过类名直接调用</strong></p>
<p> <img src="/assets/image-20220720100427-v0oqzuh.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
</li>
<li><h3 id="System类"><a href="#System类" class="headerlink" title="System类"></a>System类</h3><p> <img src="/assets/image-20220720101631-8ykfzxj.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
</li>
<li><h3 id="BigDecimal类（大数据类型）"><a href="#BigDecimal类（大数据类型）" class="headerlink" title="BigDecimal类（大数据类型）"></a>BigDecimal类（大数据类型）</h3><p> 解决浮点型运算精度失真</p>
<p> 调用  <strong>.valueof()</strong> 方法获取BD对象</p>
</li>
<li><h3 id="日期类"><a href="#日期类" class="headerlink" title="日期类"></a>日期类</h3><ol>
<li><p><strong>Date类</strong></p>
<p> 时间毫秒值可以用来方便计算日期对象<br> <code>System.currentTimeMills()</code>获取系统<strong>时间毫秒值</strong><br> <code>Date d = new Date(时间毫秒值对象)</code>or<code>d.setTime(时间毫秒值对象)</code>可以将<strong>时间毫秒值转为日期对象</strong></p>
<p> <img src="/assets/image-20220721101716-haizfcz.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
</li>
<li><p><strong>SimpleDateFormat类</strong></p>
<p> <u>Date对象</u>或<u>时间毫秒值</u>​<strong>格式化</strong>为<code>年月日时间</code>的时间形式</p>
<p> <img src="/assets/image-20220720105025-25cea3l.png" srcset="/img/loading.gif" lazyload alt="image.png"><br> 字符串时间形式<strong>解析</strong>成日期对象<br> <code>public Date parse(String source)</code></p>
<p> <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_26817225/article/details/93593989">https://blog.csdn.net/qq_26817225&#x2F;article&#x2F;details&#x2F;93593989</a> 对于年代标识符的使用</p>
</li>
<li><p><strong>Calendar类</strong>（抽象类，不能直接创建对象）</p>
<p> <img src="/assets/image-20220720121209-6m6cwib.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
</li>
<li><p><strong>JDK8的新增日期API</strong></p>
<p> <img src="/assets/image-20220721115721-mngpsif.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p> &#x3D;&#x3D;LocalDate、LocalTime、LocalDateTime&#x3D;&#x3D;：<code>of()</code>设定时间，<code>now()</code>获取当前时间…</p>
<p> &#x3D;&#x3D;Instant&#x3D;&#x3D;： 时间戳，类似<code>System.currentTimeMillis()</code><br>           <code>.now()</code>方法默认获取世界标准时间，不是东八区时间<br>           Date与Instant对象互转，<code>Date.from(Instant)</code>,<code>Date.toInstant()</code><br> &#x3D;&#x3D;DateTimeFormatter&#x3D;&#x3D;：</p>
<p> <strong>格式化format：</strong><br> ​<img src="/assets/image-20220721151606-e83l1ev.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p> <strong>解析parse：</strong><br> ​<img src="/assets/image-20220721152132-bl3cg9n.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p> &#x3D;&#x3D;Duration || Period&#x3D;&#x3D;：计算时间跨度</p>
<p> <strong>Period对应日期操作,Duration对应时间操作</strong></p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Period</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> Period.between(a,b)<span class="hljs-comment">//a,b都是LocalDate对象，默认用b-a</span><br><span class="hljs-comment">//Duration用于更精细的操作</span><br><span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">today</span> <span class="hljs-operator">=</span> LocalDateTime.now();<br><span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">birth</span> <span class="hljs-operator">=</span> LocalDateTime.of(<span class="hljs-number">2001</span>,<span class="hljs-number">11</span>,<span class="hljs-number">25</span>,<span class="hljs-number">0</span>,<span class="hljs-number">5</span>,<span class="hljs-number">0</span>);<br><span class="hljs-type">Duration</span> <span class="hljs-variable">duration</span> <span class="hljs-operator">=</span> Duration.between(birth,today);<br></code></pre></td></tr></table></figure>

<p> &#x3D;&#x3D;可以用ChronoUnit简化&#x3D;&#x3D;</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">today</span> <span class="hljs-operator">=</span> LocalDateTime.now();<br><span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">birth</span> <span class="hljs-operator">=</span> LocalDateTime.of(<span class="hljs-number">2001</span>,<span class="hljs-number">11</span>,<span class="hljs-number">25</span>,<span class="hljs-number">0</span>,<span class="hljs-number">5</span>,<span class="hljs-number">0</span>);<br>ChronoUnit.YEARS.between(birth,today).sout;<br></code></pre></td></tr></table></figure></li>
</ol>
</li>
<li><h3 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h3><p> <img src="/assets/image-20220721155922-3m1wuvz.png" srcset="/img/loading.gif" lazyload alt="image.png"><img src="/assets/image-20220721160346-dxvlw2i.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p> &#x3D;&#x3D;Parsexxx可以用valueOf替代&#x3D;&#x3D;</p>
</li>
<li><h3 id="Arrays类"><a href="#Arrays类" class="headerlink" title="Arrays类"></a>Arrays类</h3><p> 对所有数组类型可以操作</p>
<p> toString、sort、binarySearch等</p>
<p> Comparater接口用来&#x3D;&#x3D;制定比较器规则&#x3D;&#x3D;（当sort对象为<u>自定义类对象</u>时非常好用）</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">Array.sort(array, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparater</span>&lt;Student&gt;()&#123;<br>   <span class="hljs-meta">@override</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Student o1, Student o2)</span>&#123;<br>       <span class="hljs-comment">//制定比较规则</span><br>       <span class="hljs-keyword">return</span> o2.getAge()-o1.getAge();<span class="hljs-comment">//年龄降序排序</span><br>   &#125;<br>&#125;)<br></code></pre></td></tr></table></figure></li>
<li><h3 id="Java集合-Collection-框架-​-、Map框架"><a href="#Java集合-Collection-框架-​-、Map框架" class="headerlink" title="&#x3D;&#x3D;Java集合(Collection)框架&#x3D;&#x3D;​&#x3D;&#x3D;、Map框架&#x3D;&#x3D;"></a>&#x3D;&#x3D;Java集合(Collection)框架&#x3D;&#x3D;​&#x3D;&#x3D;、Map框架&#x3D;&#x3D;</h3><p> <img src="/assets/image-20220710170132-y8mpebm.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p> <img src="/assets/image-20220710170144-0rny6m1.png" srcset="/img/loading.gif" lazyload alt="image.png">&#x3D;&#x3D;框架统一于util包内&#x3D;&#x3D;</p>
<p> <strong>Collection集合的遍历</strong>：迭代器Iterator，foreach，lambda表达式(Collection不支持索引)</p>
<p> ‍</p>
<p> List集合：查询快，线性表（有序，有索引，可重复）<br> Set集合：增删改查都快，不重复集合<br> Map集合：键值对<br> Queue集合：队列</p>
<p> <img src="/assets/image-20220802155852-f8erj8f.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p> <strong>Collection特点</strong>：集合大小不固定，可以动态变化，类型也可以不固定（对基本数据类型的引用只能用<strong>包装类</strong>），非常适合做增删操作</p>
<ol>
<li><h4 id="List集合"><a href="#List集合" class="headerlink" title="List集合"></a>List集合</h4><p> ArrayList列表、LinkedList链表<br> <strong>Vecto****r</strong>与ArrayList原理相同，但使用了synchronized方法保证线程安全，因此性能略差<br> <strong>Stack</strong>继承自Vector，拓展了push、pop、peek(取堆栈顶点)、empty、search操作以实现后进先出的堆栈结构</p>
<p> &#x3D;&#x3D;ArrayList构造方法&#x3D;&#x3D;</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>方法功能</th>
</tr>
</thead>
<tbody><tr>
<td>ArrayList()</td>
<td>构造一个初始容量10的空列表</td>
</tr>
<tr>
<td>ArrayList(Collection c)</td>
<td>构造一个包含指定collection的元素的列表</td>
</tr>
<tr>
<td>ArrayList(int capacity)</td>
<td>构造一个指定初始容量的空列表</td>
</tr>
</tbody></table>
<p> ‍</p>
<table>
<thead>
<tr>
<th>List接口常用方法（Arraylist同用）</th>
</tr>
</thead>
<tbody><tr>
<td><strong>void add(int index, Object obj)</strong> <br />Inserts obj 插入到调用列表中的索引通过索引处。达到或超出插入点任何预先存在的要素被上移。因此，不会有元素被覆盖。</td>
</tr>
<tr>
<td><strong>boolean addAll(int index, Collection c)</strong> <br />插入c的所有元素入索引通过索引处的调用列表。等于或超出插入点任何预先存在的要素被上移。因此，没有任何元素被覆盖。如果调用列表更改并返回true，否则返回false。</td>
</tr>
<tr>
<td><strong>Object get(int index)</strong> <br />返回存储调用集合中指定索引处的对象。</td>
</tr>
<tr>
<td><strong>int indexOf(Object obj)</strong> <br />返回调用列表obj的第一个实例的索引。如果obj不是列表中的一个元素，则返回-1。</td>
</tr>
<tr>
<td><strong>int lastIndexOf(Object obj)</strong> <br />返回调用列表obj的最后一个实例的索引。如果obj不是列表中的一个元素，则返回-1。</td>
</tr>
<tr>
<td><strong>ListIterator listIterator( )</strong> <br />返回一个迭代器调用列表的开始。</td>
</tr>
<tr>
<td><strong>List Iterator list Iterator(int index)</strong> <br />返回一个迭代器调用列表开头的在指定索引处。</td>
</tr>
<tr>
<td><strong>Object remove(int index)</strong> <br />从调用列表删除index位置的元素，并返回被删除的元素。结果列表中被压缩。也就是说，随后的元素的索引减一。</td>
</tr>
<tr>
<td><strong>Object set(int index, Object obj)</strong> <br />赋予obj转换通过索引调用列表中指定的位置。</td>
</tr>
<tr>
<td><strong>List subList(int start, int end)</strong> <br />返回一个列表，其中包括在调用列表，从开始元素end-1。在返回列表中的元素也被调用对象的引用。</td>
</tr>
</tbody></table>
</li>
<li><h4 id="泛型深入"><a href="#泛型深入" class="headerlink" title="泛型深入"></a>泛型深入</h4><ol>
<li><p><strong>泛型类</strong></p>
<p> <code>public class myClass&lt;E&gt;&#123;...&#125;</code>→创建类对象时<code>myClass&lt;包装类&gt; list = new myClass&lt;&gt;()</code>，<strong>限定对象的成员类型</strong></p>
</li>
<li><p><strong>泛型方法</strong></p>
<p> <code>public &lt;T&gt; void show(T t)</code>,<strong>使用泛型接受一切类型的参数，更具有通用性</strong></p>
</li>
<li><p><strong>泛型接口</strong></p>
<p> <code>public interface Data&lt;E&gt;&#123;...&#125;</code>，<strong>让实现类选择当前功能需要的数据类型</strong></p>
</li>
<li><p><strong>泛型通配符、上下限</strong></p>
<p> <code>？</code>在 <u>使用泛型</u> 的时候代表一切类型（ETKV是在定义泛型使用的）</p>
<p> <img src="/assets/image-20220731105938-tnp12jm.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
</li>
</ol>
</li>
<li><h4 id="Set集合"><a href="#Set集合" class="headerlink" title="Set集合"></a>Set集合</h4><p> <img src="/assets/image-20220731164725-2y2ej48.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<ol>
<li><p><strong>HashSet</strong></p>
<ul>
<li><p><strong>无序的底层原理</strong>：哈希表（数组+链表+红黑树）</p>
<p>哈希值：根据对象地址，按某种规则计算得到的int数值，可以直接用Object类下的<code>public int hashCode()</code>获取</p>
<p><img src="/assets/image-20220801115235-ipy2rbo.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p><u>Step4的equals()方法和hashCode()方法需要重写</u></p>
<p><u>JDK8以后，如果链表长度超过8，会自动转为红黑树</u></p>
<p><img src="/assets/image-20220801115648-sbn7zzf.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p><img src="/assets/image-20220801115933-m4y6xjf.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
</li>
<li><p><strong>去重的底层原理</strong>：先判断Hash值，再判断equals()，<u>Override Object类中的hashCode和equals才能正确去重</u></p>
</li>
</ul>
</li>
<li><p><strong>LinkedHashSet</strong></p>
<p> <img src="/assets/image-20220801140514-yckzx4d.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p> ‍</p>
</li>
<li><p><strong>TreeSet</strong></p>
<p> <img src="/assets/image-20220802153814-iavkcf3.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p> 包装类按照大小、首字符编号等排序，<u>自定义对象需要自定义排序规则</u>  👇</p>
<p> <img src="/assets/image-20220802154703-m6a8jg2.png" srcset="/img/loading.gif" lazyload alt="image.png"><img src="/assets/image-20220802154937-t9ekqny.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p> 浮点型比较直接用<code>Double.compare()</code></p>
</li>
</ol>
</li>
<li><h4 id="Map集合"><a href="#Map集合" class="headerlink" title="&#x3D;&#x3D;Map集合&#x3D;&#x3D;"></a>&#x3D;&#x3D;Map集合&#x3D;&#x3D;</h4><p> 键值对集合（双列集合），每个元素有key，value俩值{key1&#x3D;value1，key2&#x3D;value2，…}</p>
<p> 特点：<strong>HashMap、TreeMap、LinkedHashMap</strong>作为重点，key无序不重复（后覆盖前），value可以有多个key。  </p>
<ul>
<li>HashMap：无序、不重复、无索引</li>
<li>LinkedHashMap：有序、不重复、无索引</li>
</ul>
<p> <strong>常用API</strong>：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">map.put(<span class="hljs-string">&quot;key_1&quot;</span>,<span class="hljs-number">1</span>);               <span class="hljs-comment">// 添加键值对,已有 key 则覆盖 value</span><br>map.putIfAbsent(<span class="hljs-string">&quot;key_2&quot;</span>,<span class="hljs-number">2</span>);       <span class="hljs-comment">// 添加键值对,已有 key 则不操作</span><br><br>map.remove(<span class="hljs-string">&quot;key_1&quot;</span>);              <span class="hljs-comment">// 删除键值对（按值）           </span><br>map.remove(<span class="hljs-string">&quot;key_2&quot;</span>,<span class="hljs-number">2</span>);            <span class="hljs-comment">// 删除键值对（按键值）</span><br><br>map.get(<span class="hljs-string">&quot;key_1&quot;</span>);                 <span class="hljs-comment">// 获取值, key 不存在返回null</span><br>map.getOrDefault(<span class="hljs-string">&quot;key_2&quot;</span>,-<span class="hljs-number">1</span>);     <span class="hljs-comment">// 获取值, key 不存在返回默认值</span><br><br>map.containsKey(<span class="hljs-string">&quot;key_1&quot;</span>);         <span class="hljs-comment">// 判断 key 是否存在  </span><br>map.containsValue(<span class="hljs-number">1</span>);             <span class="hljs-comment">// 判断 value 是否存在      </span><br><br>map.keySet();<br>map.values();<br></code></pre></td></tr></table></figure>

<p> &#x3D;&#x3D;遍历的3种方式&#x3D;&#x3D;</p>
<ul>
<li><p><strong>键找值</strong></p>
<p>Step1. 拿keySet集合<br>Step2. 遍历每个键，用键提取值，<code>value = maps.get(key)</code></p>
</li>
<li><p><strong>键值对</strong></p>
<p>Step1. 将Map转化为Set集合，使用Map的实体类型<code>Set&lt;Map.Entry&lt;String,Integer&gt;&gt; entries = maps.entrySet();</code><br>Step2. foreach遍历<code> for(Map.Entry&lt;String,Integer&gt; entry : entries)&#123;entry.getKey / entry.getValue&#125;</code></p>
</li>
<li><p><strong>Lambda</strong></p>
<p>利用Map中的 <code>forEach(BiConsumer&lt;? super K,? super V&gt; action)</code> 方法<br>实现：<code>maps.foreach((k,v) -&gt;&#123;...&#125;)</code></p>
</li>
</ul>
<ol>
<li><p><strong>HashMap</strong></p>
<p> <img src="/assets/image-20220806164524-ekumbs3.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
</li>
<li><p><strong>TreeMap</strong></p>
<p> <img src="/assets/image-20220806164828-szdvexz.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
</li>
<li><p><strong>LinkedHashMap</strong></p>
<p> <img src="/assets/image-20220806164718-0f5mfwq.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
</li>
</ol>
</li>
</ol>
</li>
<li><h3 id="补充：集合工具类Collections"><a href="#补充：集合工具类Collections" class="headerlink" title="补充：集合工具类Collections"></a>补充：集合工具类Collections</h3><p> 不属于Collection家族，是一个辅助工具，具体参照API文档，addAll、shuffle、sort等</p>
<p> <img src="/assets/image-20220802161516-3vs7mbp.png" srcset="/img/loading.gif" lazyload alt="image.png"><img src="/assets/image-20220802161653-ize6dfk.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
</li>
<li><h3 id="补充：集合的嵌套"><a href="#补充：集合的嵌套" class="headerlink" title="补充：集合的嵌套"></a>补充：集合的嵌套</h3><p> <img src="/assets/image-20220806171516-grgj1sf.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
</li>
</ol>
<p>‍</p>
<p>‍</p>
<h1 id="·-正则表达式"><a href="#·-正则表达式" class="headerlink" title="· 正则表达式"></a><strong>· 正则表达式</strong></h1><p> **	用规定的字符制定规则，用来校验数据格式的合法性**</p>
<pre><code class="hljs">==API文档regex.pattern==  
![image.png](assets/image-20220722173410-36y2pfy.png)

String的一些方法（如split、replace）都可以使用正则表达式传参

==正则表达式爬取信息==
</code></pre>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RegularExpression</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;电影名称：《我和我的祖国》，票价：43元，联系电话：400-100-3233，邮箱地址：xyf@scnu.com&quot;</span> +<br>                <span class="hljs-string">&quot;电影名称：《闯江湖》，票价：63元，联系电话：400-100-2020，邮箱地址：xyf@126.com.cn&quot;</span>;<br>        <span class="hljs-comment">//爬取规则</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">regex</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;(《\\W&#123;1,10&#125;》)|(\\d+元)|(400-?\\d&#123;3,9&#125;-\\d&#123;3,9&#125;)|(\\w&#123;1,30&#125;@[a-zA-Z0-9]&#123;2,20&#125;(\\.[a-zA-Z0-9]&#123;2,20&#125;)&#123;1,2&#125;)&quot;</span>;<br>        <span class="hljs-comment">//爬取规则编译为匹配对象</span><br>        <span class="hljs-type">Pattern</span> <span class="hljs-variable">pattern</span> <span class="hljs-operator">=</span> Pattern.compile(regex);<br>        <span class="hljs-comment">//得到一个内容匹配器对象</span><br>        <span class="hljs-type">Matcher</span> <span class="hljs-variable">matcher</span> <span class="hljs-operator">=</span> pattern.matcher(rs);<br>        <span class="hljs-comment">//开始爬取</span><br>        <span class="hljs-keyword">while</span> (matcher.find())&#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">rs1</span> <span class="hljs-operator">=</span> matcher.group();<br>            System.out.println(rs1);<br>        &#125;<br>    &#125;<br>&#125;<br>    OUT&#123;<br>        《我和我的祖国》<br>        <span class="hljs-number">43</span>元<br>        <span class="hljs-number">400</span>-<span class="hljs-number">100</span>-<span class="hljs-number">3233</span><br>        xyf<span class="hljs-meta">@scnu</span>.com<br>        《闯江湖》<br>        <span class="hljs-number">63</span>元<br>        <span class="hljs-number">400</span>-<span class="hljs-number">100</span>-<span class="hljs-number">2020</span><br>        xyf@<span class="hljs-number">126.</span>com.cn<br>    &#125;<br></code></pre></td></tr></table></figure>

<h1 id="·-Stream流体系"><a href="#·-Stream流体系" class="headerlink" title="· Stream流体系"></a>· <strong>Stream流体系</strong></h1><ol>
<li><h3 id="不可变集合（list，set，map）"><a href="#不可变集合（list，set，map）" class="headerlink" title="不可变集合（list，set，map）"></a>不可变集合（list，set，map）</h3><p> <code>List&lt;T&gt; lists = list.of(...)</code>不允许<code>add，set</code>操作</p>
</li>
<li><h3 id="Stream流"><a href="#Stream流" class="headerlink" title="Stream流"></a>Stream流</h3><p> <strong>目的：结合Lambda表达式，简化集合和数组操作的API</strong>（不会影响原集合结构（无增删改））</p>
<p> <img src="/assets/image-20220807173135-7qmk6i4.png" srcset="/img/loading.gif" lazyload alt="image.png"><img src="/assets/image-20220807173231-qurlsxs.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Map集合获取流</span><br>Map&lt;String, Integer&gt; maps = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><span class="hljs-comment">//key stream</span><br>Stream&lt;String&gt; a = maps.KeySet().stream();<br><span class="hljs-comment">//value stream</span><br>Stream&lt;String&gt; b = maps.values().stream();<br><span class="hljs-comment">//key-value steam</span><br>Stream&lt;Maps.Entry&lt;String,Integer&gt;&gt; c = maps.entrySet().stream();<br><br><span class="hljs-comment">//数组获取流</span><br>Arrays.stream()<br><span class="hljs-comment">//或者</span><br>Stream&lt;String&gt; a = Stream.of() <br></code></pre></td></tr></table></figure>

<h4 id="Stream流的常用API"><a href="#Stream流的常用API" class="headerlink" title="Stream流的常用API"></a>Stream流的常用API</h4><table>
<thead>
<tr>
<th align="center">方法名称</th>
<th align="center">方法作用</th>
<th align="center">方法种类</th>
<th align="center">是否支持链式调用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">count</td>
<td align="center">统计个数</td>
<td align="center">终结方法</td>
<td align="center">否</td>
</tr>
<tr>
<td align="center">forEach</td>
<td align="center">逐一处理</td>
<td align="center">终结方法</td>
<td align="center">否</td>
</tr>
<tr>
<td align="center">filter</td>
<td align="center">过滤</td>
<td align="center">函数拼接</td>
<td align="center">是</td>
</tr>
<tr>
<td align="center">limit</td>
<td align="center">取用前几个</td>
<td align="center">函数拼接</td>
<td align="center">是</td>
</tr>
<tr>
<td align="center">skip</td>
<td align="center">跳过前几个</td>
<td align="center">函数拼接</td>
<td align="center">是</td>
</tr>
<tr>
<td align="center">map</td>
<td align="center">映射</td>
<td align="center">函数拼接</td>
<td align="center">是</td>
</tr>
<tr>
<td align="center">concat</td>
<td align="center">组合</td>
<td align="center">函数拼接</td>
<td align="center">是</td>
</tr>
</tbody></table>
<p> 注：<u>终结方法</u>：返回值类型不再是Stream接口本身类型的方法<br>    <u>非终结方法&#x2F;延迟方法</u>：返回值类型仍然是Stream接口自身类型的方法，除了终结方法都是延迟方法。</p>
<h4 id="Stream流-to-Collection"><a href="#Stream流-to-Collection" class="headerlink" title="Stream流 to Collection"></a>Stream流 to Collection</h4> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>list2.add(<span class="hljs-string">&quot;张老三&quot;</span>);<br>list2.add(<span class="hljs-string">&quot;张小三&quot;</span>);<br>list2.add(<span class="hljs-string">&quot;李四&quot;</span>);<br>list2.add(<span class="hljs-string">&quot;赵五&quot;</span>);<br>list2.add(<span class="hljs-string">&quot;张六&quot;</span>);<br>list2.add(<span class="hljs-string">&quot;王八&quot;</span>);<br>     <br><span class="hljs-comment">// 需求：过滤出姓张的并且长度为3的元素</span><br>Stream&lt;String&gt; stream = list2.stream().filter(name -&gt; name.startsWith(<span class="hljs-string">&quot;张&quot;</span>)).filter(name -&gt; name.length() == <span class="hljs-number">3</span>);<br>     <br><span class="hljs-comment">// stream 收集到单列集合中</span><br>List&lt;String&gt; list = stream.collect(Collectors.toList());<br>System.out.println(list);<br>     <br><span class="hljs-comment">// stream 收集到单列集合中</span><br>Set&lt;String&gt; set = stream.collect(Collectors.toSet());<br>System.out.println(set);<br></code></pre></td></tr></table></figure></li>
</ol>
<h1 id="·-异常处理"><a href="#·-异常处理" class="headerlink" title="· 异常处理"></a><strong>· 异常处</strong>理</h1><p><img src="/assets/image-20220809103437-xbqysho.png" srcset="/img/loading.gif" lazyload alt="image.png">​</p>
<p>​<code>Error</code>​异常是系统级别的严重错误，是不可操作的；<code>Exception</code>​异常分为运行时异常<code>RuntimeException</code>​和编译时异常<code>other</code>​</p>
<ol>
<li><h3 id="异常处理方式"><a href="#异常处理方式" class="headerlink" title="异常处理方式"></a>异常处理方式</h3><ul>
<li><p><strong>throws</strong> ：<code>function throws Exceptions&#123;...&#125;</code></p>
</li>
<li><p><strong>try catch</strong> :</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span>&#123;<br>  <span class="hljs-comment">//需要监视的代码段</span><br>&#125;<span class="hljs-keyword">catch</span>(异常类型<span class="hljs-number">1</span> e)&#123;<br>  <span class="hljs-comment">//处理方式</span><br>  e.printStackTrace();<br>&#125;<span class="hljs-keyword">catch</span>(异常类型<span class="hljs-number">2</span> e)&#123;<br>  <span class="hljs-comment">//处理方式</span><br>&#125;<br><span class="hljs-comment">//企业级写法</span><br><span class="hljs-keyword">catch</span>(Exception e)&#123;<br>  e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p><strong>调用者决定</strong> ：function将exception throw给上层调用者，上层调用者再做try catch决定如何处理</p>
</li>
</ul>
<p> RuntimeException可以在最外层try catch</p>
</li>
<li><h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><ol>
<li><h4 id="自定义编译时异常"><a href="#自定义编译时异常" class="headerlink" title="自定义编译时异常"></a>自定义编译时异常</h4><p> 定义一个异常类继承Exception -&gt; 重写构造器 -&gt; 出现异常的地方用<code>throw new</code>抛出</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//出现异常的地方用`throw new`抛出</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String arg[])</span>&#123;<br>    <span class="hljs-keyword">try</span>&#123;checkAge(-<span class="hljs-number">23</span>)&#125;<br>    <span class="hljs-keyword">catch</span>(xyfAgeIllegalException e)&#123;e.printStackTrace();&#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">checkAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> <span class="hljs-keyword">throws</span> xyfAgeIllegalException&#123;<br>    <span class="hljs-keyword">if</span> (age&lt;<span class="hljs-number">0</span>||age&gt;<span class="hljs-number">200</span>)&#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">xyfAgeIllegalException</span>(age + <span class="hljs-string">&quot;is illegal!&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        sout(<span class="hljs-string">&quot;年龄合法！&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//重写构造器</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">xyfAgeIllegalException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Exception</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">xyfAgeIllegalException</span><span class="hljs-params">()</span>&#123;&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">xyfAgeIllegalException</span><span class="hljs-params">(String message)</span>&#123;<span class="hljs-built_in">super</span>(message);&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><h4 id="自定义运行时异常"><a href="#自定义运行时异常" class="headerlink" title="自定义运行时异常"></a>自定义运行时异常</h4><p> 定义一个异常类继承RuntimeException -&gt; 重写构造器 -&gt; 出现异常的地方用<code>throw new</code>抛出</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//出现异常的地方用`throw new`抛出</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String arg[])</span>&#123;<br>    <span class="hljs-keyword">try</span>&#123;checkAge(-<span class="hljs-number">23</span>)&#125;<br>    <span class="hljs-keyword">catch</span>(xyfAgeIllegalRuntimeException e)&#123;e.printStackTrace();&#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">checkAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> <span class="hljs-keyword">throws</span> xyfAgeIllegalRuntimeException&#123;<br>    <span class="hljs-keyword">if</span> (age&lt;<span class="hljs-number">0</span>||age&gt;<span class="hljs-number">200</span>)&#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">xyfAgeIllegalRuntimeException</span>(age + <span class="hljs-string">&quot;is illegal!&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        sout(<span class="hljs-string">&quot;年龄合法！&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//重写构造器</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">xyfAgeIllegalRuntimeException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RuntimeException</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">xyfAgeIllegalException</span><span class="hljs-params">()</span>&#123;&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">xyfAgeIllegalException</span><span class="hljs-params">(String message)</span>&#123;<span class="hljs-built_in">super</span>(message);&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h1 id="·-日志技术"><a href="#·-日志技术" class="headerlink" title="· 日志技术"></a><strong>· 日志技术</strong></h1><p><strong>Advantage：</strong> 可以将日志信息写入文件或数据库 + 不需修改代码，灵活性好 + 多线程性能较好</p>
<ol>
<li><h3 id="Logback框架"><a href="#Logback框架" class="headerlink" title="Logback框架"></a>Logback框架</h3><ul>
<li><p><strong>三个技术模块</strong><br>logback-core：为其他俩模块奠定基础<br>logback-classic：Log4j的改良版本，且完整实现了<u>slf4j的API</u>（日志规范）<br>logback-access：与Tomcat &amp;&amp; Jetty等Servlet容器集成，以提供HTTP访问日志功能</p>
</li>
<li><p><strong>Logback入门</strong></p>
<p>S1. 导入jar包（logback-classic.jar, logback-core.jar, slf4j-api.jar），至新建的lib文件夹下<br>S2. logback.xml拷贝到src目录下<br>S3. 代码中获取日志的对象<code>public static final logger LOGGER = LoggerFactory.getLogger(&quot;类对象&quot;);</code><br>S4. 使用日志对象输出日志</p>
</li>
<li><p><strong>Logback配置</strong></p>
<p>通过 <u>logback.xml</u> 配置，可以设置<u>日志输出位置和格式</u></p>
<p>&#x3D;&#x3D;日志输出位置和格式设置&#x3D;&#x3D;<br><appender>可以设置输出位置(CONSOLE or FILE)和日志信息的详细格式</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;CONSOLE&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;...&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">target</span>&gt;</span>System.out<span class="hljs-tag">&lt;/<span class="hljs-name">target</span>&gt;</span> <span class="hljs-comment">&lt;!--.err打红色 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">encoder</span>&gt;</span><br>      <span class="hljs-comment">&lt;!--format输出。%d-日期 %thread-线程名 %-5level-level从左显示5个字符宽度 %msg-日志消息--&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%-5level] %c[%thread] : %msg%n<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">charset</span>&gt;</span>utf-8<span class="hljs-tag">&lt;/<span class="hljs-name">charset</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--输出路径--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">file</span>&gt;</span>C:/code/code1.log<span class="hljs-tag">&lt;/<span class="hljs-name">file</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">rollingPolicy</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;...&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">fileNamePattern</span>&gt;</span>C:/code/code-%d&#123;yyyy-MMdd&#125;.log%i.gz<span class="hljs-tag">&lt;/<span class="hljs-name">fileNamePattern</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">maxFileSize</span>&gt;</span>1MB<span class="hljs-tag">&lt;/<span class="hljs-name">maxFileSize</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">rollingPolicy</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span><br><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">&lt;root&gt; -&gt; &lt;appender-ref&gt;不配置就不记录</span><br><span class="hljs-comment">level用来设置打印级别，有TRACE,DEBUG,INFO,WARN,ERROR,ALL,OFF,default is debug</span><br><span class="hljs-comment">--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">root</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;ALL&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;CONSOLE&quot;</span> /&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;FILE&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;日志级别设置&#x3D;&#x3D;</p>
<p>日志级别有 TRACE&lt;DEBUG&lt;INFO&lt;WARN&lt;ERROR ,ALL,OFF，默认是debug，只输出级别高于设置级别的信息</p>
</li>
</ul>
</li>
</ol>
<h1 id="·-IO文件操作"><a href="#·-IO文件操作" class="headerlink" title="· IO文件操作"></a><strong>· IO文件操作</strong></h1><p><strong>File类</strong>可以定位和操作文件，但不能读写文件内容，<strong>I&#x2F;O流技术</strong>可以读写文件</p>
<p>一些预备知识点：File类使用，方法递归，字符集，I&#x2F;O流，字节流&amp;&amp;字符流</p>
<ol>
<li><h3 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h3><p> 代表了操作系统的文件对象（文件，文件夹）</p>
<p> <strong>主要功能：</strong> 定位文件，删除文件，获取文件信息，创建文件</p>
<p> 创建File对象：<code>File f = new File(&quot;C:/file/b.xlsx&quot;)</code>​👉pathname支持 <u>绝对路径</u> 和 <u>相对路径</u> （相对工程目录）<br> 字节长度：<code>f.length()</code>​<br> 获取绝对路径：<code>f.getAbsolutePath()</code>​<br> 获取定义的路径：<code>f.getPath()</code>​<br> 获取文件名称：<code>f.getName()</code>​<br> 获取文件的最后修改时间：<code>long time = f.lastModified()</code>​获得时间毫秒值<br>                                      <code>new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;).format()</code>​转换成人话<br> 判断是文件还是文件夹：<code>.isFile() .isDirectory()</code>​</p>
<p> 创建新文件：<code>f.createNewFile()</code>​ &#x2F;&#x2F;几乎不用，会自动创建<br> 创建一级目录：<code>f.mkdir()</code>​<br> 创建多级目录：<code>f.mkdirs()</code>​<br> 删除文件(夹)：<code>f.delete()</code>​ &#x2F;&#x2F;只能删除空文件夹</p>
<p> 获取当前目录下所有一级文件名称，返回到字符串数组：<code>public String list()</code>​<br> —————————–对象，返回文件对象数组：<code>public File listFiles()</code>​ &#x2F;&#x2F;调用者<u>不存在&#x2F;为文件</u>时返回null，空文件夹时返回空数组（包括隐藏文件）</p>
</li>
<li><h3 id="方法递归Recursion"><a href="#方法递归Recursion" class="headerlink" title="方法递归Recursion"></a>方法递归Recursion</h3><p> 复杂的问题 划分为 较小规模的问题</p>
<p> 基线情况 + 递归情况 + 递归公式向基线情况靠近</p>
<ul>
<li><h4 id="递归经典问题"><a href="#递归经典问题" class="headerlink" title="递归经典问题"></a>递归经典问题</h4><p><img src="/assets/image-20220811211111-nsuoy6g.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-comment">/**</span><br><span class="hljs-comment">x是第x天，f(x)是第x天摘的桃子</span><br><span class="hljs-comment">f(x) - f(x)/2 - 1 = f(x+1)</span><br><span class="hljs-comment">  */</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>      System.out.println(Peaches(<span class="hljs-number">1</span>));<br>  &#125;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">Peaches</span><span class="hljs-params">(<span class="hljs-type">int</span> day)</span>&#123;<br>      <span class="hljs-keyword">if</span>(day == <span class="hljs-number">10</span>)&#123;<br>          <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>      &#125;<br>      <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>*Peaches(day+<span class="hljs-number">1</span>)+<span class="hljs-number">2</span>;<br>      &#125;<br>  &#125;<br></code></pre></td></tr></table></figure></li>
<li><h4 id="非规律递归–文件搜索"><a href="#非规律递归–文件搜索" class="headerlink" title="非规律递归–文件搜索"></a>非规律递归–文件搜索</h4><p>遍历一级文件对象，判断是否是文件 → 如果是文件，是否是目标 → 如果是文件夹，返回步骤1</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>       <span class="hljs-comment">//X盘中找codeblocks.exe</span><br>       searchFile(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;X:/codeblocks&quot;</span>),<span class="hljs-string">&quot;codeblocks.exe&quot;</span>);<br>   &#125;<br><br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> dir 被搜索的源目录</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> fileName  被搜索的文件名称</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">searchFile</span><span class="hljs-params">(File dir,String fileName)</span>&#123;<br>       <span class="hljs-keyword">if</span> (dir!=<span class="hljs-literal">null</span>&amp;&amp;dir.isDirectory())&#123;<br>           <span class="hljs-comment">//可以找</span><br>           File[] files = dir.listFiles();<br>           <span class="hljs-comment">//防止拿了空文件夹</span><br>           <span class="hljs-keyword">if</span> (files!=<span class="hljs-literal">null</span>&amp;&amp;files.length&gt;<span class="hljs-number">0</span>)&#123;<br>               <span class="hljs-keyword">for</span> (File file : files) &#123;<br>                   <span class="hljs-comment">//进去之后判断当前是文件还是文件夹</span><br>                   <span class="hljs-keyword">if</span> (file.isFile())&#123;<br>                       <span class="hljs-keyword">if</span> (file.getName().contains(fileName))&#123;<br>                           System.out.println(<span class="hljs-string">&quot;找到了&quot;</span>+file.getAbsolutePath());<br>                       &#125;<br>                   &#125;<span class="hljs-keyword">else</span>&#123;<br>                       searchFile(file,fileName);<br>                   &#125;<br>               &#125;<br>           &#125;<br>       &#125;<span class="hljs-keyword">else</span> &#123;<br>           System.out.println(dir.getAbsolutePath()+<span class="hljs-string">&quot;不是文件夹&quot;</span>);<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure></li>
<li><h4 id="非规律递归–啤酒问题"><a href="#非规律递归–啤酒问题" class="headerlink" title="非规律递归–啤酒问题"></a>非规律递归–啤酒问题</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//定义一个static成员变量用于存储可以买的酒数量</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> totalNum;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> lastBottleNum;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> lastCoverNum;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        buy(<span class="hljs-number">10</span>);<br>        System.out.println(<span class="hljs-string">&quot;总数：&quot;</span> + totalNum);<br>        System.out.println(<span class="hljs-string">&quot;剩余盖子：&quot;</span> + lastCoverNum);<br>        System.out.println(<span class="hljs-string">&quot;剩余瓶子：&quot;</span> + lastBottleNum);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">buy</span><span class="hljs-params">(<span class="hljs-type">int</span> money)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">buyNum</span> <span class="hljs-operator">=</span> money / <span class="hljs-number">2</span>; <span class="hljs-comment">//第一次直接可以买的酒数量</span><br>        totalNum += buyNum;<br>        <span class="hljs-comment">//盖子和瓶子换算成钱</span><br>        <span class="hljs-comment">//统计本轮总的盖子数和瓶子数</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">coverNum</span> <span class="hljs-operator">=</span> lastCoverNum + buyNum;   <span class="hljs-comment">//盖子数 = 上一次的盖子数+传进来的money可以直接买的酒数</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">bottleNUm</span> <span class="hljs-operator">=</span> lastBottleNum + buyNum; <span class="hljs-comment">//类上</span><br>        <span class="hljs-comment">//统计可以换算的钱</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">allMoney</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (coverNum&gt;=<span class="hljs-number">4</span>)&#123;<br>            allMoney += (coverNum/<span class="hljs-number">4</span>)*<span class="hljs-number">2</span>;<br>        &#125;<br>        lastCoverNum = coverNum%<span class="hljs-number">4</span>;<br>        <span class="hljs-keyword">if</span> (bottleNUm&gt;=<span class="hljs-number">2</span>)&#123;<br>            allMoney += (bottleNUm/<span class="hljs-number">2</span>)*<span class="hljs-number">2</span>;<br>        &#125;<br>        lastBottleNum = bottleNUm%<span class="hljs-number">2</span>;<br><br>        <span class="hljs-keyword">if</span> (allMoney&gt;=<span class="hljs-number">2</span>)&#123;<br>            buy(allMoney);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><h3 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h3><p> <strong>ASCII</strong>，<strong>GBK</strong>(中国码表,兼容ASCII表,包含了几万个汉字,<u>一个中文以两个字节存储</u>)，<strong>Unicode</strong>(万国码,容纳大多数国家的符号和文字,<u>utf-8后中文以三个字节存储</u>)<br> ​<img src="/assets/image-20220815213502-pnk172y.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<ul>
<li><p><strong>编码解码操作</strong></p>
<p>编码 – <code>getBytes(&quot;GBK...&quot;)</code>​编码，返回字节数组</p>
<p>解码 – S<code>tring rs = new String(字节数组,&quot;GBK...&quot;)</code>​编解码前后的字符集必须一致，否则乱码</p>
</li>
</ul>
</li>
<li><h3 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h3><p> 磁盘与内存间的输入输出流，用以读写数据</p>
<p> 按传输的最小单位划分：字节流（音视频文件），字符流（纯文本文件）</p>
<p> <img src="/assets/image-20220821090533-j670u2d.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<ol>
<li><p><strong>字节流</strong></p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    一次读一个字节的FileInputStream(性能差，可能乱码)</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//创建一个文件字节输入流管道</span><br><span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(”path/File“);<br><span class="hljs-comment">//读取一个字节，返回</span><br><span class="hljs-type">int</span> <span class="hljs-variable">b1</span> <span class="hljs-operator">=</span> is.read();<br><span class="hljs-comment">//读取下一个，返回（未读到返回-1）</span><br><span class="hljs-type">int</span> <span class="hljs-variable">b2</span> <span class="hljs-operator">=</span> is.read();<br><span class="hljs-comment">//循环形式</span><br><span class="hljs-type">int</span> b;<br><span class="hljs-keyword">while</span>((b = is.read())!=-<span class="hljs-number">1</span>)&#123;...&#125;<br></code></pre></td></tr></table></figure>

 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    一次读一个字节数组的FileInputStream(可能乱码)</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(”path/File“);<br><span class="hljs-comment">//定义一个字节数组，用于读取()</span><br><span class="hljs-type">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">3</span>];<br><span class="hljs-type">int</span> len;<br><span class="hljs-keyword">while</span>((len = is.read(buffer)) != -<span class="hljs-number">1</span>)&#123;<br>    sout.<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(buffer,<span class="hljs-number">0</span>,len);<br>&#125;<br></code></pre></td></tr></table></figure>

 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    一次读完全部字节的FileInputStream(solve the messy code problem)</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(”path/File“);<br><span class="hljs-comment">//set buffer长度为文件字节长度(line6,7 is the same)</span><br><span class="hljs-type">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[(<span class="hljs-type">int</span>)f.length()]<br><span class="hljs-type">byte</span>[] buffer = is.readAllBytes();<br></code></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public void write(int a)</td>
<td>写一个字节出去</td>
</tr>
<tr>
<td>public void write(byte[] buffer)</td>
<td>写一个字节数组</td>
</tr>
<tr>
<td>public void write(byte[] buffer,int pos,int len)</td>
<td>写一个字节数组的一部分出去</td>
</tr>
<tr>
<td>flush()</td>
<td>刷新流，可以继续写</td>
</tr>
<tr>
<td>close()</td>
<td>关闭流，释放资源（关闭前刷新，一旦关闭，无法写数据）</td>
</tr>
</tbody></table>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    FileOutputStream</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">OutputStream</span> <span class="hljs-variable">os</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(”path/File“,<span class="hljs-literal">true</span>);<span class="hljs-comment">//true可以保证向文件追加数据而不是先清空再写</span><br><span class="hljs-type">byte</span>[] buffer = <span class="hljs-string">&quot;something&quot;</span>.getBytes();<br>os.write(<span class="hljs-string">&quot;/r/n&quot;</span>.getBytes());<span class="hljs-comment">//换行</span><br>os.write(buffer);<br>os.close(); <br></code></pre></td></tr></table></figure>

<blockquote>
<p><strong>文件拷贝</strong></p>
<p>Step1. 根据数据源创建字节输入流对象<br>Step2. 根据目的地创建字节输出流对象<br>Step3. 读写数据，复制视频<br>Step4. 释放资源</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(”path/File“);<br><span class="hljs-type">OutputStream</span> <span class="hljs-variable">os</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(”path/File“);<br><span class="hljs-type">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>]；<br><span class="hljs-type">int</span> len;<br><span class="hljs-keyword">while</span>(len=is.read(buffer)!=-<span class="hljs-number">1</span>)&#123;<br>	os.write(buffer,<span class="hljs-number">0</span>,len);<br>os.close();<br>is.close();<br></code></pre></td></tr></table></figure>

<p><img src="/assets/image-20220821224054-yqfu1t8.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
</blockquote>
<blockquote>
<p><strong>资源释放的方式</strong></p>
<p>try-catch-finally&#x2F;try-with-resource</p>
<p>因为finally语句一定会执行(除非JVM退出)，因此适合做资源释放的工作.close()<br>如果finally中有return的话，上面语句的return不会执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// JDK7更新的资源释放方式</span><br><span class="hljs-keyword">try</span>(<br>	<span class="hljs-comment">//定义流对象，只能放置资源对象（implements了Closeable/AutoCloseable接口的对象），用完自动关闭</span><br>	<span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(”path/File“);<br>	<span class="hljs-type">OutputStream</span> <span class="hljs-variable">os</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(”path/File“);<br>)&#123;...&#125;<br><span class="hljs-keyword">catch</span>&#123;...&#125;<br></code></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><strong>字符流</strong></p>
<p> 按单个字符读取，读取中文不会乱码(编码格式一致)，更合适</p>
<p> 构造器：<code>public FileReader(file/path)</code>​、<code>public FileWriter(file/path,true)</code>​</p>
<table>
<thead>
<tr>
<th>method</th>
<th>statement</th>
</tr>
</thead>
<tbody><tr>
<td>public int read()</td>
<td>每次读取一个字符，读完返回-1</td>
</tr>
<tr>
<td>public int read(char[] buffer)</td>
<td>读取字符数组，返回字符个数，读完返回-1</td>
</tr>
<tr>
<td>void write(…)</td>
<td>可以写字符，字符数组(一部分)，字符串(一部分)</td>
</tr>
<tr>
<td>flush()</td>
<td>刷新</td>
</tr>
<tr>
<td>close()</td>
<td>关闭流，释放</td>
</tr>
</tbody></table>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    一次读一个字节的FileReader(性能差)</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">Reader</span> <span class="hljs-variable">fr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(<span class="hljs-string">&quot;path/file&quot;</span>);<br><span class="hljs-keyword">while</span> ((code=fr.read())!=-<span class="hljs-number">1</span>)&#123;<br>    sout.(<span class="hljs-type">char</span>)code;<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">    一次读一个字节数组的FileReader</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">char</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[<span class="hljs-number">1024</span>];<br><span class="hljs-type">int</span> len;<br><span class="hljs-keyword">while</span>(len=fr.read(buffer)!=-<span class="hljs-number">1</span>)&#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(buffer,<span class="hljs-number">0</span>,len);<br>    sout.rs;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
</li>
<li><h3 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h3><p> &#x3D;&#x3D;自带缓冲区，提高原始流的性能&#x3D;&#x3D;</p>
<p> <img src="/assets/image-20220825150235-ts9sija.png" srcset="/img/loading.gif" lazyload alt="image.png">​</p>
<ul>
<li><p><strong>字节缓冲流</strong></p>
<p>​<code>BufferedInputStream</code>​、<code>BufferedOutputStream</code>​(自带了8kb的缓冲池)</p>
<p>​<code>InputStream bis = new BufferedInputStream(is)</code>​直接将FileInputStream包装成BufferedInputStream</p>
</li>
<li><p><strong>字符缓冲流</strong></p>
<p>​<code>BufferedReader</code>​ ，多了一个<code>readLine</code>​方法</p>
<p>​<code>BufferedWriter</code>​，多了一个<code>newLine</code>​方法</p>
</li>
</ul>
<blockquote>
<p><strong>代码与文件编码不一致的乱码问题</strong></p>
<ul>
<li><p>字符输入转换流（InputStreamReader）</p>
<p>InputStreamReader(InputStream in, String charsetName)</p>
</li>
<li><p>字符输出转换流（OutputStreamReader）&#x3D;“String”.getBytes()</p>
<p>控制写出的字符使用的编码</p>
<p>OutputStreamWriter(OutputStream out, Charset cs)</p>
</li>
</ul>
</blockquote>
</li>
<li><h3 id="序列化对象"><a href="#序列化对象" class="headerlink" title="序列化对象"></a>序列化对象</h3><ul>
<li><h5 id="对象序列化"><a href="#对象序列化" class="headerlink" title="对象序列化"></a>对象序列化</h5><p>定义：以内存为基准，将内存的对象存储到磁盘文件中</p>
<p>使用<strong>对象字节输出流ObjectOutputStream</strong></p>
<table>
<thead>
<tr>
<th>构造器</th>
<th>statement</th>
</tr>
</thead>
<tbody><tr>
<td>public ObjectOutputStream(OutputStream out)</td>
<td>低级字节输出流包装成高级的对象字节输出流</td>
</tr>
</tbody></table>
<p>对象class必须implements Serializable才能序列化</p>
</li>
<li><h5 id="对象反序列化"><a href="#对象反序列化" class="headerlink" title="对象反序列化"></a>对象反序列化</h5><p>定义：以内存为基准，将磁盘文件中的对象数据恢复成内存中的对象</p>
<p>使用<strong>对象字节输入流ObjectInputStream</strong></p>
<table>
<thead>
<tr>
<th>构造器</th>
<th>statement</th>
</tr>
</thead>
<tbody><tr>
<td>public ObjectInputStream(InputStream in)</td>
<td>低级字节输入流包装成高级的对象字节输入流<br /></td>
</tr>
</tbody></table>
<p>​<code>private transient password</code>​敏感信息可以用transient修饰，不参与序列化</p>
<p>可以定义final字段来规定序列化的版本号</p>
</li>
</ul>
</li>
<li><h3 id="打印流"><a href="#打印流" class="headerlink" title="打印流"></a>打印流</h3><p> 两种：FileOutputStream -&gt; PrintStream 或者 FileWriter -&gt; PrintWriter</p>
<p> 最强大的写数据到文件流，可以实现所见即所得</p>
<table>
<thead>
<tr>
<th>构造器</th>
<th>statement</th>
</tr>
</thead>
<tbody><tr>
<td>public PrintStream(OutputStream os)</td>
<td>直接通向字节输出流管道<br /></td>
</tr>
<tr>
<td>public PrintStream(File f)</td>
<td>直接通向文件对象</td>
</tr>
<tr>
<td>public PrintStream(String filepath)</td>
<td>直接通向文件路径</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>method</th>
<th>statement</th>
</tr>
</thead>
<tbody><tr>
<td>public print(xxx xx)</td>
<td>打印任意类型数据<br /></td>
</tr>
</tbody></table>
<p> 打印功能上PrintStream与PrintWriter无异（归属有异，写数据上PrintStream 只能写字节数据）</p>
</li>
<li><h3 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h3><p> Map -&gt; HashTable -&gt; Properties</p>
<p> 其实就是一个Map集合，但不当集合用（因为HashMap更好用）</p>
<p> 核心作用：<strong>Properties代表一个属性文件，可以把自己对象中的键值对信息存入一个属性文件中</strong></p>
<p> 属性文件：.properties结尾的文件，里面的内容都是key&#x3D;value，后续做系统配置信息</p>
<p> method：<code>properties.store()</code>​、<code>properties.getProperties()</code>​、<code>properties.setProperties()</code>​</p>
</li>
<li><h3 id="Commons-IO"><a href="#Commons-IO" class="headerlink" title="Commons-IO"></a>Commons-IO</h3><p> apache基金会提供的有关IO操作的类库，主要的类有FileUtils，IOUtils</p>
<p> 详细可见：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/johnnyzen/p/18291766">https://www.cnblogs.com/johnnyzen/p/18291766</a>，或<a target="_blank" rel="noopener" href="https://commons.apache.org/proper/commons-io/">官网</a></p>
</li>
</ol>
<p>‍</p>
<ul>
<li><h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a><strong>线程</strong></h1><p>多线程的创建、Thread类的常用方法、线程安全、线程同步、线程通信、线程池、定时器、线程状态…</p>
<ol>
<li><h3 id="创建Thread"><a href="#创建Thread" class="headerlink" title="创建Thread"></a>创建Thread</h3><ol>
<li><p>方案一（继承Thread类）</p>
<p> ① 定义一个myThread子类&#x3D;&#x3D;继承&#x3D;&#x3D;java.lang.Thread，重写run()</p>
<p> ② 创建myThread类的对象</p>
<p> ③ 调用线程对象的start()方法启动线程</p>
<p> <strong>缺点</strong>：继承Thread类，无法继承其他类，不利于扩展</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//多线程创建方式一:继承Thread类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">createThread</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">myThread</span>();<br>        thread.start();<br>        task;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">myThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br><span class="hljs-comment">//    重写run()</span><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        task;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>方案二（实现Runnable接口）</p>
<p> ① 定义一个线程任务类MyRunnable实现Runnable接口，重写run()</p>
<p> ② 创建MyRunnable任务对象</p>
<p> ③ 把MyRunnable的任务对象交给Thread处理</p>
<p> ④ 调用线程对象的start()方法启动线程</p>
<p> <strong>缺点</strong>：多了一层对象包装，线程的执行结果无法直接return（第一种也无法直接return）</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 实现Runnable接口，创建线程</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">createThread2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//创建任务对象</span><br>        <span class="hljs-type">Runnable</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyRunnable</span>();<br>        <span class="hljs-comment">//把任务对象交给Thread处理</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(target);<br>        <span class="hljs-comment">//启动线程</span><br>        t.start();<br>        task;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        task;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p> <strong>另一种写法（匿名内部类）</strong> </p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">createThreadOther</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Runnable</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>                    System.out.println(<span class="hljs-string">&quot;子线程执行输出：&quot;</span>+i);<br>                &#125;<br>            &#125;<br>        &#125;;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(target);<br>        t.start();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            System.out.println(<span class="hljs-string">&quot;主线程执行输出：&quot;</span>+i);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//lambda表达式简化</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">createThreadOther</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>          <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)&#123;<br>        System.out.println(<span class="hljs-string">&quot;子线程执行输出：&quot;</span>+i);<br>      &#125;<br>    &#125;).start();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            System.out.println(<span class="hljs-string">&quot;主线程执行输出：&quot;</span>+i);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>方案三（JDK5.0 Callable&amp;FutureTask，解决不能直接return线程执行结果的问题）</p>
<p> ① 得到任务对象</p>
<ul>
<li>定义类实现Callable接口，重写call()，封装要做的事</li>
<li>用FutureTask把Callable对象封装成线程任务对象</li>
</ul>
<p> ② 线程任务对象交给Thread处理</p>
<p> ③ 调用Thread的start()启动线程，执行任务</p>
<p> ④ 线程执行完毕后，用FutureTask的get()获取任务执行的结果</p>
<p> <strong>缺点</strong>：编码复杂</p>
<p> <strong>优点</strong>：扩展性强，实现接口的同时可继承其他类；可以得到线程执行的结果</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.Callable;<br><span class="hljs-keyword">import</span> java.util.concurrent.ExecutionException;<br><span class="hljs-keyword">import</span> java.util.concurrent.FutureTask;<br><span class="hljs-comment">// Callable+FutureTask</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">createThread3</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 3.创建Callable任务对象</span><br>        Callable&lt;String&gt; call = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyCallable</span>(<span class="hljs-number">100</span>);<br>        <span class="hljs-comment">// 4.把Callable对象封装成FutureTask对象（FutureTask是Runable的对象）</span><br>        FutureTask&lt;String&gt; f1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;&gt;(call);<br>        <span class="hljs-comment">// 5.交给线程</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(f1);<br>        t1.start();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">rs1</span> <span class="hljs-operator">=</span> f1.get();<br>            System.out.println(<span class="hljs-string">&quot;第一个结果是：&quot;</span>+rs1);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 1.定义任务类 实现Callable接口</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCallable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Callable</span>&lt;String&gt;&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> n;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyCallable</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-built_in">this</span>.n = n;<br>    &#125;<br>    <span class="hljs-comment">// 2.重写call(),线程的任务方法</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= n; i++) &#123;<br>            sum+=i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;子线程返回的结果是：&quot;</span>+sum;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
</li>
<li><h3 id="Thread的常用方法"><a href="#Thread的常用方法" class="headerlink" title="Thread的常用方法"></a>Thread的常用方法</h3><ul>
<li><p><strong>如何区分不同线程</strong></p>
<table>
<thead>
<tr>
<th>method</th>
<th>statement</th>
</tr>
</thead>
<tbody><tr>
<td>getName()</td>
<td>获取当前线程名</td>
</tr>
<tr>
<td>setName(String name)</td>
<td>修改线程名</td>
</tr>
<tr>
<td>currentThread()</td>
<td>获取当前线程对象</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xyf.thread.APIofThread;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">distinguishThread</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyTHread</span>();<br>        t1.setName(<span class="hljs-string">&quot;no1&quot;</span>);<br>        t1.start();<br>        System.out.println(t1.getName());<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyTHread</span>();<br>        t2.setName(<span class="hljs-string">&quot;no2&quot;</span>);<br>        t2.start();<br>        System.out.println(t2.getName());<br>        <span class="hljs-comment">//to get main thread</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>        System.out.println(m.getName());<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            System.out.println(<span class="hljs-string">&quot;main线程输出：&quot;</span>+i);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyTHread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;子线程输出：&quot;</span>+i);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>也可以在MyThread类中修改构造器</p>
<p>Thread的构造器</p>
<table>
<thead>
<tr>
<th>constructor</th>
<th>statement</th>
</tr>
</thead>
<tbody><tr>
<td>public Thread(Stirng name)</td>
<td>为当前线程指定名称</td>
</tr>
<tr>
<td>public Thread(Runable target)</td>
<td>封装Runnable对象成为线程对象</td>
</tr>
<tr>
<td>public Thread(Runable target,Stirng name)</td>
<td>封装Runnable对象成为，并指定名称</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">MyThread</span><span class="hljs-params">(String name)</span>&#123;<br>    <span class="hljs-comment">//调用父类Thread的构造器</span><br>    <span class="hljs-built_in">super</span>(name);<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p><strong>线程的休眠方法</strong></p>
<table>
<thead>
<tr>
<th>method</th>
<th>statement</th>
</tr>
</thead>
<tbody><tr>
<td>public static void sleep(long time)</td>
<td>线程休眠time时间再执行，单位ms</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><p> 多个Thread同时操作同一个共享资源时可能会出现的业务安全问题</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Account</span>&#123;<br>    <span class="hljs-keyword">private</span> String cardID;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> money;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Account</span><span class="hljs-params">(String cardID, <span class="hljs-type">double</span> money)</span> &#123;<br>        <span class="hljs-built_in">this</span>.cardID = cardID;<br>        <span class="hljs-built_in">this</span>.money = money;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Account</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getCardID</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> cardID;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setCardID</span><span class="hljs-params">(String cardID)</span> &#123;<br>        <span class="hljs-built_in">this</span>.cardID = cardID;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getMoney</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> money;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setMoney</span><span class="hljs-params">(<span class="hljs-type">double</span> money)</span> &#123;<br>        <span class="hljs-built_in">this</span>.money = money;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drawMoney</span><span class="hljs-params">(<span class="hljs-type">double</span> money)</span> &#123;<br>        <span class="hljs-comment">//1.判断谁来取钱</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> Thread.currentThread().getName();<br>        <span class="hljs-comment">//2.判断账户钱够不够</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.money&gt;=money)&#123;<br>            <span class="hljs-comment">//3.取钱，更新余额</span><br>            System.out.println(name+<span class="hljs-string">&quot;取钱成功，取出：&quot;</span>+money+<span class="hljs-string">&quot;元&quot;</span>);<br>            <span class="hljs-built_in">this</span>.money-=money;<br>            System.out.println(name+<span class="hljs-string">&quot;取钱后剩余：&quot;</span>+<span class="hljs-built_in">this</span>.money);<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            System.out.println(name+<span class="hljs-string">&quot;取钱失败，余额不足&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DrawThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br>    <span class="hljs-comment">//取钱线程类</span><br>    <span class="hljs-keyword">private</span> Account account;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DrawThread</span><span class="hljs-params">(Account account,String name)</span>&#123;<br>        <span class="hljs-built_in">super</span>(name);<br>        <span class="hljs-built_in">this</span>.account=account;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        account.drawMoney(<span class="hljs-number">100000</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">run</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//账户实例（用户共享账户）</span><br>        <span class="hljs-type">Account</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Account</span>(<span class="hljs-string">&quot;123456&quot;</span>,<span class="hljs-number">100000</span>);<br>        <span class="hljs-comment">//创建两个用户线程</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">DrawThread</span>(a,<span class="hljs-string">&quot;Tom&quot;</span>).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">DrawThread</span>(a,<span class="hljs-string">&quot;Ivan&quot;</span>).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3><p> <strong>核心思想</strong></p>
<ul>
<li><p><strong>锁</strong> <strong>lock</strong></p>
<p>将共享资源上锁，一次只能一个Thread进入，访问完毕后解锁，Other thread才能进</p>
</li>
</ul>
<ol>
<li><p>&#x3D;&#x3D;上锁方法一：同步代码块&#x3D;&#x3D;</p>
<p> <strong>Function</strong>：把出现线程安全的code上锁</p>
<p> <strong>Principal</strong>：每次只能一个Thread进入，执行完毕后自动解锁，其他Thread才能执行</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span>(同步锁对象)&#123;<br>  <span class="hljs-comment">//   ↑使用共享资源作为锁对象(实例方法用this，静态方法用类名.class)</span><br>  <span class="hljs-comment">//操作共享资源的代码</span><br>  ...<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>&#x3D;&#x3D;上锁方法二：同步方法&#x3D;&#x3D;</p>
<p> <strong>Function</strong>：把出现线程安全的function上锁</p>
<p> <strong>Principal</strong>：same</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">修饰符 <span class="hljs-keyword">synchronized</span> 返回值类型 方法名称(para1,para2,...)&#123;<br>  <span class="hljs-comment">//操作共享资源的代码</span><br>  ...<br>&#125;<br></code></pre></td></tr></table></figure>

<p> <strong>底层原理</strong>：其实方法前加<code>synchronized</code>​与同步代码块方法是一样的，底层有隐式锁对象锁住整个方法代码，实例-this，静态-类名.class</p>
</li>
<li><p>&#x3D;&#x3D;上锁方法三：Lock锁&#x3D;&#x3D;</p>
<p> JDK5后提供了Lock锁对象，Lock是接口不能实例化，用其实现类<code>public ReentrantLock()</code>​ 构建Lock锁对象</p>
<p> ​<code>lock()/unlock()</code>​方法上&#x2F;解锁，最好放在try-finally结构中保证始终解锁</p>
<p> ​<code>lock.tryLock(1, TimeUnit.SECONDS)</code>​，程序可以通过trylock的返回值做一些额外处理，而不是无限等待下去</p>
</li>
</ol>
</li>
<li><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p> 一个复用线程的技术，工作线程 + 任务队列</p>
<ol>
<li><h5 id="创建线程池"><a href="#创建线程池" class="headerlink" title="创建线程池"></a>创建线程池</h5><p> JDK5起提供了一个代表线程池的<u>接口</u>：<code>ExecutorService</code>​</p>
<ul>
<li><p><strong>方法一（推荐）</strong></p>
<p>使用<code>ExecutorService</code>​的实现类&#x3D;&#x3D;​<code>ThreadPoolExecutor</code>​&#x3D;&#x3D;​自创建一个线程池对象</p>
<p>ThreadPoolExecutor提供的有参构造器的参数含义</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>corePoolSize</td>
<td>指定线程池核心线程数量<br />“正式工”</td>
</tr>
<tr>
<td>maximumPoolSize</td>
<td>最大线程数<br />“正式工+临时工”</td>
</tr>
<tr>
<td>keepAliveTime</td>
<td>指定临时线程的存活时间</td>
</tr>
<tr>
<td>unit</td>
<td>临时线程存活的时间单位（秒，分，时，天）<br /><code>TimeUnit.SECONDS</code>​…</td>
</tr>
<tr>
<td>workQueue</td>
<td>指定线程池的任务队列<br /><code>new ArrayBlockingQueue&lt;&gt;(3)</code>​</td>
</tr>
<tr>
<td>threadFactory</td>
<td>指定线程池的线程工厂<br />“负责招聘的HR”<br /><code>Executors.defaultThreadFactory()</code>​</td>
</tr>
<tr>
<td>handler</td>
<td>任务拒绝策略<br /><code>new ThreadPoolExecutor.AbortPolicy()</code>​</td>
</tr>
</tbody></table>
</li>
<li><p><strong>方法二</strong></p>
<p>使用线程池的工具类<code>Executors</code>​，调用其方法返回不同的线程池对象</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>​<code>pulic static ExecutorService newFixedThreadPool(int nThreads)</code>​</td>
<td>创建固定线程数量的线程池，如果线程因异常结束，系统会创建新线程替代</td>
</tr>
<tr>
<td>​<code>pulic static ExecutorService newSingleThreadExecutor()</code>​</td>
<td>创建只有一个线程的线程池对象，如果线程因异常结束，系统会创建新线程替代</td>
</tr>
<tr>
<td>​<code>pulic static ExecutorService newcachedThreadPool()</code>​</td>
<td>线程数随任务数增加，执行完毕且空闲60s的线程会被回收</td>
</tr>
<tr>
<td>​<code>pulic static ScheduledExecutorService newScheduledThreadPool(int corePoolSize)</code>​</td>
<td>创建一个线程池，在给定延迟后执行任务，或是定期执行任务</td>
</tr>
</tbody></table>
<p><strong>Executors可能存在的问题</strong>（alibaba开发手册）<br>1）<code>FixedThreadPool</code>​和<code>SingleThreadPool</code>​：<br>允许的请求队列长度为Integer.MAX_VALUE，可能会导致堆积大量的请求，从而导致OOM<br>2）<code>cachedThreadPool</code>​和<code>ScheduledThreadPool</code>​：<br>允许的创建线程数量为Integer.MAX_VALUE，可能会创建大量的线程，从而导致OOM</p>
</li>
</ul>
</li>
<li><h5 id="Future类"><a href="#Future类" class="headerlink" title="Future类"></a>Future类</h5><p> Future是一个用于获取异步结果的接口、</p>
<p> 一般来说，当我们执行一个长时间运行的任务时，使用Future就可以让我们暂时去处理其他的任务，等长任务执行完毕再返回其结果。<br> 经常会使用到Future的场景有：1. 计算密集场景。2. 处理大数据量。3. 远程方法调用等。</p>
</li>
<li><h5 id="ExecutorService的常用方法"><a href="#ExecutorService的常用方法" class="headerlink" title="ExecutorService的常用方法"></a>ExecutorService的常用方法</h5><table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>​<code>void execute(Runable command)</code>​</td>
<td>执行Runable任务</td>
</tr>
<tr>
<td>​<code>Future&lt;T&gt; submit(Callable&lt;T&gt; task)</code>​</td>
<td>执行Callable任务，返回未来任务对象</td>
</tr>
<tr>
<td>​<code>void shutdown()</code>​</td>
<td>等全部任务执行完成后，关闭线程池</td>
</tr>
<tr>
<td>​<code>List&lt;Runable&gt; shutDownNow()</code>​</td>
<td>立刻关闭线程池，停止正在执行的任务，并返回队列中未执行的任务</td>
</tr>
</tbody></table>
</li>
<li><h5 id="临时线程"><a href="#临时线程" class="headerlink" title="临时线程"></a>临时线程</h5><p> 新的任务提交时，&#x3D;&#x3D;核心线程都在执行&#x3D;&#x3D;，&#x3D;&#x3D;任务队列也满了&#x3D;&#x3D;，且&#x3D;&#x3D;支持创建临时线程&#x3D;&#x3D;时，才会<u>创建临时线程</u></p>
</li>
<li><h5 id="任务拒绝策略"><a href="#任务拒绝策略" class="headerlink" title="任务拒绝策略"></a>任务拒绝策略</h5><table>
<thead>
<tr>
<th>策略</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>​<code>ThreadPoolExecutor.AbortPolicy()</code>​</td>
<td>丢弃任务 并抛出异常，为默认策略</td>
</tr>
<tr>
<td>​<code>ThreadPoolExecutor.DiscardPolicy()</code>​</td>
<td>丢弃任务 不抛出异常</td>
</tr>
<tr>
<td>​<code>ThreadPoolExecutor.DiscardOldestPolicy()</code>​</td>
<td>丢弃等待最久的任务，把当前任务加入队列中</td>
</tr>
<tr>
<td>​<code>ThreadPoolExecutor.CallerRunsPolicy()</code>​</td>
<td>由主线程负责调用任务的<code>run()</code>​方法，从而绕过线程池直接执行线程</td>
</tr>
</tbody></table>
</li>
<li><h5 id="并发-并行"><a href="#并发-并行" class="headerlink" title="并发 &amp; 并行"></a>并发 &amp; 并行</h5><ul>
<li><p>并发</p>
<p>process中的thread是由CPU调度的，但CPU核心数有限，为了保证所有线程执行，CPU会轮询<br>由于CPU切换速度很快，给人的感觉是线程同时执行。这就是并发</p>
</li>
<li><p>并行</p>
<p>同一时刻，多个线程被CPU执行</p>
</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
<li><h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h1><ol>
<li><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul>
<li><p><strong>IP</strong></p>
<p>Java中使用<code>InetAddress</code>​类实现IP地址</p>
<table>
<thead>
<tr>
<th><span data-type="text" style="background-color: var(--b3-font-background5);">常用方法</span></th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public static InetAddress getLocalHost() throws UnknownHostException</td>
<td>获取本机ip，返回InetAddress对象</td>
</tr>
<tr>
<td>public String getHostName()</td>
<td>获取主机名</td>
</tr>
<tr>
<td>public String getHostAddress()</td>
<td>获取ip</td>
</tr>
<tr>
<td>public static InetAddress getByName(String host) throws UnknownHostException</td>
<td>根据ip或域名，返回InetAddress对象</td>
</tr>
<tr>
<td>public boolean isReachable(int timeout) throws IOException</td>
<td>判断主机毫秒内与调用方法的ip是否能连通</td>
</tr>
</tbody></table>
</li>
<li><p><strong>端口</strong></p>
<p>周知端口：0 - 1023，被预先定义的应用占用<br>注册端口：1024 - 49151，分配给用户进程或某些应用程序<br>动态端口：49152 - 65535，动态分配</p>
</li>
<li><p><strong>协议</strong></p>
<p>UDP（User Datagram Protocol，用户数据报协议）：无连接，不可靠<br>TCP（Transmission Control Protocol，传输控制协议）：面向连接，可靠，三次握手四次挥手</p>
</li>
</ul>
</li>
<li><h3 id="UDP通信"><a href="#UDP通信" class="headerlink" title="UDP通信"></a>UDP通信</h3><p> 不事先建立连接，发送端将数据(&lt;&#x3D;64KB)、接收端IP等信息封装为一个数据包，发出去就不跟踪了</p>
<p> ​<code>java.net.DatagramSocket</code>​包用于实现UDP通信</p>
<table>
<thead>
<tr>
<th>构造器</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public DatagramSocket()</td>
<td>创建客户端socket对象，系统会随机分配一个端口号</td>
</tr>
<tr>
<td>public DatagramSocket(int port)</td>
<td>创建服务端的socket对象，并指定端口号</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public void send(DatagramPacket dp)</td>
<td>发送数据包</td>
</tr>
<tr>
<td>public void receive(DatagramPacket dp)</td>
<td>使用数据包接收数据</td>
</tr>
</tbody></table>
<p> <span data-type="text" style="color: var(--b3-font-color8);">其中，</span><u>DatagramPacket</u><span data-type="text" style="color: var(--b3-font-color8);">是一种数据包类</span></p>
<table>
<thead>
<tr>
<th>构造器</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public DatagramPacket(byte buf[], int length, InetAddress address, int port)</td>
<td>创建客户端socket对象，系统会随机分配一个端口号</td>
</tr>
<tr>
<td>public DatagramPacket(byte buf[], int length)</td>
<td>创建服务端的socket对象，并指定端口号</td>
</tr>
</tbody></table>
<ul>
<li><p><strong>一发一收</strong></p>
<p><strong>客户端（发送）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1. 创建发送端对象</span><br><span class="hljs-type">DatagramSocket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramSocket</span>();<br><span class="hljs-comment">// 2. 创建数据包</span><br><span class="hljs-type">byte</span>[] dataInBytes = <span class="hljs-string">&quot;我是要发送的数据&quot;</span>.getBytes();<br><span class="hljs-type">DatagramPacket</span> <span class="hljs-variable">packet</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramPacket</span>(dataInBytes, dataInBytes.length, InetAddress.getByName(<span class="hljs-string">&quot;ip地址&quot;</span>)， <span class="hljs-number">8080</span>);<br><span class="hljs-comment">// 3. 发送数据包</span><br>socket.send(packet);<br></code></pre></td></tr></table></figure>

<p><strong>服务端（接收）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1. 创建服务端对象</span><br><span class="hljs-type">DatagramSocket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramSocket</span>(<span class="hljs-number">8080</span>);<br><span class="hljs-comment">// 2. 创建一个用于接收的数据包</span><br><span class="hljs-type">byte</span>[] buf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>*<span class="hljs-number">64</span>];<br><span class="hljs-type">DatagramPacket</span> <span class="hljs-variable">packet</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramPacket</span>(buf, buf.length);<br><span class="hljs-comment">// 3. 接收数据，将数据封装到数据包对象</span><br>socket.receive();<br><span class="hljs-type">String</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(buf, <span class="hljs-number">0</span>, packet.getLength());<br></code></pre></td></tr></table></figure></li>
<li><p><strong>多发多收</strong></p>
<p><strong>客户端（发送）</strong><br>思路：使用<code>while(true)</code>​不断接收用户输入，直到用户输入exit</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1. 创建发送端对象</span><br><span class="hljs-type">DatagramSocket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramSocket</span>();<br><span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>    <span class="hljs-comment">// 2. 创建数据包</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> sc.nextLine();<br>    <span class="hljs-keyword">if</span>(<span class="hljs-string">&quot;msg&quot;</span>.equals(<span class="hljs-string">&quot;exit&quot;</span>))&#123;...;<span class="hljs-keyword">break</span>;&#125;<br>    <span class="hljs-type">byte</span>[] dataInBytes = msg.getBytes();<br>    <span class="hljs-type">DatagramPacket</span> <span class="hljs-variable">packet</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramPacket</span>(dataInBytes, dataInBytes.length, InetAddress.getByName(<span class="hljs-string">&quot;ip地址&quot;</span>)， <span class="hljs-number">8080</span>);<br>    <span class="hljs-comment">// 3. 发送数据包</span><br>    socket.send(packet);<br>    socket.close();<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>服务端（接收）</strong><br>思路：<code>while(true)</code>​不断执行<code>receive</code>​方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1. 创建服务端对象</span><br><span class="hljs-type">DatagramSocket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramSocket</span>(<span class="hljs-number">8080</span>);<br><span class="hljs-comment">// 2. 创建一个用于接收的数据包</span><br><span class="hljs-type">byte</span>[] buf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>*<span class="hljs-number">64</span>];<br><span class="hljs-type">DatagramPacket</span> <span class="hljs-variable">packet</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramPacket</span>(buf, buf.length);<br><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>    <span class="hljs-comment">// 3. 接收数据，将数据封装到数据包对象</span><br>    socket.receive();<br>    <span class="hljs-type">String</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(buf, <span class="hljs-number">0</span>, packet.getLength());<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><h3 id="TCP通信"><a href="#TCP通信" class="headerlink" title="TCP通信"></a>TCP通信</h3><p> 面向连接，可靠通信，三次握手，四次挥手</p>
<p> ​<code>java.net.Socket</code>​类实现TCP通信，基于IO流管道通信</p>
<table>
<thead>
<tr>
<th>构造器</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public Socket(String host, int port)</td>
<td>根据指定服务器ip、端口号请求与服务器建立连接，连接通过获得了客户端的socket</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public OutputStream getOutputStream()</td>
<td>获得字节输出流对象</td>
</tr>
<tr>
<td>public InputStream getInputStream()</td>
<td>获得字节输入流对象</td>
</tr>
</tbody></table>
<ul>
<li><p><strong>一发一收</strong></p>
<p><strong>客户端（发送）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1. 创建Socket管道对象，请求与服务端的Socket连接</span><br><span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Socket</span>(<span class="hljs-string">&quot;ip&quot;</span>, <span class="hljs-number">8080</span>);<br><span class="hljs-comment">// 2. 从socket管道中得到一个字节输出流</span><br><span class="hljs-type">OutputStream</span> <span class="hljs-variable">os</span> <span class="hljs-operator">=</span> socket.getOutputStream();<br><span class="hljs-comment">// 3. 特殊数据流</span><br><span class="hljs-type">DataOutputStream</span> <span class="hljs-variable">dos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataOutputStream</span>(os);<br>dos.writeInt(<span class="hljs-number">1</span>)；<br>dos.writeUTF(<span class="hljs-string">&quot;要发送的UTF编码字符&quot;</span>);<br><span class="hljs-comment">// 4. 释放资源</span><br>socket.close();<br></code></pre></td></tr></table></figure>

<p><strong>服务端（接收）</strong></p>
<p><span data-type="text" style="color: var(--b3-font-color1);">服务端是通过</span><code>java.net.ServerSocket</code>​​​​<span data-type="text" style="color: var(--b3-font-color1);">实现的</span></p>
<table>
<thead>
<tr>
<th>构造器</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public ServerSocket(int port)</td>
<td>为服务端程序注册端口</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public Socket accept()</td>
<td>阻塞等待客户端的连接请求，与客户端连接成功后，返回服务端侧的Socket对象</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1. 创建一个ServerSocket对象</span><br><span class="hljs-type">ServerSocket</span> <span class="hljs-variable">ss</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span>(<span class="hljs-number">8080</span>);<br><span class="hljs-comment">// 2. 等待客户端连接</span><br><span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> ss.accept();<br><span class="hljs-comment">// 3. 获取输入流，读取客户端发送的信息</span><br><span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> socket.getInputStream();<br><span class="hljs-comment">// 4. 将字节输入流包装为特殊数据输入流</span><br><span class="hljs-type">DataInputStream</span> <span class="hljs-variable">dis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataInputStream</span>(is);<br><span class="hljs-comment">// 5. 读取数据</span><br><span class="hljs-type">int</span> <span class="hljs-variable">data1</span> <span class="hljs-operator">=</span> dis.readInt();<br><span class="hljs-type">String</span> <span class="hljs-variable">data2</span> <span class="hljs-operator">=</span> dis.readUTF();<br></code></pre></td></tr></table></figure></li>
<li><p><strong>多发多收</strong></p>
<p><strong>客户端（发送）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1. 创建Socket管道对象，请求与服务端的Socket连接</span><br><span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Socket</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">8080</span>);<br><span class="hljs-comment">// 2. 从socket管道中得到一个字节输出流</span><br><span class="hljs-type">OutputStream</span> <span class="hljs-variable">os</span> <span class="hljs-operator">=</span> socket.getOutputStream();<br><span class="hljs-comment">// 3. 特殊数据流</span><br><span class="hljs-type">DataOutputStream</span> <span class="hljs-variable">dos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataOutputStream</span>(os);<br><span class="hljs-comment">// 4. while(True)接输入数据</span><br><span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br><span class="hljs-keyword">while</span>(True)&#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> sc.nextLine();<br>    <span class="hljs-keyword">if</span>(msg.equals(<span class="hljs-string">&quot;exit&quot;</span>))&#123;...&#125;<br>    dos.writeUTF();<br>    dos.flush();<br>&#125;<br><span class="hljs-comment">// 4. 释放资源</span><br>socket.close();<br></code></pre></td></tr></table></figure>

<p><strong>服务端（接收）</strong></p>
<p>只要在读数据时用死循环即可</p>
</li>
</ul>
</li>
<li><h3 id="TCP同时接收多客户端消息❗"><a href="#TCP同时接收多客户端消息❗" class="headerlink" title="TCP同时接收多客户端消息❗"></a>TCP同时接收多客户端消息❗</h3><p> <strong>问题</strong>：上述所有的通信方法，服务端不能支持接收多个客户端的消息</p>
<p> <strong>思路</strong>：主线程不断接收客户端管道，每接收一个管道，便交由一个独立的子线程专门处理该管道的消息</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java">main&#123;<br>  <span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> ss.accept();<br>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerReader</span>(socket).start();<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServerReader</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123; <span class="hljs-comment">// Thread实现了Runnable，继承Thread相等于实现了Runnable</span><br>  <span class="hljs-keyword">private</span> Socket socket;<br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">ServerReader</span><span class="hljs-params">(Socket socket)</span>&#123;<br>      <span class="hljs-built_in">this</span>.socket = socket;<br>  &#125;<br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>      <span class="hljs-comment">// 读取管道的消息</span><br>      <span class="hljs-keyword">try</span>&#123;<br>          <span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> socket.getInputStream();<br>          <span class="hljs-type">DataInputStream</span> <span class="hljs-variable">dis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataInputStream</span>(is);<br>          <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>              <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> dis.readUTF();<br>          &#125;<br>      &#125; <span class="hljs-keyword">catch</span> (Exception e)&#123;<br>          e.printStackTrace();<br>          sout(<span class="hljs-string">&quot;服务端下线了&quot;</span>);	<br>      &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><p><strong>每次请求都开一个新线程，资源浪费，如何解决？</strong></p>
<p>短连接的业务场景，如B&#x2F;S架构，可以考虑使用线程池进行优化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ServerSocket</span> <span class="hljs-variable">ss</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span>(<span class="hljs-number">8080</span>);<br><span class="hljs-comment">// 创建线程池</span><br><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(corePoolSize:<span class="hljs-number">3</span>, maximumPoolSize:<span class="hljs-number">10</span>, keepAliveTime:<span class="hljs-number">10</span>, TimeUnit.SECONDS, <br>                                                <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="hljs-number">100</span>), Executors.defaultThreadFactory(), <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>.AbortPolicy());<br><span class="hljs-keyword">while</span>(True)&#123;<br>    <span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> ss.accept();<br>    <span class="hljs-comment">// 把客户端管道包装成一个任务交给线程池处理</span><br>    pool.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerReader</span>(socket));<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
</li>
<li><h1 id="高级技术"><a href="#高级技术" class="headerlink" title="高级技术"></a>高级技术</h1><ul>
<li><h3 id="Junit单元测试"><a href="#Junit单元测试" class="headerlink" title="Junit单元测试"></a>Junit单元测试</h3><p>针对最小的功能单元：<strong>方法function</strong>，编写测试代码进行测试</p>
<p>为需要测试的业务类，定义对应的测试类，并为每个业务方法编写对应的<u>测试方法</u>（要求：public，无参，无返回值，@Test注解）<br>在测试方法中编写测试用例，要尽可能全面覆盖</p>
<p>做断言<code>Assert</code>​，对结果进行勘误</p>
</li>
<li><h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><ol>
<li><p><strong>定义</strong></p>
<p> <span data-type="text" style="color: var(--b3-font-color8);">加载类，并允许以编程的方式解剖类中的各种成分</span>（如成员变量&#x2F;方法&#x2F;构造器）</p>
</li>
<li><p><strong>步骤</strong></p>
<p> ① <strong>获取类对象</strong>​<strong>​<code>Class</code>​</strong>​<br>  <code>Class c1 = 类名.class</code>​<br>  调用Class提供的方法：<code>public static Class forName(String package)</code>​<br>  Object提供的方法：<code>public Class getClass(); Class c = 对象.getClass();</code>​<br> ② 获取类的<strong>构造器</strong>对象<code>Constructor</code>​<br>  <code>Constructor con = c1.</code>​<code>getDeclaredConstructor()</code>​​​​<br><br>   获取某类的构造器对象之后，可以拿构造器再创建对象，功能上等于Dog dog &#x3D; new Dog()，也就是<u>反射</u><br>  <code>Dog dog = (dog)con.newInstance()</code>​<br> ③ 获取类的<strong>成员变量</strong>对象<code>Field</code>​<br>  <code>Field[] fields = c1.</code>​<code>getDeclaredFields()</code>​​​​<br>   获取的成员变量对象可以为其设置值<code>，也可以获取值 field.set(dog, &quot;1&quot;)</code>​，<code>String hobby = (String)field.get(dog)</code>​<br> ④ 获取类的<strong>成员方法</strong>对象<code>Method</code>​<br> <code> Method[] methods = c1.</code>​<code>getDeclaredMethods()</code>​​​​<br>   <code>method.invoke(dog)</code>​</p>
</li>
<li><p><strong>如何应用</strong></p>
<p> 得到一个类的全部成分，并操作<br> 破坏封装性（暴力反射）<br> 绕过泛型的约束</p>
<p> <span data-type="text" style="color: var(--b3-font-color8);">适合做Java的框架，主流框架都会用反射设计功能</span></p>
</li>
</ol>
</li>
<li><h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><p>让调用程序根据注解信息来决定如何执行此程序</p>
<p>注解可以加在类、构造器、方法、成员变量、参数等上</p>
<ul>
<li><h5 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> 注解名 &#123;<br>  String <span class="hljs-title function_">str</span><span class="hljs-params">()</span>;<br>  <span class="hljs-type">int</span> <span class="hljs-title function_">age</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-number">10</span>;<br>  String[] address();<br>&#125;<br>@注解名<span class="hljs-number">1</span>(str=<span class="hljs-string">&quot;str&quot;</span>, age=<span class="hljs-number">1</span>, address=&#123;<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;&quot;</span>&#125;)<br><span class="hljs-comment">// value是一个特殊属性，使用时若只有一个value属性，则写注解时可以不写属性名</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> 注解名<span class="hljs-number">1</span> &#123;<br>  String <span class="hljs-title function_">value</span><span class="hljs-params">()</span>;<br>&#125;<br>@注解名<span class="hljs-number">1</span>(<span class="hljs-string">&quot;str&quot;</span>)<br></code></pre></td></tr></table></figure></li>
<li><h5 id="注解原理"><a href="#注解原理" class="headerlink" title="注解原理"></a>注解原理</h5><p>注解本身是一个接口，继承自<code>Annotation</code>​类，我们定义的注解成员，实际上是抽象方法</p>
</li>
<li><h5 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">@元注解<br>@元注解<br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> 注解()&#123;&#125;<br></code></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>常见的元注解</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@Target(ElementType.xx)</td>
<td>声明被修饰的注解能在哪些位置生效<br />1. TYPE ，类 &#x2F; 接口<br />2. FIELD ，成员变量<br />3. METHOD ，成员方法<br />4. PARAMETER，方法参数<br />5. CONSTRUCTOR，构造器<br />6. LOCAL_VARIABLE，局部变量</td>
</tr>
<tr>
<td>@Retention(RetentionPolicy.xx)</td>
<td>声明注解的保留周期<br />1. SOURCE ，作用在源码阶段，字节码中不存在<br />2. CLASS，默认值，作用在字节码中，run时不存在<br />3. RUNTIME，一直保留到运行阶段（常用）</td>
</tr>
</tbody></table>
</li>
<li><h5 id="注解解析"><a href="#注解解析" class="headerlink" title="注解解析"></a>注解解析</h5><p>判断类、方法、成员变量上是否有注解，并把注解内容解析</p>
<p>先用反射获得Class对象，，因为反射对象都实现了<code>AnnotationElement</code>​接口，所以他们都有解析注解的能力</p>
<table>
<thead>
<tr>
<th>​<code>AnnotationElement</code>​接口</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public Annotation[] getDeclaredAnnotations()</td>
<td>获取当前对象上的注解</td>
</tr>
<tr>
<td>public T getDeclaredAnnotation(Class<T> annotationClass)</td>
<td>获取指定的注解对象</td>
</tr>
<tr>
<td>public boolean isAnnotationPresent(Class<Annotatio> annotationClass)</td>
<td>判断当前对象上是否存在某个注解</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><p>动态代理是一种设计模式</p>
<p><strong>代理</strong><br>对象实现的任务太多，可以通过代理转移部分功能<br>代理通过实现接口来获得被代理对象的功能<br>​<code>java.lang.reflect.proxy</code>​类提供了为对象生成代理的方法 ↓<br><span data-type="text" style="color: var(--b3-font-color8);">public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)</span><br><span data-type="text" style="color: var(--b3-font-color8);">参数一：指定类加载器，加载生成的代理类<br>参数二：指定接口，用于指定生成的代理有哪些方法<br>参数三：指定生成对象的功能</span></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">starservice</span>()&#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">sing</span><span class="hljs-params">(String name)</span>;<br>    String <span class="hljs-title function_">dance</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">star</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">starservice</span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sing</span><span class="hljs-params">(String name)</span>&#123;<br>        <span class="hljs-string">&quot;啦啦啦～&quot;</span>.sout;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dance</span><span class="hljs-params">(String name)</span>&#123;<br>        <span class="hljs-string">&quot;跳～&quot;</span>.sout;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProxyUtil</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> starservice <span class="hljs-title function_">createProxy</span><span class="hljs-params">(star s)</span>&#123;<br>        <span class="hljs-type">starservice</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> (starservice)Proxy.newProxyInstance(<br>                                            ProxyUtil.class.getClassLoader(),<br>                                            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;starservice.class&#125;或者s.getClass().getInterfaces(),<br>                                            <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvocationHandler</span>()&#123;<br>                                            <span class="hljs-meta">@Override</span> <br>                                            <span class="hljs-keyword">public</span> Obejcet <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable&#123;<br>                                                <span class="hljs-comment">// 参数1：proxy接收到的对象本身</span><br>                                                <span class="hljs-comment">// 参数2：method代表正在被代理的方法 sing/dance</span><br>                                                <span class="hljs-comment">// 参数3：args代表正在被代理方法的参数</span><br>                                                <span class="hljs-type">String</span> <span class="hljs-variable">methodName</span> <span class="hljs-operator">=</span> method.getName();<br>                                                <span class="hljs-comment">// 代理功能</span><br>                                                <span class="hljs-keyword">if</span>(<span class="hljs-string">&quot;sing&quot;</span>.equals(methodName))&#123;...&#125;<br>                                                <span class="hljs-comment">// 原对象功能</span><br>                                                <span class="hljs-type">Object</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> method.invoke(s, args);<br>                                                <span class="hljs-keyword">return</span> res;<br>                                            &#125;							<br>                            &#125;);<br>        <span class="hljs-keyword">return</span> proxy;<br>    &#125;<br>&#125;<br><br>main&#123;<br>    <span class="hljs-type">Star</span> <span class="hljs-variable">star</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Star</span>(<span class="hljs-string">&quot;刘德华&quot;</span>);<br>    <span class="hljs-comment">// 创建代理对象</span><br>    <span class="hljs-type">starservice</span> <span class="hljs-variable">star</span> <span class="hljs-operator">=</span> ProxyUtil.createProxy(star);<br>    <span class="hljs-comment">// 代理对象proxy底层会调用重写的invoke方法</span><br>    proxy.sing(<span class="hljs-string">&quot;歌名&quot;</span>);<br>    proxy.dance();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>‍</p>
</li>
</ul>
</li>
</ul>
<p>‍</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/" class="category-chain-item">开发技术</a>
  
  
    <span>></span>
    
  <a href="/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/" class="category-chain-item">后端开发</a>
  
  

  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/" class="print-no-link">#开发技术</a>
      
        <a href="/tags/%E7%AC%94%E8%AE%B0/" class="print-no-link">#笔记</a>
      
        <a href="/tags/%E5%90%8E%E7%AB%AF/" class="print-no-link">#后端</a>
      
        <a href="/tags/%E6%9B%B4%E6%96%B0%E4%B8%AD/" class="print-no-link">#更新中</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>JAVA基础</div>
      <div>http://example.com/2025/06/02/JAVA基础/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Yifan Xie</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年6月2日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/05/24/%E8%B0%83%E5%88%B6%E8%AF%86%E5%88%ABHOM%E5%8E%BB%E5%99%AA%E6%96%B9%E6%B3%95/" title="调制识别HOM去噪方法">
                        <span class="hidden-mobile">调制识别HOM去噪方法</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    

  

</div>

  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  var relativeDate = function() {
    var updatedTime = document.getElementById('updated-time');
    if (updatedTime) {
      var text = updatedTime.textContent;
      var reg = /\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(?:Z|[+-]\d{2}:\d{2})/;
      var matchs = text.match(reg);
      if (matchs) {
        var relativeTime = moment(matchs[0]).fromNow();
        updatedTime.textContent = text.replace(reg, relativeTime);
      }
      updatedTime.style.display = '';
    }
  };
  Fluid.utils.createScript('https://lib.baomitu.com/moment.js/2.29.4/moment.min.js', function() {
    if (!'zh-cn'.startsWith('en')) {
      Fluid.utils.createScript('https://lib.baomitu.com/moment.js/2.29.4/locale/zh-cn.min.js', function() {
        relativeDate();
      });
    } else {
      relativeDate();
    }
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
