<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>VUE</title>
    <link href="/2025/08/24/VUE/"/>
    <url>/2025/08/24/VUE/</url>
    
    <content type="html"><![CDATA[<p>根据各类网络教程总结的VUE前端基础知识点</p><span id="more"></span><h1 id="VUE"><a href="#VUE" class="headerlink" title="VUE"></a>VUE</h1><p>Vue是一款用于<span data-type="text" style="color: var(--b3-font-color8);">构建用户界面</span>的<strong>渐进式</strong>JS框架</p><p><img src="/2025/08/24/VUE/image-20250716215927-9xnvqgv.png" alt="image">​</p><p><strong>模块化</strong>：项目划分模块，单独开发、维护，提高效率<br><strong>组件化</strong>：将页面的各个组成部分封装为组件，提高复用性<br><strong>规范化</strong>：提供标准的目录结构，编码规范，开发流程<br><strong>自动化</strong>：项目构建、开发、测试、打包、部署</p><h3 id="1-1-VUE工程化"><a href="#1-1-VUE工程化" class="headerlink" title="1.1 VUE工程化"></a>1.1 VUE工程化</h3><p>创建一个工程化的VUE项目，执行命令<code>npm create vue@&#123;version&#125;</code>，将会安装并执行create-vue脚手架工具</p><p><img src="/2025/08/24/VUE/image-20250716223350-mb2dbac.png" alt="image"></p><p>执行<code>npm install</code>下载包</p><p><strong>项目结构介绍</strong></p><p><img src="/2025/08/24/VUE/image-20250716223848-l6072gb.png" alt="image">​</p><p>​<code>npm run dev</code>命令启动Vue项目</p><p>Vue实例与容器只能1-1对应</p><p>花括号中只能写JS表达式</p><p>Vue控制台 选项卡1-观察组件结构</p><h3 id="1-3-模板语法"><a href="#1-3-模板语法" class="headerlink" title="1.3 模板语法"></a><strong>1.3 模板语法</strong></h3><p>插值&#x2F;指令 语法</p><p>在属性内插值被移除，只能用v-bind:xxx&#x3D;“”，VUE会将双引号中的字符当作JS表达式执行</p><p>标签体中用插值语法，标签属性(解析标签)用指令语法</p><h3 id="1-4-数据绑定"><a href="#1-4-数据绑定" class="headerlink" title="1.4 数据绑定"></a><strong>1.4 数据绑定</strong></h3><p>v-bind单向绑定，数据从data流向页面</p><p>v-model双向绑定，页面与data同时更新</p><p>v-model只能运用在表单类&#x2F;输入类(有value值的)标签中</p><ul><li><strong>el与data</strong></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br><span class="hljs-attr">el</span>:<span class="hljs-string">&#x27;#root&#x27;</span><br><span class="hljs-attr">data</span>:&#123;<br><span class="hljs-attr">name</span>:<span class="hljs-string">&quot;123&quot;</span><br>&#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>el绑定也可以写成：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> v = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br><span class="hljs-attr">el</span>:<span class="hljs-string">&#x27;#root&#x27;</span><br><span class="hljs-attr">data</span>:&#123;<br><span class="hljs-attr">name</span>:<span class="hljs-string">&quot;123&quot;</span><br>&#125;<br>&#125;)<br>v.$mount(<span class="hljs-string">&#x27;#root&#x27;</span>) <span class="hljs-comment">//挂载</span><br></code></pre></td></tr></table></figure><p>好处是可以在绑定时做别的逻辑操作</p><p>&#x3D;&#x3D;data的函数式写法：&#x3D;&#x3D;</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">data</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-keyword">return</span>&#123;<br><span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;123&#x27;</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>组件中必须使用此类写法，不要写箭头函数(保持this为vue实例)</p><p><strong>1.5 MVVM模型 model-view-viewmodel</strong></p><p><img src="/2025/08/24/VUE/image-20240115103655-ytlgk8b.png" alt="image.png"></p><p><img src="/2025/08/24/VUE/image-20240115103645-2jmljpg.png" alt="image.png"></p><p>花括号中 vm中有的属性全都能用</p><h3 id="1-6-数据代理"><a href="#1-6-数据代理" class="headerlink" title="1.6 数据代理"></a><strong>1.6 数据代理</strong></h3><ul><li><strong>Object.defineProperty()方法</strong> (ES6)</li></ul><p><img src="/2025/08/24/VUE/image-20240115103730-92gvcv2.png" alt="image.png"></p><p>用此方法加入的参数</p><p>默认不参与遍历 <code>enumerable:true</code></p><p><img src="/2025/08/24/VUE/image-20240115103753-oxzylt0.png" alt="image.png"></p><p>默认不可修改 <code>writable:true</code></p><p>默认不可删除 <code>configurable:true</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">get</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;sth&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2025/08/24/VUE/image-20240115103852-vqyae5s.png" alt="image.png"></p><ul><li><strong>数据代理的定义</strong></li></ul><p><img src="/2025/08/24/VUE/image-20240115103911-2h9v76c.png" alt="image.png"></p><p>通过defineProperty()实现数据代理</p><ul><li><strong>Vue中的数据代理</strong></li></ul><p><img src="/2025/08/24/VUE/image-20240115103929-y8u2v9y.png" alt="image.png"></p><p><img src="/2025/08/24/VUE/image-20240115103938-l3meydk.png" alt="image.png"></p><p>把vm中的数据用defineproperty()放在data中</p><p>使数据操作更方便</p><h3 id="1-7-事件处理"><a href="#1-7-事件处理" class="headerlink" title="1.7 事件处理"></a><strong>1.7 事件处理</strong></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">methods</span>:&#123;<br>v-<span class="hljs-attr">on</span>:click=“func” 或者 @click=“<span class="hljs-title function_">func</span>($event, para, ...)”<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>事件修饰符</strong></li></ul><p> <strong>@click.stop 阻止事件冒泡</strong></p><p> <strong>@click.prevent 阻止默认事件</strong></p><p> <strong>@click.once 事件只触发一次</strong></p><p>@click.capture 使用事件的捕获模式（div外到内）</p><p>@click.self 仅当e.target是当前操作元素才触发</p><p>@click.passive 事件的默认行为立即执行，无需等待回调</p><ul><li><strong>键盘事件</strong></li></ul><p><img src="/2025/08/24/VUE/image-20240115104038-a5fnvht.png" alt="image.png"></p><p><img src="/2025/08/24/VUE/image-20240115104046-8yltsh0.png" alt="image.png"></p><h3 id="1-8-计算属性"><a href="#1-8-计算属性" class="headerlink" title="1.8 计算属性"></a><strong>1.8 计算属性</strong></h3><p>1.插值语法<code>&#123;&#123;str.slice(0,3)&#125;&#125;</code> &#x3D;&#x3D;&#x3D;</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//2.methods实现</span><br>&#123;&#123;<span class="hljs-title function_">func</span>()&#125;&#125;<br><span class="hljs-attr">methods</span>:&#123;<br><span class="hljs-title function_">func</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">b</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>&#x3D;&#x3D;&#x3D;</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//3.计算属性实现（相比methods有缓存）</span><br><span class="hljs-attr">computed</span>:&#123;<br><span class="hljs-attr">func</span>:&#123;<br><span class="hljs-comment">//自动调用</span><br><span class="hljs-title function_">get</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>+<span class="hljs-variable language_">this</span>.<span class="hljs-property">b</span><br>&#125;<br><span class="hljs-comment">//当func被修改时调用</span><br><span class="hljs-title function_">set</span>(<span class="hljs-params">value</span>)&#123;<br><span class="hljs-comment">//要书写具体代码才能修改data中的内容，计算属性会自动根据data发生变化</span><br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>监视属性 – watch</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 监视属性变化时，handler自动调用</span><br><span class="hljs-comment">// 监视多层级属性改变时，需给watch配置deep:true</span><br><span class="hljs-attr">watch</span>:&#123;<br>    <span class="hljs-attr">func</span>:&#123;<br>        <span class="hljs-comment">//还有很多配置</span><br>        <span class="hljs-attr">immediate</span>:<span class="hljs-literal">true</span><br>        <span class="hljs-title function_">handler</span>(<span class="hljs-params">newvalue,oldvalue</span>)&#123;<br>            pass<br>        &#125;<br><br>    &#125;<br>&#125;<br><br>vm.$watch(<span class="hljs-string">&#x27;属性&#x27;</span>, &#123;<br>    <span class="hljs-attr">immediate</span>:<span class="hljs-literal">true</span><br>    <span class="hljs-title function_">handler</span>(<span class="hljs-params">newvalue,oldvalue</span>)&#123;<br>        pass<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure></li><li><p><strong>计算属性和监视属性的区别</strong><br>watch不靠返回值，可以实现异步任务</p><p>不被Vue管理的函数（如定时器setTimeout，Ajax的回调函数，Promise的回调函数）要写成箭头函数</p></li></ul><h3 id="1-9-绑定样式"><a href="#1-9-绑定样式" class="headerlink" title="1.9 绑定样式"></a><strong>1.9 绑定样式</strong></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;root&quot;</span>&gt;</span><br>    // 绑定class样式，字符串写法<br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&#x27;stable_style&#x27;</span> <span class="hljs-attr">v-bind:class</span>=<span class="hljs-string">&quot;varible_style&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;change&quot;</span>&gt;</span>&#123;&#123;name&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>    //绑定style样式<br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&#x27;stable_style&#x27;</span> <span class="hljs-attr">:style</span>=<span class="hljs-string">&quot;styleObj&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;change&quot;</span>&gt;</span>&#123;&#123;name&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-title class_">Vue</span>.<span class="hljs-property">config</span>.<span class="hljs-property">productionTip</span> = <span class="hljs-literal">false</span></span><br><span class="language-javascript">    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><br><span class="language-javascript">        <span class="hljs-attr">el</span>:<span class="hljs-string">&#x27;#root&#x27;</span>,</span><br><span class="language-javascript"><span class="hljs-attr">data</span>:&#123;</span><br><span class="language-javascript">    <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;123&#x27;</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">varible_style</span>:<span class="hljs-string">&quot;style1&quot;</span></span><br><span class="language-javascript">  </span><br><span class="language-javascript">    <span class="hljs-comment">// 字符串，对象，数组 both ok</span></span><br><span class="language-javascript">    <span class="hljs-attr">styleObj</span>:&#123;</span><br><span class="language-javascript"><span class="hljs-attr">fontSize</span>:<span class="hljs-string">&#x27;40px&#x27;</span></span><br><span class="language-javascript">   &#125;</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-attr">methods</span>:&#123;</span><br><span class="language-javascript">    <span class="hljs-title function_">change</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript"><span class="hljs-variable language_">this</span>.<span class="hljs-property">varible_style</span>=<span class="hljs-string">&#x27;style2&#x27;</span></span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript">    &#125;)</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="1-10-条件渲染"><a href="#1-10-条件渲染" class="headerlink" title="1.10 条件渲染"></a><strong>1.10 条件渲染</strong></h3><p>v-show &#x2F; v-if </p><p>可以用<template>写条件，template不影响结构，页面渲染时不存在。但只能配合v-if。</p><h3 id="1-11-列表渲染-v-for"><a href="#1-11-列表渲染-v-for" class="headerlink" title="1.11 列表渲染 v-for"></a><strong>1.11 列表渲染 v-for</strong></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;root&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;p in persons&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;p.id&quot;</span>&gt;</span><br>                &#123;&#123;p&#125;&#125;<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">        <span class="hljs-title class_">Vue</span>.<span class="hljs-property">config</span>.<span class="hljs-property">productionTip</span> = <span class="hljs-literal">false</span></span><br><span class="language-javascript">        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><br><span class="language-javascript">            <span class="hljs-attr">el</span>:<span class="hljs-string">&#x27;#root&#x27;</span>,</span><br><span class="language-javascript">            <span class="hljs-attr">data</span>:&#123;</span><br><span class="language-javascript">                <span class="hljs-attr">persons</span>:[</span><br><span class="language-javascript">                    &#123;<span class="hljs-attr">id</span>:<span class="hljs-string">&#x27;001&#x27;</span>,<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;张三&#x27;</span>,<span class="hljs-attr">age</span>:<span class="hljs-number">18</span>&#125;,</span><br><span class="language-javascript">                    &#123;<span class="hljs-attr">id</span>:<span class="hljs-string">&#x27;002&#x27;</span>,<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;张4&#x27;</span>,<span class="hljs-attr">age</span>:<span class="hljs-number">19</span>&#125;,</span><br><span class="language-javascript">                    &#123;<span class="hljs-attr">id</span>:<span class="hljs-string">&#x27;003&#x27;</span>,<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;张5&#x27;</span>,<span class="hljs-attr">age</span>:<span class="hljs-number">20</span>&#125;</span><br><span class="language-javascript">                ]</span><br><span class="language-javascript">            &#125;</span><br><span class="language-javascript">        &#125;)</span><br><span class="language-javascript"> </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li><p><strong>key的原理</strong></p><p>虚拟DOM对比算法 – 不一致的节点：更新 + 一致的节点：不变<br>如果用index作为key，且对数据破坏了顺序，会导致对应节点信息错位</p></li><li><p><strong>列表过滤</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// watch实现</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>    <span class="hljs-attr">el</span>:<span class="hljs-string">&quot;#root&quot;</span>,<br>    <span class="hljs-attr">data</span>:&#123;<br><span class="hljs-attr">keyword</span>:<span class="hljs-string">&quot;&quot;</span>,<br><span class="hljs-attr">persons</span>:[<br>    &#123;<span class="hljs-attr">id</span>:<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-attr">name</span>:<span class="hljs-string">&quot;马冬梅&quot;</span>，<span class="hljs-attr">age</span>:<span class="hljs-number">19</span>&#125;,<br>    &#123;<span class="hljs-attr">id</span>:<span class="hljs-string">&#x27;2&#x27;</span>,<span class="hljs-attr">name</span>:<span class="hljs-string">&quot;周冬雨&quot;</span>，<span class="hljs-attr">age</span>:<span class="hljs-number">20</span>&#125;,<br>    &#123;<span class="hljs-attr">id</span>:<span class="hljs-string">&#x27;3&#x27;</span>,<span class="hljs-attr">name</span>:<span class="hljs-string">&quot;周杰伦&quot;</span>，<span class="hljs-attr">age</span>:<span class="hljs-number">21</span>&#125;,<br>    &#123;<span class="hljs-attr">id</span>:<span class="hljs-string">&#x27;4&#x27;</span>,<span class="hljs-attr">name</span>:<span class="hljs-string">&quot;温兆伦&quot;</span>，<span class="hljs-attr">age</span>:<span class="hljs-number">22</span>&#125;,<br>],<br><span class="hljs-attr">filterPersons</span>:[]<br>    &#125;,<br>    <span class="hljs-attr">watch</span>:&#123;<br><span class="hljs-attr">keywrod</span>:&#123;<br>    <span class="hljs-attr">immediate</span>:<span class="hljs-literal">true</span>,<br>    <span class="hljs-title function_">handler</span>(<span class="hljs-params">val</span>)&#123;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">filterPerson</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">persons</span>.<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">p</span>)=&gt;</span>&#123;<br>    <span class="hljs-keyword">return</span> p.<span class="hljs-property">name</span>.<span class="hljs-title function_">indexOf</span>(val) !== -<span class="hljs-number">1</span><br>&#125;)<br>    &#125;<br>&#125;<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 计算属性实现</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>    <span class="hljs-attr">el</span>:<span class="hljs-string">&quot;#root&quot;</span>,<br>    <span class="hljs-attr">data</span>:&#123;<br><span class="hljs-attr">keyword</span>:<span class="hljs-string">&quot;&quot;</span>,<br><span class="hljs-attr">persons</span>:[<br>    &#123;<span class="hljs-attr">id</span>:<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-attr">name</span>:<span class="hljs-string">&quot;马冬梅&quot;</span>，<span class="hljs-attr">age</span>:<span class="hljs-number">19</span>&#125;,<br>    &#123;<span class="hljs-attr">id</span>:<span class="hljs-string">&#x27;2&#x27;</span>,<span class="hljs-attr">name</span>:<span class="hljs-string">&quot;周冬雨&quot;</span>，<span class="hljs-attr">age</span>:<span class="hljs-number">20</span>&#125;,<br>    &#123;<span class="hljs-attr">id</span>:<span class="hljs-string">&#x27;3&#x27;</span>,<span class="hljs-attr">name</span>:<span class="hljs-string">&quot;周杰伦&quot;</span>，<span class="hljs-attr">age</span>:<span class="hljs-number">21</span>&#125;,<br>    &#123;<span class="hljs-attr">id</span>:<span class="hljs-string">&#x27;4&#x27;</span>,<span class="hljs-attr">name</span>:<span class="hljs-string">&quot;温兆伦&quot;</span>，<span class="hljs-attr">age</span>:<span class="hljs-number">22</span>&#125;,<br>],<br><span class="hljs-attr">filterPersons</span>:[]<br>    &#125;,<br>    <span class="hljs-attr">computed</span>:&#123;<br><span class="hljs-title function_">filterPersons</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">filterPersons</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">persons</span>.<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">p</span>)=&gt;</span>&#123;<br><span class="hljs-keyword">return</span> p.<span class="hljs-property">name</span>.<span class="hljs-title function_">indexOf</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">keyword</span>) !== -<span class="hljs-number">1</span><br>    &#125;)<br>&#125;<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure></li><li><p><strong>列表排序</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;div id=<span class="hljs-string">&quot;root&quot;</span>&gt;<br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>列表过滤<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;请输入名字&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;keyword&quot;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;sortType = 2&quot;</span>&gt;</span>年龄升序<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;sortType = 1&quot;</span>&gt;</span>年龄降序<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;sortType = 0&quot;</span>&gt;</span>原顺序<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><br><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(index,p) in filterPersons&quot;</span> <span class="hljs-attr">::key</span>=<span class="hljs-string">&quot;p.id&quot;</span>&gt;</span></span><br><span class="language-xml">             &#123;&#123;p.name&#125;&#125;--&#123;&#123;p.age&#125;&#125;</span><br><span class="language-xml">          <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>    <span class="hljs-attr">el</span>:<span class="hljs-string">&quot;#root&quot;</span>,<br>    <span class="hljs-attr">data</span>:&#123;<br>    <span class="hljs-attr">keyword</span>:<span class="hljs-string">&quot;&quot;</span>,<br>          <span class="hljs-attr">sortType</span>:<span class="hljs-number">0</span>,  <span class="hljs-comment">//0-原顺序 1-降序 2-升序</span><br>    <span class="hljs-attr">persons</span>:[<br>      &#123;<span class="hljs-attr">id</span>:<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-attr">name</span>:<span class="hljs-string">&quot;马冬梅&quot;</span>,<span class="hljs-attr">age</span>:<span class="hljs-number">19</span>&#125;,<br>      &#123;<span class="hljs-attr">id</span>:<span class="hljs-string">&#x27;2&#x27;</span>,<span class="hljs-attr">name</span>:<span class="hljs-string">&quot;周冬雨&quot;</span>,<span class="hljs-attr">age</span>:<span class="hljs-number">20</span>&#125;,<br>      &#123;<span class="hljs-attr">id</span>:<span class="hljs-string">&#x27;3&#x27;</span>,<span class="hljs-attr">name</span>:<span class="hljs-string">&quot;周杰伦&quot;</span>,<span class="hljs-attr">age</span>:<span class="hljs-number">21</span>&#125;,<br>      &#123;<span class="hljs-attr">id</span>:<span class="hljs-string">&#x27;4&#x27;</span>,<span class="hljs-attr">name</span>:<span class="hljs-string">&quot;温兆伦&quot;</span>,<span class="hljs-attr">age</span>:<span class="hljs-number">22</span>&#125;,<br>    ],<br>    <span class="hljs-attr">filterPersons</span>:[]<br>    &#125;,<br>    <span class="hljs-attr">computed</span>:&#123;<br>    <span class="hljs-title function_">filterPersons</span>(<span class="hljs-params"></span>)&#123;<br>      <span class="hljs-keyword">const</span> arr = <span class="hljs-variable language_">this</span>.<span class="hljs-property">filterPersons</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">persons</span>.<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">p</span>)=&gt;</span>&#123;<br>      <span class="hljs-keyword">return</span> p.<span class="hljs-property">name</span>.<span class="hljs-title function_">indexOf</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">keyword</span>) !== -<span class="hljs-number">1</span><br>      &#125;)<br>        <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">sortType</span>)&#123;<br>          arr.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a,b</span>)=&gt;</span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">sortType</span> === <span class="hljs-number">1</span> ? b.<span class="hljs-property">age</span>-a.<span class="hljs-property">age</span> : a.<span class="hljs-property">age</span>-b.<span class="hljs-property">age</span><br>          &#125;)<br>        &#125;<br>        <span class="hljs-keyword">return</span> arr<br>    &#125;<br>    &#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>Vue监测数据的原理</strong></p><p>Vue检测data中的所有数据</p><p>&#x3D;&#x3D;对象&#x3D;&#x3D;：<code>Vue.set(target, propertyName/index, value)</code> &#x2F;<code>vm.$set(target, propertyName/index, value)</code>后添加的数据属性也可以保证响应式get set，但只能给vm的对象添加属性，而不能直接给vm本身和vm根数据对象添加</p><p>&#x3D;&#x3D;数组&#x3D;&#x3D;：不会为数组元素匹配get&#x2F;set，Vue中的数组方法被重新包装过，<code>push/pop/shift/unshift/splice/sort/reverse</code>，都会引起模板的渲染。数组也可以用<code>Vue.set/vm.$set()</code></p></li></ul><h3 id="1-12-收集表单元素"><a href="#1-12-收集表单元素" class="headerlink" title="1.12 收集表单元素"></a><strong>1.12 收集表单元素</strong></h3><p>v-model收集的是value值，得在<code>&lt;input&gt;</code>中配置value</p><p>多选框v-model对应的data要配置为数组</p><p>v-model也有修饰符，如<code>v-model.number</code>可以限制输入数据为数字类型，<code>v-model.lazy</code>可以在失去焦点时再收集，<code>v-model.trim</code>可以去掉前后空格</p><h3 id="1-13-过滤器"><a href="#1-13-过滤器" class="headerlink" title="1.13 过滤器"></a><strong>1.13 过滤器</strong></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;&#123;time | timeFormater | methods2 | ...&#125;&#125;<br><span class="hljs-comment">//创建全局过滤器</span><br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">filter</span>()<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br><span class="hljs-attr">filters</span>:&#123;<br><span class="hljs-title function_">timeFormater</span>(<span class="hljs-params">value</span>)&#123;<br>pass<br>&#125;<br>&#125;<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="1-14-Vue指令"><a href="#1-14-Vue指令" class="headerlink" title="1.14 Vue指令"></a>1.14 Vue指令</h3><table><thead><tr><th>指令</th><th>用途</th></tr></thead><tbody><tr><td>v-bind</td><td>单向绑定解析式，可简写为:xxx</td></tr><tr><td>v-model</td><td>双向数据绑定</td></tr><tr><td>v-for</td><td>遍历数组&#x2F;对象&#x2F;字符串</td></tr><tr><td>v-on</td><td>绑定事件监听，可简写为@</td></tr><tr><td>v-else</td><td>条件渲染</td></tr><tr><td>v-show</td><td>条件渲染</td></tr><tr><td>v-if</td><td>条件渲染</td></tr><tr><td>v-text</td><td>向所在节点渲染文本，并且替换原有文本</td></tr><tr><td>v-html</td><td>支持结构解析(可以在数据中放标签)<br />安全性问题：cookie作字符传，XSS攻击</td></tr><tr><td>v-cloak</td><td>配合css可以控制页面在Vue接管前的效果，可以解决JS阻塞，和未经解析的模板渲染到页面</td></tr><tr><td>v-once</td><td>所在节点在初次动态渲染后，视为静态内容；以后的数据改变不改变内容，可用于优化性能</td></tr><tr><td>v-pre</td><td>跳过节点编译过程，Vue不解析</td></tr></tbody></table><ul><li><p><strong>自定义指令</strong>（全局&#x2F;局部 写法与过滤器一致）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;span v-xxx=<span class="hljs-string">&quot;n&quot;</span>&gt;&lt;/span&gt;<br><span class="hljs-attr">data</span>:&#123;<br><span class="hljs-attr">n</span>:<span class="hljs-number">1</span><br>&#125;<br><span class="hljs-attr">directives</span>:&#123;<br><span class="hljs-comment">// 自定义指令函数何时调用</span><br><span class="hljs-comment">// 1. 指令与元素绑定时（一上来）</span><br><span class="hljs-comment">// 2. 指令所在模板被重新解析时</span><br><span class="hljs-title function_">xxx</span>(<span class="hljs-params">element真实DOM元素, binding绑定信息</span>)&#123;<br><span class="hljs-comment">//操作DOM元素</span><br>&#125;<br><span class="hljs-comment">//写成对象可以选择操作的生命周期</span><br><span class="hljs-attr">xxx2</span>:&#123;<br><span class="hljs-title function_">bind</span>(<span class="hljs-params"></span>)&#123;&#125;,<br><span class="hljs-title function_">inserted</span>(<span class="hljs-params"></span>)&#123;&#125;, <span class="hljs-comment">//绑定元素插入时（获取焦点/拿到父元素...）</span><br><span class="hljs-title function_">update</span>(<span class="hljs-params"></span>)&#123;&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="1-15-生命周期"><a href="#1-15-生命周期" class="headerlink" title="1.15 生命周期"></a><strong>1.15 生命周期</strong></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br><span class="hljs-attr">el</span>:<span class="hljs-string">&quot;#root&quot;</span>,<br><span class="hljs-attr">data</span>:&#123;&#125;,<br><span class="hljs-attr">methods</span>:&#123;&#125;,<br><span class="hljs-comment">// 生命周期回调函数 / 生命周期钩子</span><br><span class="hljs-title function_">beforecreated</span>(<span class="hljs-params"></span>)&#123;&#125;, <span class="hljs-comment">// 不能访问data和methods，数据代理尚未开始，初始化事件</span><br><span class="hljs-title function_">created</span>(<span class="hljs-params"></span>)&#123;&#125;,       <span class="hljs-comment">// 初始化-数据检测和数据代理</span><br><br><span class="hljs-comment">// 有无el</span><br><span class="hljs-comment">// 有无template，有：编译，无：将el的outerHTML当作template</span><br><span class="hljs-comment">// 解析模板，生成虚拟DOM，但还不能显示解析好的内容</span><br><br><span class="hljs-title function_">beforemounted</span>(<span class="hljs-params"></span>)&#123;&#125;, <span class="hljs-comment">// 页面呈现未经Vue编译的DOM，对DOM操作不显示</span><br><br><span class="hljs-comment">//虚拟DOM转为真实DOM，插入页面</span><br><br><span class="hljs-comment">// Vue完成模板解析，并把初始的真实DOM元素放入页面后（挂载完毕），调用mounted</span><br><span class="hljs-comment">// 初始化过程结束</span><br><span class="hljs-comment">// 开启定时器，发送网络请求，订阅消息，绑定自定义事件</span><br><span class="hljs-title function_">mounted</span>(<span class="hljs-params"></span>)&#123;&#125;,<br><span class="hljs-comment">// 挂载流程↑</span><br><br><span class="hljs-comment">// 更新流程↓</span><br><span class="hljs-comment">// 当data中数据改变</span><br><span class="hljs-title function_">beforeUpdate</span>(<span class="hljs-params"></span>)&#123;&#125;, <span class="hljs-comment">// 数据新，页面旧</span><br><span class="hljs-comment">// 新旧DOM比较，完成页面更新，完成Model→View的更新</span><br><span class="hljs-title function_">updated</span>(<span class="hljs-params"></span>)&#123;&#125;,      <span class="hljs-comment">// 页面数据同步完成</span><br><br><span class="hljs-comment">//销毁流程 ↓</span><br><span class="hljs-comment">// vm.$destroy(), 解绑全部指令和自定义事件监听器</span><br><span class="hljs-title function_">beforeDestroy</span>(<span class="hljs-params"></span>)&#123;&#125;,<span class="hljs-comment">// data/methods/指令都可用但已经不触发更新，关闭定时器，取消订阅消息，解绑自定义事件</span><br><span class="hljs-title function_">destroyed</span>(<span class="hljs-params"></span>)&#123;&#125;<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="1-16-组件"><a href="#1-16-组件" class="headerlink" title="1.16 组件"></a><strong>1.16 组件</strong></h3><p>依据不同页面部分编码组件，封装功能，提高复用率</p><p><strong>定义</strong>：实现应用中局部功能代码和资源的集合</p><p><strong>非单文件组件</strong>：一个文件中包含n个组件</p><p><strong>单文件组件</strong>：一个文件只包含一个组件</p><ul><li><h6 id="如何创建组件"><a href="#如何创建组件" class="headerlink" title="如何创建组件"></a>如何创建组件</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 1. 创建school组件</span><br><span class="hljs-keyword">const</span> school = <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">extend</span>(&#123;<br><span class="hljs-attr">template</span>:<span class="hljs-string">`&lt;div&gt;&lt;h2&gt;123&lt;/h2&gt;&lt;div&gt;`</span><br><span class="hljs-title function_">data</span>():&#123;<br><span class="hljs-keyword">return</span> &#123;<br><span class="hljs-comment">//data</span><br>&#125;<br>&#125;<br>&#125;)<br><span class="hljs-comment">// 2. 注册组件(局部注册)</span><br><span class="hljs-comment">// Vue.component(&#x27;school&#x27;,school) 全局注册</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br><span class="hljs-attr">el</span>:<span class="hljs-string">&quot;#root&quot;</span>,<br><span class="hljs-attr">components</span>:&#123;<br><span class="hljs-attr">school</span>:school<br><span class="hljs-attr">student</span>:student<br>&#125;<br>&#125;)<br><span class="hljs-comment">// 3. 编写组件标签</span><br>&lt;div id=<span class="hljs-string">&quot;root&quot;</span>&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">school</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">school</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">student</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">student</span>&gt;</span></span><br>&lt;/div&gt;<br></code></pre></td></tr></table></figure><ul><li><p>组件名首字母推荐大写，可以用kebab-case&#x2F;CamelCase方法命名</p></li><li><p>使用name配置变量可以改变在开发者工具中的标签名显示</p></li><li><p>组件嵌套</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> school = <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">extend</span>(&#123;<br><span class="hljs-attr">template</span>:<span class="hljs-string">`&lt;div&gt;&lt;h2&gt;123&lt;/h2&gt;&lt;div&gt;`</span><br><span class="hljs-title function_">data</span>():&#123;<br><span class="hljs-keyword">return</span> &#123;<br><span class="hljs-comment">//data</span><br>&#125;<br>&#125;<br><span class="hljs-attr">components</span>:&#123;<br><span class="hljs-attr">student</span>:student <span class="hljs-comment">//先在前面准备好stu组件</span><br>&#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>最外层要写<App>组件</p></li></ul></li></ul><p><strong>每次调用Vue.extend，返回的都是全新的VueComponent</strong></p><ul><li><p><strong>Vue实例&amp;组件实例</strong> vm&amp;vc</p><p>一个内置关系：<code>VueComponent.prototype.__proto__ === Vue.prototype</code></p><p>让vc可以访问Vue的原型对象（属性&#x2F;方法）</p><p><img src="/2025/08/24/VUE/image-20240121161258-x4kypis.png" alt="image.png"></p></li></ul><h3 id="1-17-单文件组件"><a href="#1-17-单文件组件" class="headerlink" title="1.17 单文件组件"></a>1.17 单文件组件</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;template&gt;<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;demo&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&lt;/template&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// ES6，默认暴露</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span>&#123;</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-title function_">data</span>(<span class="hljs-params"></span>)&#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">return</span>&#123;</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-attr">schoolName</span>:<span class="hljs-string">&quot;&quot;</span>,</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-attr">address</span>:<span class="hljs-string">&quot;&quot;</span></span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;,</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-title function_">methods</span>(<span class="hljs-params"></span>)&#123;&#125;</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></span><br></code></pre></td></tr></table></figure><ul><li><p>脚手架结构</p><p>App.vue ↓</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;template&gt;<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">School</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">School</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Student</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Student</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&lt;/template&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 引入组件</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">import</span> <span class="hljs-title class_">School</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./School&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">import</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./Student&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml">  </span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// ES6，默认暴露</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span>&#123;</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-attr">name</span>:<span class="hljs-string">&quot;App&quot;</span>,</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-attr">components</span>:&#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-title class_">School</span>,</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-title class_">Student</span></span></span><br><span class="language-javascript"><span class="language-xml">&#125;</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>main.js ↓</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./App.vue&#x27;</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>    <span class="hljs-attr">el</span>:<span class="hljs-string">&quot;#&quot;</span>,<br>    <span class="hljs-attr">component</span>:&#123;<span class="hljs-title class_">App</span>&#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>index.html ↓</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPR <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">chatset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;root&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">App</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">App</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../js/vue.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../main.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="1-18-Vue脚手架-Cli-command-line-interface"><a href="#1-18-Vue脚手架-Cli-command-line-interface" class="headerlink" title="1.18 Vue脚手架 Cli (command line interface)"></a>1.18 Vue脚手架 Cli (command line interface)</h3><ul><li><h6 id="ref-属性"><a href="#ref-属性" class="headerlink" title="ref 属性"></a>ref 属性</h6><p>替代原生JS中id属性，<u>HTML元素</u>​<code>&lt;span ref=&quot;xxx&quot;&gt;</code>,<code>this.$refs.xxx</code>可以拿到DOM节点</p><p><u>组件标签</u>加ref可以拿到自定义组件的实例对象vc</p></li><li><h6 id="props配置项"><a href="#props配置项" class="headerlink" title="props配置项"></a>props配置项</h6><p>让组件接收外部传入的数据，如要修改可在data()中作中转</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">Student</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-attr">sex</span>=<span class="hljs-string">&quot;男&quot;</span>, <span class="hljs-attr">:age</span>=<span class="hljs-string">&quot;18&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Student</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script&gt;<br>    <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br><span class="hljs-attr">name</span>:<span class="hljs-string">&quot;Student&quot;</span>,<br><span class="hljs-title function_">data</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">return</span> &#123;<br><span class="hljs-attr">msg</span>:<span class="hljs-string">&quot;123&quot;</span><br>    &#125;<br>&#125;,<br><span class="hljs-attr">props</span>:[<span class="hljs-string">&#x27;name&#x27;</span>,<span class="hljs-string">&#x27;sex&#x27;</span>,<span class="hljs-string">&#x27;age&#x27;</span>] <span class="hljs-comment">//1. 简单接收</span><br><span class="hljs-attr">props</span>:&#123;   <span class="hljs-comment">//2. 类型限制接收</span><br>    <span class="hljs-attr">name</span>:<span class="hljs-title class_">String</span>,<br>    <span class="hljs-attr">sex</span>:<span class="hljs-title class_">String</span>,<br>    <span class="hljs-attr">age</span>:<span class="hljs-title class_">Number</span><br>&#125;<br><span class="hljs-attr">props</span>:&#123;   <span class="hljs-comment">//3. 类型限制/默认值/必要性接收</span><br>    <span class="hljs-attr">name</span>:&#123;<br><span class="hljs-attr">type</span>:<span class="hljs-title class_">String</span>,<br><span class="hljs-attr">required</span>:<span class="hljs-literal">true</span><br>    &#125;,<br>    <span class="hljs-attr">sex</span>:&#123;<br><span class="hljs-attr">type</span>:<span class="hljs-title class_">String</span>,<br><span class="hljs-attr">required</span>:<span class="hljs-literal">true</span><br>    &#125;,<br>    <span class="hljs-attr">age</span>:&#123;<br><span class="hljs-attr">type</span>:<span class="hljs-title class_">String</span>,<br><span class="hljs-attr">default</span>:<span class="hljs-number">99</span><br>    &#125;<br>&#125;<br>    &#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure></li><li><h6 id="mixin配置项"><a href="#mixin配置项" class="headerlink" title="mixin配置项"></a>mixin配置项</h6><p>复用JS代码，写一个js文件后，在各Vue组件中用mixin引入</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//mixin.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> mixin = &#123;<br>    <span class="hljs-attr">methods</span>:&#123;<br><span class="hljs-title function_">func</span>(<span class="hljs-params"></span>)&#123;&#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">// 引入一个mixin</span></span><br><span class="language-javascript">    <span class="hljs-keyword">import</span> &#123;mixin&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;src&quot;</span></span><br><span class="language-javascript">    <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span>&#123;</span><br><span class="language-javascript"><span class="hljs-attr">name</span>:<span class="hljs-string">&quot;&quot;</span>,</span><br><span class="language-javascript"><span class="hljs-title function_">data</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript"> <span class="hljs-attr">name</span>:<span class="hljs-string">&quot;&quot;</span>,</span><br><span class="language-javascript"><span class="hljs-attr">address</span>:<span class="hljs-string">&quot;&quot;</span></span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">&#125;,</span><br><span class="language-javascript"><span class="hljs-attr">mixin</span>:[mixin]</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>// 在main.js中引入的话，是全局的引入<br>Vue.mixin(mixin)<br></code></pre></td></tr></table></figure></li><li><h6 id="Vue插件"><a href="#Vue插件" class="headerlink" title="Vue插件"></a>Vue插件</h6><p>增强Vue</p><p>src中另起一个plugins.js，新建一个包含install方法的对象，即为插件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span>&#123;<br>    <span class="hljs-comment">// 牛逼的地方是能直接拿到Vue作为形参</span><br>    <span class="hljs-comment">// 全局过滤器filter，全局指令directive，混入mixin，</span><br>    <span class="hljs-comment">// Vue原型添加方法prototype.hello等，就都可以写在插件中</span><br>    <span class="hljs-title function_">install</span>(<span class="hljs-params">Vue</span>)&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>main.js中import插件，并<code>Vue.use(plugins)</code></p></li><li><h6 id="scoped样式"><a href="#scoped样式" class="headerlink" title="scoped样式"></a>scoped样式</h6><p><code>&lt;style scoped&gt;</code> 可以限制样式标签中的内容只对当前文件有效</p><p><code>&lt;style lang=&quot;less&quot;&gt;</code> 可以用less语法</p></li></ul><h3 id="1-19-组件通信-组件化编码"><a href="#1-19-组件通信-组件化编码" class="headerlink" title="1.19 组件通信&amp;组件化编码"></a>1.19 组件通信&amp;组件化编码</h3><ul><li><h6 id="组件化编码流程"><a href="#组件化编码流程" class="headerlink" title="组件化编码流程"></a>组件化编码流程</h6><ol><li><p>拆分&#x3D;&#x3D;静态组件&#x3D;&#x3D;</p><p> 按功能拆分，命名不与html元素冲突</p></li><li><p>实现&#x3D;&#x3D;动态组件&#x3D;&#x3D;（根据使用数据的组件数量，考虑数据存放位置）</p><p> 一个组件用 &#x3D;&gt; 放在组件自身</p><p> 多个组件用 &#x3D;&gt; 放在共同的父组件上（状态提升）</p></li><li><p>实现交互：绑定事件</p></li></ol></li><li><h6 id="props适用"><a href="#props适用" class="headerlink" title="props适用"></a>props适用</h6><p>(1). 父组件 → 子组件 通信</p><p>(2). 子组件→父组件 通信（父先给子一个函数）</p><p>props传的值是不可修改的<br>若props传的是对象，修改不会报错，但仍不建议修改</p></li></ul><h3 id="1-20-浏览器本地存储"><a href="#1-20-浏览器本地存储" class="headerlink" title="1.20 浏览器本地存储"></a>1.20 浏览器本地存储</h3><ul><li><h6 id="Local-Storage"><a href="#Local-Storage" class="headerlink" title="Local Storage"></a>Local Storage</h6><ol><li><p><strong>保存数据</strong></p><p> <code>window.localStorage.setItem(&#39;key&#39;,&#39;value&#39;)</code></p><p> 当value为对象时，存入需要调用<code>JSON.stringify(value)</code></p></li><li><p><strong>读取数据</strong></p><p> <code>window.localStorage.getItem(&#39;key&#39;)</code></p><p> 同样的，读取结果为对象时需要<code>JSON.parse(value)</code></p></li><li><p><strong>删除数据</strong></p><p> <code>window.localStorage.removeItem(&#39;key&#39;)</code></p><p> <code>localStorage.clear()</code></p></li></ol></li><li><h6 id="Session-Storage"><a href="#Session-Storage" class="headerlink" title="Session Storage"></a>Session Storage</h6>与LocalStorage不同的时，<u>关闭浏览器后将会消失</u>。API一致。</li></ul><h3 id="1-21-组件自定义事件"><a href="#1-21-组件自定义事件" class="headerlink" title="1.21 组件自定义事件"></a>1.21 组件自定义事件</h3><ul><li><p>通过父组件给子组件&#x3D;&#x3D;绑定&#x3D;&#x3D;一个自定义事件，实现<strong>子对父传递数据</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>    // 使用@ / v-on<br>    <span class="hljs-tag">&lt;<span class="hljs-name">sonComponent</span> @<span class="hljs-attr">customEvent</span>=<span class="hljs-string">&#x27;methodName&#x27;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;App&#x27;</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">components</span>:&#123;sonComponent&#125;,</span><br><span class="language-javascript">    <span class="hljs-attr">methods</span>:&#123;</span><br><span class="language-javascript"><span class="hljs-title function_">methodName</span>(<span class="hljs-params"></span>)&#123;...&#125;</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html">// sonComponent <br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;sonComponent&#x27;</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">methods</span>:&#123;</span><br><span class="language-javascript"><span class="hljs-title function_">methodName</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript">    <span class="hljs-comment">// 触发子组件组件实例上的自定义事件，完成回调</span></span><br><span class="language-javascript">    <span class="hljs-variable language_">this</span>.$emit(<span class="hljs-string">&#x27;customEvent&#x27;</span>，<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>)</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>&#x3D;&#x3D;或者在父组件中使用ref，会更加灵活，可以在钩子上加其他需求&#x3D;&#x3D;</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>    // 使用ref<br>    <span class="hljs-tag">&lt;<span class="hljs-name">sonComponent</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#x27;sonComponent&#x27;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;App&#x27;</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">components</span>:&#123;sonComponent&#125;,</span><br><span class="language-javascript">    <span class="hljs-attr">methods</span>:&#123;</span><br><span class="language-javascript"><span class="hljs-title function_">methodName</span>(<span class="hljs-params"></span>)&#123;...&#125;</span><br><span class="language-javascript">    &#125;,</span><br><span class="language-javascript">    <span class="hljs-title function_">mounted</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript"><span class="hljs-variable language_">this</span>.<span class="hljs-property">$refs</span>.<span class="hljs-property">sonComponent</span>.$on(<span class="hljs-string">&#x27;customEvent&#x27;</span>,<span class="hljs-variable language_">this</span>.<span class="hljs-property">methodName</span>)</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>注意：通过<code>this.$refs.sonComponent.$on(&#39;customEvent&#39;,this.methodName回调)</code>绑定自定义事件时，回调要么配置在methods中，要么使用箭头函数，否则this指向会有问题</p></li><li><p>&#x3D;&#x3D;解绑&#x3D;&#x3D;自定义事件</p><p><code>this.$off([&#39;customEvent1&#39;,&#39;customEvent2&#39;])</code></p><p><code>this.$off()</code> - 不传参就解绑所有自定义事件</p></li></ul><p><code>@click.native</code>告诉组件使用的是原生事件，不然就全当自定义事件</p><h3 id="1-22-全局事件总线"><a href="#1-22-全局事件总线" class="headerlink" title="1.22 全局事件总线"></a>1.22 全局事件总线</h3><p><strong>实现任意组件间通信</strong></p><p>两个要求：1.所有组件都能看见；2.拥有Vue原型上的API($on&#x2F;emit&#x2F;…)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// main.js</span><br><span class="hljs-keyword">const</span> vm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>    <span class="hljs-attr">el</span>:<span class="hljs-string">&#x27;#app&#x27;</span>,<br>    <span class="hljs-attr">render</span>:<span class="hljs-function"><span class="hljs-params">h</span>=&gt;</span><span class="hljs-title function_">h</span>(<span class="hljs-title class_">App</span>),<br>    <span class="hljs-title function_">beforeCreate</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">$bus</span>=<span class="hljs-variable language_">this</span> <span class="hljs-comment">//安装全局事件总线</span><br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p><strong>如何使用事件总线？</strong></p><ol><li><p><u>接收数据</u>：A组件接收数据，就在A组件中给$bus绑定自定义事件，将回调留在自身</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">methods</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-title function_">demo</span>(<span class="hljs-params">data</span>)&#123;...&#125;<br>&#125; <br><span class="hljs-title function_">mounted</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">$bus</span>.$on(<span class="hljs-string">&#x27;customEvent&#x27;</span>,<span class="hljs-variable language_">this</span>.<span class="hljs-property">demo</span>)<br>&#125;<br><span class="hljs-comment">//使用后要销毁，不然将一直占用bus</span><br><span class="hljs-title function_">beforeDestroy</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">$bus</span>.$off(<span class="hljs-string">&#x27;customEvent&#x27;</span>)<br>&#125;<br><br></code></pre></td></tr></table></figure></li><li><p><u>提供数据</u></p><p> <code>this.$bus.$emit(&#39;customEvent&#39;, 数据)</code></p></li></ol><h3 id="1-23-消息订阅与发布"><a href="#1-23-消息订阅与发布" class="headerlink" title="1.23 消息订阅与发布"></a>1.23 消息订阅与发布</h3><p><strong>实现任意组件间通信</strong></p><p>pubsub.js实现消息订阅与发布</p><p><strong>接收方：订阅</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> pubsub <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;pubsub-js&#x27;</span><br>...<br><span class="hljs-title function_">mounted</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">pubId</span> = pubsub.<span class="hljs-title function_">subscribe</span>(<span class="hljs-string">&#x27;消息名&#x27;</span>,<span class="hljs-function">(<span class="hljs-params">msgName,data</span>)=&gt;</span>&#123;<br>...<br>    &#125;)<br>&#125;<br><span class="hljs-title function_">beforeDestroy</span>(<span class="hljs-params"></span>)&#123;<br>    pubsub.<span class="hljs-title function_">unsubscribe</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">pubId</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>发布方</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">method</span>:&#123;<br>    <span class="hljs-title function_">methodName</span>(<span class="hljs-params"></span>)&#123;<br>pubsub.<span class="hljs-title function_">publish</span>(<span class="hljs-string">&#x27;消息名&#x27;</span>,params)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-24-ajax配置代理"><a href="#1-24-ajax配置代理" class="headerlink" title="1.24 ajax配置代理"></a>1.24 ajax配置代理</h3><p>‍</p>]]></content>
    
    
    <categories>
      
      <category>开发技术</category>
      
      <category>前端开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发技术</tag>
      
      <tag>笔记</tag>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>知识蒸馏</title>
    <link href="/2025/08/23/%E7%9F%A5%E8%AF%86%E8%92%B8%E9%A6%8F/"/>
    <url>/2025/08/23/%E7%9F%A5%E8%AF%86%E8%92%B8%E9%A6%8F/</url>
    
    <content type="html"><![CDATA[<p>模型知识蒸馏相关知识点总结，包括实现流程，作用，分类等。持续更新中…</p><span id="more"></span><ul><li><h1 id="Model-Distillation"><a href="#Model-Distillation" class="headerlink" title="Model Distillation"></a>Model Distillation</h1><p>模型蒸馏（Model Distillation）最初由Hinton等人在2015年提出，其核心思想是通过知识迁移的方式，将一个复杂的大模型（教师模型）的知识传授给一个相对简单的小模型（学生模型）</p><p>简单概括就是利用教师模型的预测概率分布作为**<u>软标签</u>**对学生模型进行训练，从而在保持较高预测性能的同时，极大地降低了模型的复杂性和计算资源需求，实现模型的轻量化和高效化。</p><h2 id="1-实现流程"><a href="#1-实现流程" class="headerlink" title="1. 实现流程"></a><span id="20250817100222-inxve8k" style="display: none;"></span>1. 实现流程</h2><p><img src="/2025/08/23/%E7%9F%A5%E8%AF%86%E8%92%B8%E9%A6%8F/image-20250817101038-hh5qxdu.png" alt="image">​</p><ol><li><p><strong>准备教师模型和学生模型</strong></p><p> 首先，我们需要一个已经训练好的教师模型和一个待训练的学生模型。教师模型通常是一个性能较好但计算复杂度较高的模型，而学生模型则是一个计算复杂度较低的模型。</p></li><li><p><strong>使用教师模型对数据集进行预测</strong></p><p> 得到每个样本的预测概率分布（软目标）。这些概率分布包含了模型对每个类别的置信度信息。</p></li><li><p><strong>定义损失函数</strong></p><p> 损失函数用于衡量学生模型的输出与教师模型的输出之间的差异。在模型蒸馏中，我们通常会使用一种结合了&#x3D;&#x3D;软标签损失Distillation Loss&#x3D;&#x3D;和&#x3D;&#x3D;硬标签损失Student Loss&#x3D;&#x3D;的混合损失函数（通常这两个损失都可以看作交叉熵损失）。软标签损失鼓励学生模型模仿教师模型的输出概率分布，这通常使用 <u>KL 散度（Kullback-Leibler Divergence）</u>来度量，而硬标签损失则鼓励学生模型正确预测真实标签。</p><p> 其中，软标签损失$\text{SoftLoss} &#x3D; \frac{1}{T^{2}} \sum_{i&#x3D;1}^{C} q_{i} \log \left( \frac{q_{i}}{p_{i}} \right)$，硬标签损失（交叉熵）$\text{HardLoss} &#x3D; -\sum_{i&#x3D;1}^{C} y_{i} \log\left(p_{i}\right)$<br> 总损失为$\text{TotalLoss} &#x3D; \alpha \cdot \text{SoftLoss} + (1 - \alpha) \cdot \text{HardLoss}$  </p><blockquote><p><strong>KL散度（Kullback-Leibler divergence）</strong></p><p>可以以称作相对熵（relative entropy）或信息散度（information divergence）。</p><p>$KL(p|q)$表示用分布 $q$ 拟合分布 $p$ 带来的误差。其中 $p$ 是输出的真实分布，我们的数据集的标签 $y$ 就从这个分布中采样而来。<br>对于一个 $K$ 分类问题， $y_i$ 常常会表示为one-hot向量，包含1个1和 $K - 1$ 个0。对于模型蒸馏，损失函数可以表示为 $KL(q_t||q_s)$ ，<br>表示用学生模型的输出 $q_s$ 来拟合教师模型的输出 $q_t$ 。</p><p>KL散度的理论意义在于度量两个概率分布之间的差异程度，当KL散度越大的时候，说明两者的差异程度越大；而当KL散度小的时候，则说明两者的差异程度小。<br>如果两者相同的话，则该KL散度应该为0。</p></blockquote></li><li><p><strong>训练学生模型</strong></p><p> 在训练过程中，我们将教师模型的输出作为监督信号，通过优化损失函数来更新学生模型的参数。这样，学生模型就可以从教师模型中学到有用的知识。<br> KL 散度的计算涉及一个<u>温度参数</u>，该参数可以调整软目标的分布。温度较高会使分布更加平滑。在训练过程中，可以逐渐降低温度以提高蒸馏效果。</p><blockquote><p><strong>蒸馏中的温度（Softmax With Temperature）</strong></p><p><strong>为什么需要温度系数？</strong></p><p>模型在训练收敛后，往往通过softmax的输出不会是完全符合one-hot向量那样极端分布的，而是在各个类别上均有概率，推断时通过argmax取得概率最大的类别。<br>Hinton的文章指出，教师模型中在这些负类别上输出的概率分布包含了一定的隐藏信息。比如MNIST手写数字识别，标签为7的样本在输出时，类别7的概率虽然最大，但和类别1的概率更加接近，这就说明1和7很像，这是模型已经学到的隐藏的知识。<br>我们在使用softmax的时候往往会将一个差别不大的输出变成很极端的分布，导致类别间的隐藏的相关性信息不再那么明显，为了解决这个问题，我们就引入了温度系数。</p><p><strong>如何使用温度？</strong></p><p>下图最左侧是我们数据的原始分布，右侧分别展示了不同温度系数下的分布情况。可以看出，高温的分布均匀，低温的分布尖锐，T&#x3D;1.0时输出为softmax输出分布。<br>引入温度系数的本质目的，就是让softmax的soft程度变成可以调节的超参数。<br>如果是模型蒸馏， $L_1$ 项始终都使用较大的温度；如果是使用真实标签训练，确实选取较小的温度系数，更利于模型收敛。<br><span data-type="text" style="color: var(--b3-font-color8);">可以这样理解，温度系数较大时，模型需要训练得到一个很陡峭的输出，经过softmax之后才能获得一个相对陡峭的结果；温度系数较小时，模型输出稍微有点起伏，softmax就很敏感地把分布变得尖锐，认为模型学到了知识。</span></p><p><img src="/2025/08/23/%E7%9F%A5%E8%AF%86%E8%92%B8%E9%A6%8F/image-20250817104657-jp8g07n.png" alt="image">​</p></blockquote></li><li><p><strong>微调学生模型</strong></p><p> 在蒸馏过程完成后，可以对学生模型进行进一步的微调，以提高其性能表现。</p></li></ol><p>‍</p><h2 id="2-作用"><a href="#2-作用" class="headerlink" title="2. 作用"></a>2. 作用</h2><ol><li><strong>模型轻量化</strong>：通过将大型模型的知识迁移到小型模型中，可以显著降低模型的复杂度和计算量</li><li><strong>降本增效</strong>：运行时速度更快，降低了计算成本和能耗，进一步的，减少了对硬件资源的需求，降低模型运行成本</li><li><strong>泛化能力</strong>：模型蒸馏可能帮助学生模型学习到教师模型中蕴含的泛化模式，提高其在未见过的数据上的表现</li></ol><p>‍</p><h2 id="3-分类"><a href="#3-分类" class="headerlink" title="3. 分类"></a>3. 分类</h2><p>我们在<a href="#20250817100222-inxve8k">实现流程</a>中介绍的是蒸馏技术的一种，<strong>基于响应</strong>的软标签知识蒸馏。这是最早期、最经典也是最常用的一种蒸馏方式。<br>但Response-Based的知识来源单一，只利用了模型的最后一层信息，忽略了网络中间层包含的大量丰富的特征信息。<br>基于特征的知识蒸馏可以弥补这种缺陷</p><ol><li><h3 id="Feature-Based-Knowledge-Distillation"><a href="#Feature-Based-Knowledge-Distillation" class="headerlink" title="Feature-Based Knowledge Distillation"></a><strong>Feature-Based Knowledge Distillation</strong></h3><p> Feature-based 蒸馏让学生模型模仿教师模型中间层的特征表示，中间层特征保留更多结构与空间信息，早期层能引导学生捕捉关键模式，适用于目标检测、分割等任务</p><p> 但教师和学生结构差异大时对齐较难，且特征对齐会增加内存和训练复杂度</p><ul><li><p><strong>FitNets: Hints for Thin Deep Nets</strong>  <strong>（Romero et al., ICLR 2015）</strong></p><ul><li><p><strong>动机：</strong></p><p>人们发现直接训练一个又深又窄的学生网络非常困难，因为它梯度传播路径长，容易出现梯度消失&#x2F;爆炸。同时，仅仅用最终的软标签来指导它，对网络前、中段的层来说，监督信号太间接、太弱了。学生网络不知道如何正确地初始化和学习其早期层。</p></li><li><p><strong>方法：</strong></p><p>FitNets巧妙地将训练过程分为<strong>两个阶段</strong>，引入了“提示”（Hint）的概念：</p><ol><li><p><strong>提示训练(Hint-based Training)</strong></p><p> 从教师模型中选择一个中间层（称为Hint层），并从学生模型中选择一个相对较深的中间层（因为学生网络更窄，需要更深才能达到相似的表征能力）<br> 由于学生和老师的特征图通道数、尺寸可能不同，在学生模型的Hint层后面加了一个卷积回归器（regressor），将学生的特征图在形状上匹配到老师的特征图<br> 此阶段，只训练学生模型从输入层到Hint层以及回归器部分的参数。网络后面的部分不参与训练。这相当于在老师的指导下，先把学生网络的前半部分“扶上正轨”</p></li><li><p><strong>完整知识蒸馏训练 (Full Distillation Training)</strong></p><p> 在学生网络前半部分被预训练好之后，丢弃那个临时的回归器。<br> 用经典的基于响应的知识蒸馏来训练整个学生网络。即，总损失 = 蒸馏损失 (软标签) + 学生损失 (硬标签)</p></li></ol></li></ul></li><li><p><strong>Attention Transfer（Zagoruyko &amp; Komodakis, 2017）</strong></p><ul><li><p><strong>动机：</strong></p><p>FitNets强制学生模仿老师完整的特征图，这可能过于严苛和冗余。特征图中真正重要的是<u>模型“关注”的空间区域</u>。<br>比如在识别一只鸟时，网络应该更关注鸟本身，而不是背景的天空。这种“注意力”信息比像素级的特征值更抽象，也更关键。</p></li><li><p><strong>方法：</strong></p><p>AT的核心是让学生模仿老师的<span data-type="text" style="color: var(--b3-font-color8);">注意力图（Attention Map）</span></p><ol><li><p><strong>定义注意力图</strong></p><p> 如何从一个普通的特征图中提取注意力图？作者提出了一种简单而有效的方法：计算特征图在通道维度上的统计量。<br> 具体来说，可以将一个形状为 [C, H, W] 的特征图，通过计算每个空间位置(h, w)上所有通道激活值的p范数（通常用L2范数），来生成一个 [H, W] 的注意力图。这个图的每个像素值代表了模型在该空间位置的“关注强度”。</p><p> $AttentionMap(h, w) &#x3D; || FeatureMap[:, h, w] ||_p$</p></li><li><p><strong>传递注意力</strong></p><p> 在教师和学生网络的对应阶段（例如，每个ResNet block的输出），分别生成注意力图<br> 蒸馏损失被定义为教师和学生的**<u><em>注意力图之间的L2距离</em></u>**。为了让不同尺度的注意力图具有可比性，通常会先对其进行归一化<br> 这个注意力损失可以与经典的蒸馏损失和分类损失结合在一起，进行端到端的训练</p></li></ol></li></ul></li></ul></li><li><h3 id="Relation-based-Knowledge-Distillation"><a href="#Relation-based-Knowledge-Distillation" class="headerlink" title="Relation-based Knowledge Distillation"></a>Relation-based <strong>Knowledge Distillation</strong></h3><p> 前面提到响应蒸馏关注预测结果，特征蒸馏关注中间层特征表示<br> 而关系蒸馏认为，孤立的特征值或预测值不是最重要的，最重要的是样本之间、或者特征之间的相互关系。学生应该学习老师是如何组织和看待整个数据流形结构的。<br> 这种方法关注的是 <strong>样本之间 &#x2F; 通道之间 &#x2F; 空间之间</strong>的结构组织信息，例如“哪些样本更相似”。</p><ul><li><p><strong>Relational Knowledge Distillation (RKD) (Park et al., CVPR 2019)</strong></p><ul><li><p><strong>动机</strong></p><p>直接匹配特征（如FitNets）可能会因为教师和学生的能力差异（Capacity Gap）而受限。一个简单的学生模型可能永远无法完美复现复杂教师模型的特征。<br>RKD提出，我们不需要模仿特征本身，只需要模仿数据样本在特征空间中的相对关系。</p></li><li><p><strong>方法</strong></p><p>RKD在一个mini-batch的数据内，构建样本间的关系，并让学生模仿。</p><ol><li><p><strong>提取特征:</strong>  从一个包含N个样本的批次中，分别提取教师和学生的特征嵌入（embeddings），得到教师的特征集${t_1, t_2, …, t_N}$ 和学生的特征集${s_1, s_2, …, s_N}$</p></li><li><p><strong>定义关系损失</strong></p><p> <strong>距离关系:</strong>  计算批次内每两个样本特征之间的欧氏距离，形成一个N x N的距离矩阵。让学生的距离矩阵与老师的距离矩阵尽可能相似；<br> <strong>角度关系:</strong>  计算批次内每两个样本特征向量之间的夹角（余弦相似度）。形成一个 N x N 的角度矩阵。让学生的角度矩阵与老师的角度矩阵相似。</p></li></ol><p>使用Huber损失来计算教师和学生关系矩阵之间的差异</p></li></ul></li></ul></li></ol></li></ul><p>‍</p>]]></content>
    
    
    <categories>
      
      <category>算法技术</category>
      
      <category>基础算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>更新中</tag>
      
      <tag>算法技术</tag>
      
      <tag>大模型技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JAVA基础</title>
    <link href="/2025/06/02/JAVA%E5%9F%BA%E7%A1%80/"/>
    <url>/2025/06/02/JAVA%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<p>根据各类网络教程总结的JAVA语言基础知识点，仍在持续更新中…</p><span id="more"></span><h1 id="·-入门"><a href="#·-入门" class="headerlink" title="· 入门"></a><strong>· 入门</strong></h1><p><img src="/2025/06/02/JAVA%E5%9F%BA%E7%A1%80/image-20220706104753-pdrchly.png" alt="image.png">java11之后不单独提供JRE</p><p><strong>编译运行步骤</strong>                                                      字节码                                                     机器码<br>​<img src="/2025/06/02/JAVA%E5%9F%BA%E7%A1%80/image-20220706105817-s13yt87.png" alt="image.png">&#x3D;&#x3D;不同操作系统的机器码不通用，所以中间借用字节码&#x3D;&#x3D;</p><p>‍</p><h1 id="·-类设计"><a href="#·-类设计" class="headerlink" title="· 类设计"></a><strong>· 类设计</strong></h1><p>‍</p><p><strong>成员变量+成员方法+构造器+代码块+内部类</strong></p><p>Java文件定义多个类中只能有一个由public修饰，且该类名必须是文件名</p><p><img src="/2025/06/02/JAVA%E5%9F%BA%E7%A1%80/image-20220709235842-apfpixe.png" alt="image.png"></p><ol><li><h3 id="this的使用"><a href="#this的使用" class="headerlink" title="this的使用"></a><strong>this的使用</strong></h3> this用来在成员方法中访问类域，不同名时无所谓</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span>&#123;<br>    <span class="hljs-type">int</span> x,y;  <span class="hljs-comment">//域</span><br>    Point()<br>    &#123;<br>        x=<span class="hljs-number">0</span>:<br>        y=<span class="hljs-number">0</span>;<span class="hljs-comment">//this.x,this.y也可</span><br>    &#125;<br>    Point(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)<br>    &#123;<br>        <span class="hljs-built_in">this</span>.x=x;<br>        <span class="hljs-built_in">this</span>.y=y;  <span class="hljs-comment">//必须写，不然不能区分参数和类域</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li><h3 id="对象数组"><a href="#对象数组" class="headerlink" title="对象数组"></a><strong>对象数组</strong></h3><p> 数组中元素使用自己创造的对象，而不是常规的INT等变量</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span>&#123;...&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">example</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span><br>    &#123;<br>        <span class="hljs-type">Point</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Point</span>(<span class="hljs-number">10</span>,<span class="hljs-number">11</span>);<br>        <span class="hljs-type">Point</span> <span class="hljs-variable">p2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Point</span>(<span class="hljs-number">20</span>,<span class="hljs-number">21</span>);<br>        <span class="hljs-type">Point</span> <span class="hljs-variable">p3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Point</span>(<span class="hljs-number">30</span>,<span class="hljs-number">31</span>);<br>        <span class="hljs-comment">//初始化的多种方法</span><br>        <span class="hljs-type">Point</span> <span class="hljs-variable">point1</span> <span class="hljs-operator">=</span> &#123;p1,p2,p3,<span class="hljs-keyword">new</span> <span class="hljs-title class_">Point</span>(<span class="hljs-number">40</span>,<span class="hljs-number">41</span>)&#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p> 域中定义变量 static int才能发挥全局作用</p></li><li><h3 id="访问权限-封装Encapsulation"><a href="#访问权限-封装Encapsulation" class="headerlink" title="访问权限 (封装Encapsulation)"></a><strong>访问权限</strong> (封装Encapsulation)</h3><p> Java的封装可以使用保护修饰词，有private, protected, public</p><table><thead><tr><th>访问权限</th><th>本类</th><th>本包的类</th><th>子类</th><th>非子类的外包类</th></tr></thead><tbody><tr><td>public</td><td>是</td><td>是</td><td>是</td><td>是</td></tr><tr><td>protected</td><td>是</td><td>是</td><td>是</td><td>否</td></tr><tr><td>default</td><td>是</td><td>是</td><td>否</td><td>否</td></tr><tr><td>private</td><td>是</td><td>否</td><td>否</td><td>否</td></tr></tbody></table></li><li><h3 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a><strong>类的继承</strong></h3> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">father</span><br>&#123;<br>    <span class="hljs-comment">//无参构造器</span><br>    father()&#123;...&#125;<br>    <span class="hljs-comment">//有参构造器</span><br>    father(a,b,c)&#123;...&#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">son</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">father</span><br>&#123;<br>    son()&#123;...&#125;<br>    son(a,b,c)<br>    &#123;<br>        <span class="hljs-comment">//先初始化父类构造器，不写也是隐式调用无参的，如要有参必须写</span><br>        <span class="hljs-built_in">super</span>();<br>        <span class="hljs-comment">//再构造自己</span><br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br>    <span class="hljs-comment">//子类域</span><br>    <span class="hljs-comment">//子类方法</span><br>&#125;<br>main:<br>    <span class="hljs-type">son</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">son</span>();<br>    <span class="hljs-comment">//先执行父类无参构造器，再执行子类相应(有参或无参构造器)！！</span><br></code></pre></td></tr></table></figure><p> 子类可以继承父类的域和方法，就当作自身定义的一样使用</p><p> 子类可能不适用父类的域或方法，重新定义父类的域称为&#x3D;&#x3D;域的隐藏&#x3D;&#x3D;，重新定义继承自父类的方法称为&#x3D;&#x3D;方法的重写&#x3D;&#x3D;</p><p> <strong>域的隐藏</strong>：在子类域中取域父类域相同名称的变量</p><p> <strong>方法的重写</strong>：在子类方法中写相同名称的函数</p><p> <strong>super关键字</strong><br> 若子类隐藏了父类的域，或重写了父类的方法，但仍想引用这些方法，可通过super关键字访问</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-built_in">super</span>.域<br><span class="hljs-built_in">super</span>.方法([para])<br><span class="hljs-comment">//调用父类的构造方法</span><br><span class="hljs-built_in">super</span>([para])<br></code></pre></td></tr></table></figure><p> <strong>Object类</strong>（类的大爹）<br> 我们创建一个类时，如果没有明确继承一个父类，那么它就会自动继承 Object，成为 Object 的子类。<br> <strong>Object</strong>类中有很多方法可以用以重写，如clone、equals、toString…<br> <a href="https://blog.csdn.net/weixin_43232955/article/details/89705350">https://blog.csdn.net/weixin_43232955&#x2F;article&#x2F;details&#x2F;89705350</a></p><p> 用<strong>final关键字</strong>标记的域或方法不能被重写<br> public static final double PI &#x3D; 3.1415926<br> public final int getA()</p><p>  <strong>@Override注解</strong></p><p> 它标注的方法必须是对父类的重写，若父类没有则报错</p><p> ‍</p></li><li><h3 id="组合类-派生类"><a href="#组合类-派生类" class="headerlink" title="组合类&amp;派生类"></a><strong>组合类&amp;派生类</strong></h3><p> <a href="https://www.cnblogs.com/wft1990/p/5995416.html">https://www.cnblogs.com/wft1990/p/5995416.html</a></p></li><li><h3 id="类的多态"><a href="#类的多态" class="headerlink" title="类的多态"></a><strong>类的多态</strong></h3><p> 多态指的是同一类对象的不同行为，eg.飞机&amp;汽车都属于交通工具类，但运行方式不同</p><p> 多态更强调行为的多态，而不是变量的多态</p><p> <strong>赋值兼容规则</strong></p><p> 类Circle是类Point1的子类，则可以有<code>Point p = new Circle(15,25,10);</code>称p(父类对象)为子类对象的<strong>上转型对象</strong></p><p> &#x3D;&#x3D;多态的优势&#x3D;&#x3D;</p><ol><li><pre><code class="language-java"> Animal a = new Dog() Animal a = new Tiger() //多态使得右边对象可以解耦合，便于扩展和维护 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><br>    ‍<br><span class="hljs-number">2.</span> 定义方法的时候用父类型作为参数，所有子类型都可以传参<br><br>==多态的劣势==<br><br><span class="hljs-number">1.</span> 多态下不能访问子类的独有功能---》**sol.**  **引用数据类型的类型转换**<br><br>==引用数据类型的类型转换==<br><br><span class="hljs-number">1.</span> 自动类型转换（子👉父）<br><span class="hljs-number">2.</span> 强制类型转换（父👉子）<br><br>    ```java<br>    <span class="hljs-type">Animal</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Tiger</span>();<br>    <span class="hljs-comment">//此时不能调用Tiger类独有function</span><br>    <span class="hljs-type">Tiger</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> (Tiger)a;<br>    <span class="hljs-comment">//强制类型转换后可以调用独有功能</span><br>    <span class="hljs-comment">//!下面写法是运行时报错的</span><br>    <span class="hljs-type">Dog</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> (Dog)a;<span class="hljs-comment">//上面new的是Tiger，不能转Dog，异常：ClassCastException</span><br></code></pre></td></tr></table></figure> 因此，JAVA推荐在强转前用**instanceof**判断对象真实类型再进行强转 `if(t instanceof Tiger)&#123;//强转&#125;`</code></pre></li></ol></li></ol><p>‍</p><ol start="7"><li><h3 id="抽象类-方法-接口"><a href="#抽象类-方法-接口" class="headerlink" title="抽象类&#x2F;方法&amp;接口"></a><strong>抽象类&#x2F;方法&amp;接口</strong></h3> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span><span class="hljs-comment">//抽象类</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-type">double</span> <span class="hljs-title function_">area</span><span class="hljs-params">()</span>;<span class="hljs-comment">//抽象方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-type">double</span> <span class="hljs-title function_">perimeter</span><span class="hljs-params">()</span>;<span class="hljs-comment">//抽象方法</span><br>&#125;<br><span class="hljs-comment">//重写抽象类的方法以适应子类特征（必须重写抽象方法）</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Shape</span>&#123;...&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rectangle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Shape</span>&#123;...&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">example</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span>&#123;<br>        Shape aShape;声明抽象类的对象<br>        <span class="hljs-comment">//aShape = new Shape是不被允许的，即实例化抽象类是不允许的</span><br>        aShape = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Circle</span>(<span class="hljs-number">10</span>);<br>        aShape = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Rectangle</span>(<span class="hljs-number">15.2</span>,<span class="hljs-number">10.8</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p> <strong>接口</strong>可看作特殊的抽象类，但interface与class不同，class是对一类事物的描述，而interface可以描述不同类型的事物</p><p> 接口 弥补了单继承的不足</p><p> <strong>接口的域只能是不可重新赋值的常量；接口只能声明方法，不能定义方法</strong></p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Shape</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">double</span> <span class="hljs-variable">PI</span> <span class="hljs-operator">=</span> <span class="hljs-number">3.1415926</span>;<br>    <span class="hljs-comment">//interface中必须100%的抽象类</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-type">double</span> <span class="hljs-title function_">area</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-type">double</span> <span class="hljs-title function_">perimeter</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Shape</span>&#123;<br>    <span class="hljs-comment">//构造函数</span><br>    <span class="hljs-comment">//接口方法实现的函数</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p><strong>如何选择使用抽象类还是接口呢？</strong></p><ol><li>抽象类可以定义类的全部普通成员，接口只能定义常量和抽象方法；</li><li>抽象类只能单继承，接口可以多实现；</li><li>抽象类适合写模板，提高代码的复用性；接口更适合给功能做解耦。</li></ol></li></ul></li></ol><p>‍</p><ol start="8"><li><h3 id="static关键字的使用"><a href="#static关键字的使用" class="headerlink" title="static关键字的使用"></a>static关键字的使用</h3><p> &#x3D;&#x3D;静态成员变量&#x3D;&#x3D;<br> <code>static int a = 0</code>可以用 <code>类名.a</code> 的方式访问</p><p> &#x3D;&#x3D;实例成员变量&#x3D;&#x3D;<br> <code>private int b = 1</code> 只能用实例化后的对象访问，即<code>类名 c = new 类名()；c.b = 1</code></p><p> <img src="/2025/06/02/JAVA%E5%9F%BA%E7%A1%80/image-20220713204009-rqf8907.png" alt="image.png"></p><p> &#x3D;&#x3D;静态成员方法&#x3D;&#x3D;<br> 属于类，<code>public static int get()&#123;...&#125;</code>,共享调用</p><p> &#x3D;&#x3D;实例方法&#x3D;&#x3D;<br> 属于实例，<code>public void get()&#123;...&#125;</code>,实例调用</p></li></ol><p>‍</p><ol start="9"><li><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//用以初始化</span><br>&#123;...&#125;<span class="hljs-comment">//实例代码块</span><br><span class="hljs-keyword">static</span> &#123;...&#125;<span class="hljs-comment">//静态代码块</span><br></code></pre></td></tr></table></figure> 静态代码块会在类加载时执行一次，可将类的初始化操作置于其中</li></ol><p>‍</p><ol start="10"><li><h3 id="内部类（lambda表达式）"><a href="#内部类（lambda表达式）" class="headerlink" title="内部类（lambda表达式）"></a>内部类（lambda表达式）</h3><p> 静态内部类、成员内部类、<strong>匿名内部类</strong></p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//静态内部类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Outer</span>&#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">inner</span>&#123;...&#125;<br>&#125;<br><span class="hljs-comment">//成员内部类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Outer</span>&#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">inner</span>&#123;...&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p> &#x3D;&#x3D;匿名内部类&#x3D;&#x3D;：方便创建子类对象，简化代码的书写  (可以将构造器作为参数直接传入方法)</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Employee</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Employee</span>()&#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">work</span><span class="hljs-params">()</span>&#123;...&#125;<br>&#125;;<br>a.work();<br></code></pre></td></tr></table></figure><p> &#x3D;&#x3D;Lambda表达式&#x3D;&#x3D;：<strong>简化匿名内部类的代码写法</strong>！！<br>                     (只能简化&#x3D;&#x3D;函数式接口&#x3D;&#x3D;的匿名内部类的写法)<br> 函数式接口：接口中只有一个抽象方法的形式  <strong>@FunctionalInterface</strong></p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Lambda的格式</span><br><span class="hljs-comment">//(匿名内部类被重写方法的形参列表) -&gt; &#123;</span><br><span class="hljs-comment">//重写的方法体；</span><br><span class="hljs-comment">//&#125;</span><br><br><span class="hljs-comment">//简化Arrays.sort Comparator接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Lambda</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Integer[] ages = &#123;<span class="hljs-number">34</span>,<span class="hljs-number">12</span>,<span class="hljs-number">42</span>,<span class="hljs-number">23</span>&#125;;<br>        Arrays.sort(ages, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Integer&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Integer o1, Integer o2)</span> &#123;<br>                <span class="hljs-keyword">return</span> o1-o2;<span class="hljs-comment">//升序</span><br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;<br>简化为👇<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Lambda</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Integer[] ages = &#123;<span class="hljs-number">34</span>,<span class="hljs-number">12</span>,<span class="hljs-number">42</span>,<span class="hljs-number">23</span>&#125;;<br>        Arrays.sort(ages, (o1, o2) -&gt; &#123;<br>            <span class="hljs-keyword">return</span> o1-o2;<span class="hljs-comment">//升序</span><br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p> <img src="/2025/06/02/JAVA%E5%9F%BA%E7%A1%80/image-20220723155911-tg5026n.png" alt="image.png"></p><p> ‍</p><p> ‍</p></li><li><h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span>&#123;<br>   sum(<span class="hljs-number">10</span>);<br>   sum(<span class="hljs-number">10</span>,<span class="hljs-number">20</span>)<br>   ...<span class="hljs-comment">//都是合理的</span><br>&#125;<br><span class="hljs-comment">//传入就是一个数组</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> ... sum)</span>&#123;...&#125;<br></code></pre></td></tr></table></figure></li></ol><h1 id="·-核心类库-API"><a href="#·-核心类库-API" class="headerlink" title="· 核心类库(API)"></a>· <strong>核心类库</strong>(API)</h1><ol><li><h3 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h3><p> 使用构造器创建 <code>new String()</code> 👉 堆内存 👉 不同地址</p><p> 使用<code>“str”</code>​创建 👉 常量池 👉 相同地址</p><p> &#x3D;&#x3D;String类API&#x3D;&#x3D;</p><p> <strong>和长度有关的方法</strong><br> 返回类型      方法名               作用<br>  int        length()        得到一个字符串的字符个数（一个中文是一个字符，一个英文是一个字符，一个转义字符是一个字符）</p><p> <strong>和数组有关的方法</strong><br> 返回类型        方法名             作用<br> byte[]        getBytes()       将一个字符串转换成字节数组<br> char[]        toCharArray()    将一个字符串转换成字符数组<br> String[]      split(String)    将一个字符串按照指定内容劈开</p><p> <strong>和判断有关的方法</strong><br> 返回类型        方法名                         作用<br> boolean       equals(String)                判断两个字符串的内容是否一模一样<br> boolean       equalsIgnoreCase(String)      忽略大小写的比较两个字符串的内容是否一模一样<br> boolean       contains(String)              判断一个字符串里面是否包含指定的内容<br> boolean       startsWith(String)            判断一个字符串是否以指定的内容开头<br> boolean       endsWith(String)              判断一个字符串是否以指定的内容结尾</p><p> <strong>和改变内容有关的方法</strong><br>  <strong>和改变内容有关的方法，都不会直接操作原本的字符串<br> 而是将符合条件的字符串返回给我们，所以注意接收</strong><br> 返回类型        方法名                         作用<br> String        toUpperCase()                 将一个字符串全部转换成大写<br> String        toLowerCase()                 将一个字符串全部转换成小写<br> String        replace(String,String)        将某个内容全部替换成指定内容<br> String        replaceAll(String,String)     将某个内容全部替换成指定内容，支持正则<br> String        repalceFirst(String,String)   将第一次出现的某个内容替换成指定的内容<br> String        substring(int)                从指定下标开始一直截取到字符串的最后<br> String        substring(int,int)            从下标x截取到下标y-1对应的元素<br> String        trim()                        去除一个字符串的前后空格</p><p> <strong>和位置有关的方法</strong><br> 返回类型        方法名                     作用<br> char          charAt(int)               得到指定下标位置对应的字符<br> int           indexOf(String)           得到指定内容第一次出现的下标<br> int           lastIndexOf(String)       得到指定内容最后一次出现的下标</p></li><li><h3 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h3><ol><li><p><strong>toString</strong>​ <strong>()</strong></p><p> 返回当前对象的地址<br> 需要自己重写方法来实现具体功能</p></li><li><p><strong>equals()</strong></p><p> 判断对象是否相等(基本类型&amp;String-compare value；引用类型-compare LOC)，instanceof&#x2F;强转等</p><p> 重写后一般连着<code>hashcode()</code>一块重写，因为equals不再具有’&#x3D;&#x3D;’的从地址判断的功能，而两个对象hashcode相同<br> 对象并不一定相同(也就是hashcode相同，equals的结果可能仍不同)</p></li></ol></li><li><h3 id="Objects类"><a href="#Objects类" class="headerlink" title="Objects类"></a>Objects类</h3><p> 继承于Object类，<code>Objects.equals(a,b)</code>写法更安全（null不报错）</p></li><li><h3 id="StringBuilder-StringBuffer类"><a href="#StringBuilder-StringBuffer类" class="headerlink" title="StringBuilder&amp;&amp;StringBuffer类"></a>StringBuilder&amp;&amp;StringBuffer类</h3><p> 可变string类，可看作对象容器，好处就是不用创建新的string对象</p><p> <code>StringBuilder a = new StringBuilder()</code>,append()、reverse()、length()</p><ol><li><h4 id="字符修改上的区别"><a href="#字符修改上的区别" class="headerlink" title="字符修改上的区别"></a>字符修改上的区别</h4><p> StringBuilder的<strong>修改效率高</strong>，但<strong>非线程安全</strong>（不能同步访问）；StringBuffer恰恰相反</p></li><li><h4 id="继承结构"><a href="#继承结构" class="headerlink" title="继承结构"></a>继承结构</h4><p> <img src="/2025/06/02/JAVA%E5%9F%BA%E7%A1%80/image-20220731160921-nvebuyu.png" alt="image.png"></p></li><li><h4 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h4><p> StringBuffer 每次获取 toString 都会直接使用缓存区的 toStringCache 值来构造一个字符串。</p><p> 而 StringBuilder 则每次都需要复制一次字符数组，再构造一个字符串。</p></li></ol></li><li><h3 id="Math类"><a href="#Math类" class="headerlink" title="Math类"></a>Math类</h3><p> <strong>都是静态方法，可以通过类名直接调用</strong></p><p> <img src="/2025/06/02/JAVA%E5%9F%BA%E7%A1%80/image-20220720100427-v0oqzuh.png" alt="image.png"></p></li><li><h3 id="System类"><a href="#System类" class="headerlink" title="System类"></a>System类</h3><p> <img src="/2025/06/02/JAVA%E5%9F%BA%E7%A1%80/image-20220720101631-8ykfzxj.png" alt="image.png"></p></li><li><h3 id="BigDecimal类（大数据类型）"><a href="#BigDecimal类（大数据类型）" class="headerlink" title="BigDecimal类（大数据类型）"></a>BigDecimal类（大数据类型）</h3><p> 解决浮点型运算精度失真</p><p> 调用  <strong>.valueof()</strong> 方法获取BD对象</p></li><li><h3 id="日期类"><a href="#日期类" class="headerlink" title="日期类"></a>日期类</h3><ol><li><p><strong>Date类</strong></p><p> 时间毫秒值可以用来方便计算日期对象<br> <code>System.currentTimeMills()</code>获取系统<strong>时间毫秒值</strong><br> <code>Date d = new Date(时间毫秒值对象)</code>or<code>d.setTime(时间毫秒值对象)</code>可以将<strong>时间毫秒值转为日期对象</strong></p><p> <img src="/2025/06/02/JAVA%E5%9F%BA%E7%A1%80/image-20220721101716-haizfcz.png" alt="image.png"></p></li><li><p><strong>SimpleDateFormat类</strong></p><p> <u>Date对象</u>或<u>时间毫秒值</u>​<strong>格式化</strong>为<code>年月日时间</code>的时间形式</p><p> <img src="/2025/06/02/JAVA%E5%9F%BA%E7%A1%80/image-20220720105025-25cea3l.png" alt="image.png"><br> 字符串时间形式<strong>解析</strong>成日期对象<br> <code>public Date parse(String source)</code></p><p> <a href="https://blog.csdn.net/qq_26817225/article/details/93593989">https://blog.csdn.net/qq_26817225&#x2F;article&#x2F;details&#x2F;93593989</a> 对于年代标识符的使用</p></li><li><p><strong>Calendar类</strong>（抽象类，不能直接创建对象）</p><p> <img src="/2025/06/02/JAVA%E5%9F%BA%E7%A1%80/image-20220720121209-6m6cwib.png" alt="image.png"></p></li><li><p><strong>JDK8的新增日期API</strong></p><p> <img src="/2025/06/02/JAVA%E5%9F%BA%E7%A1%80/image-20220721115721-mngpsif.png" alt="image.png"></p><p> &#x3D;&#x3D;LocalDate、LocalTime、LocalDateTime&#x3D;&#x3D;：<code>of()</code>设定时间，<code>now()</code>获取当前时间…</p><p> &#x3D;&#x3D;Instant&#x3D;&#x3D;： 时间戳，类似<code>System.currentTimeMillis()</code><br>           <code>.now()</code>方法默认获取世界标准时间，不是东八区时间<br>           Date与Instant对象互转，<code>Date.from(Instant)</code>,<code>Date.toInstant()</code><br> &#x3D;&#x3D;DateTimeFormatter&#x3D;&#x3D;：</p><p> <strong>格式化format：</strong><br> ​<img src="/2025/06/02/JAVA%E5%9F%BA%E7%A1%80/image-20220721151606-e83l1ev.png" alt="image.png"></p><p> <strong>解析parse：</strong><br> ​<img src="/2025/06/02/JAVA%E5%9F%BA%E7%A1%80/image-20220721152132-bl3cg9n.png" alt="image.png"></p><p> &#x3D;&#x3D;Duration || Period&#x3D;&#x3D;：计算时间跨度</p><p> <strong>Period对应日期操作,Duration对应时间操作</strong></p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Period</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> Period.between(a,b)<span class="hljs-comment">//a,b都是LocalDate对象，默认用b-a</span><br><span class="hljs-comment">//Duration用于更精细的操作</span><br><span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">today</span> <span class="hljs-operator">=</span> LocalDateTime.now();<br><span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">birth</span> <span class="hljs-operator">=</span> LocalDateTime.of(<span class="hljs-number">2001</span>,<span class="hljs-number">11</span>,<span class="hljs-number">25</span>,<span class="hljs-number">0</span>,<span class="hljs-number">5</span>,<span class="hljs-number">0</span>);<br><span class="hljs-type">Duration</span> <span class="hljs-variable">duration</span> <span class="hljs-operator">=</span> Duration.between(birth,today);<br></code></pre></td></tr></table></figure><p> &#x3D;&#x3D;可以用ChronoUnit简化&#x3D;&#x3D;</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">today</span> <span class="hljs-operator">=</span> LocalDateTime.now();<br><span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">birth</span> <span class="hljs-operator">=</span> LocalDateTime.of(<span class="hljs-number">2001</span>,<span class="hljs-number">11</span>,<span class="hljs-number">25</span>,<span class="hljs-number">0</span>,<span class="hljs-number">5</span>,<span class="hljs-number">0</span>);<br>ChronoUnit.YEARS.between(birth,today).sout;<br></code></pre></td></tr></table></figure></li></ol></li><li><h3 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h3><p> <img src="/2025/06/02/JAVA%E5%9F%BA%E7%A1%80/image-20220721155922-3m1wuvz.png" alt="image.png"><img src="/2025/06/02/JAVA%E5%9F%BA%E7%A1%80/image-20220721160346-dxvlw2i.png" alt="image.png"></p><p> &#x3D;&#x3D;Parsexxx可以用valueOf替代&#x3D;&#x3D;</p></li><li><h3 id="Arrays类"><a href="#Arrays类" class="headerlink" title="Arrays类"></a>Arrays类</h3><p> 对所有数组类型可以操作</p><p> toString、sort、binarySearch等</p><p> Comparater接口用来&#x3D;&#x3D;制定比较器规则&#x3D;&#x3D;（当sort对象为<u>自定义类对象</u>时非常好用）</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">Array.sort(array, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparater</span>&lt;Student&gt;()&#123;<br>   <span class="hljs-meta">@override</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Student o1, Student o2)</span>&#123;<br>       <span class="hljs-comment">//制定比较规则</span><br>       <span class="hljs-keyword">return</span> o2.getAge()-o1.getAge();<span class="hljs-comment">//年龄降序排序</span><br>   &#125;<br>&#125;)<br></code></pre></td></tr></table></figure></li><li><h3 id="Java集合-Collection-框架-​-、Map框架"><a href="#Java集合-Collection-框架-​-、Map框架" class="headerlink" title="&#x3D;&#x3D;Java集合(Collection)框架&#x3D;&#x3D;​&#x3D;&#x3D;、Map框架&#x3D;&#x3D;"></a>&#x3D;&#x3D;Java集合(Collection)框架&#x3D;&#x3D;​&#x3D;&#x3D;、Map框架&#x3D;&#x3D;</h3><p> <img src="/2025/06/02/JAVA%E5%9F%BA%E7%A1%80/image-20220710170132-y8mpebm.png" alt="image.png"></p><p> <img src="/2025/06/02/JAVA%E5%9F%BA%E7%A1%80/image-20220710170144-0rny6m1.png" alt="image.png">&#x3D;&#x3D;框架统一于util包内&#x3D;&#x3D;</p><p> <strong>Collection集合的遍历</strong>：迭代器Iterator，foreach，lambda表达式(Collection不支持索引)</p><p> ‍</p><p> List集合：查询快，线性表（有序，有索引，可重复）<br> Set集合：增删改查都快，不重复集合<br> Map集合：键值对<br> Queue集合：队列</p><p> <img src="/2025/06/02/JAVA%E5%9F%BA%E7%A1%80/image-20220802155852-f8erj8f.png" alt="image.png"></p><p> <strong>Collection特点</strong>：集合大小不固定，可以动态变化，类型也可以不固定（对基本数据类型的引用只能用<strong>包装类</strong>），非常适合做增删操作</p><ol><li><h4 id="List集合"><a href="#List集合" class="headerlink" title="List集合"></a>List集合</h4><p> ArrayList列表、LinkedList链表<br> <strong>Vecto****r</strong>与ArrayList原理相同，但使用了synchronized方法保证线程安全，因此性能略差<br> <strong>Stack</strong>继承自Vector，拓展了push、pop、peek(取堆栈顶点)、empty、search操作以实现后进先出的堆栈结构</p><p> &#x3D;&#x3D;ArrayList构造方法&#x3D;&#x3D;</p><table><thead><tr><th>方法名</th><th>方法功能</th></tr></thead><tbody><tr><td>ArrayList()</td><td>构造一个初始容量10的空列表</td></tr><tr><td>ArrayList(Collection c)</td><td>构造一个包含指定collection的元素的列表</td></tr><tr><td>ArrayList(int capacity)</td><td>构造一个指定初始容量的空列表</td></tr></tbody></table><p> ‍</p><table><thead><tr><th>List接口常用方法（Arraylist同用）</th></tr></thead><tbody><tr><td><strong>void add(int index, Object obj)</strong> <br />Inserts obj 插入到调用列表中的索引通过索引处。达到或超出插入点任何预先存在的要素被上移。因此，不会有元素被覆盖。</td></tr><tr><td><strong>boolean addAll(int index, Collection c)</strong> <br />插入c的所有元素入索引通过索引处的调用列表。等于或超出插入点任何预先存在的要素被上移。因此，没有任何元素被覆盖。如果调用列表更改并返回true，否则返回false。</td></tr><tr><td><strong>Object get(int index)</strong> <br />返回存储调用集合中指定索引处的对象。</td></tr><tr><td><strong>int indexOf(Object obj)</strong> <br />返回调用列表obj的第一个实例的索引。如果obj不是列表中的一个元素，则返回-1。</td></tr><tr><td><strong>int lastIndexOf(Object obj)</strong> <br />返回调用列表obj的最后一个实例的索引。如果obj不是列表中的一个元素，则返回-1。</td></tr><tr><td><strong>ListIterator listIterator( )</strong> <br />返回一个迭代器调用列表的开始。</td></tr><tr><td><strong>List Iterator list Iterator(int index)</strong> <br />返回一个迭代器调用列表开头的在指定索引处。</td></tr><tr><td><strong>Object remove(int index)</strong> <br />从调用列表删除index位置的元素，并返回被删除的元素。结果列表中被压缩。也就是说，随后的元素的索引减一。</td></tr><tr><td><strong>Object set(int index, Object obj)</strong> <br />赋予obj转换通过索引调用列表中指定的位置。</td></tr><tr><td><strong>List subList(int start, int end)</strong> <br />返回一个列表，其中包括在调用列表，从开始元素end-1。在返回列表中的元素也被调用对象的引用。</td></tr></tbody></table></li><li><h4 id="泛型深入"><a href="#泛型深入" class="headerlink" title="泛型深入"></a>泛型深入</h4><ol><li><p><strong>泛型类</strong></p><p> <code>public class myClass&lt;E&gt;&#123;...&#125;</code>→创建类对象时<code>myClass&lt;包装类&gt; list = new myClass&lt;&gt;()</code>，<strong>限定对象的成员类型</strong></p></li><li><p><strong>泛型方法</strong></p><p> <code>public &lt;T&gt; void show(T t)</code>,<strong>使用泛型接受一切类型的参数，更具有通用性</strong></p></li><li><p><strong>泛型接口</strong></p><p> <code>public interface Data&lt;E&gt;&#123;...&#125;</code>，<strong>让实现类选择当前功能需要的数据类型</strong></p></li><li><p><strong>泛型通配符、上下限</strong></p><p> <code>？</code>在 <u>使用泛型</u> 的时候代表一切类型（ETKV是在定义泛型使用的）</p><p> <img src="/2025/06/02/JAVA%E5%9F%BA%E7%A1%80/image-20220731105938-tnp12jm.png" alt="image.png"></p></li></ol></li><li><h4 id="Set集合"><a href="#Set集合" class="headerlink" title="Set集合"></a>Set集合</h4><p> <img src="/2025/06/02/JAVA%E5%9F%BA%E7%A1%80/image-20220731164725-2y2ej48.png" alt="image.png"></p><ol><li><p><strong>HashSet</strong></p><ul><li><p><strong>无序的底层原理</strong>：哈希表（数组+链表+红黑树）</p><p>哈希值：根据对象地址，按某种规则计算得到的int数值，可以直接用Object类下的<code>public int hashCode()</code>获取</p><p><img src="/2025/06/02/JAVA%E5%9F%BA%E7%A1%80/image-20220801115235-ipy2rbo.png" alt="image.png"></p><p><u>Step4的equals()方法和hashCode()方法需要重写</u></p><p><u>JDK8以后，如果链表长度超过8，会自动转为红黑树</u></p><p><img src="/2025/06/02/JAVA%E5%9F%BA%E7%A1%80/image-20220801115648-sbn7zzf.png" alt="image.png"></p><p><img src="/2025/06/02/JAVA%E5%9F%BA%E7%A1%80/image-20220801115933-m4y6xjf.png" alt="image.png"></p></li><li><p><strong>去重的底层原理</strong>：先判断Hash值，再判断equals()，<u>Override Object类中的hashCode和equals才能正确去重</u></p></li></ul></li><li><p><strong>LinkedHashSet</strong></p><p> <img src="/2025/06/02/JAVA%E5%9F%BA%E7%A1%80/image-20220801140514-yckzx4d.png" alt="image.png"></p><p> ‍</p></li><li><p><strong>TreeSet</strong></p><p> <img src="/2025/06/02/JAVA%E5%9F%BA%E7%A1%80/image-20220802153814-iavkcf3.png" alt="image.png"></p><p> 包装类按照大小、首字符编号等排序，<u>自定义对象需要自定义排序规则</u>  👇</p><p> <img src="/2025/06/02/JAVA%E5%9F%BA%E7%A1%80/image-20220802154703-m6a8jg2.png" alt="image.png"><img src="/2025/06/02/JAVA%E5%9F%BA%E7%A1%80/image-20220802154937-t9ekqny.png" alt="image.png"></p><p> 浮点型比较直接用<code>Double.compare()</code></p></li></ol></li><li><h4 id="Map集合"><a href="#Map集合" class="headerlink" title="&#x3D;&#x3D;Map集合&#x3D;&#x3D;"></a>&#x3D;&#x3D;Map集合&#x3D;&#x3D;</h4><p> 键值对集合（双列集合），每个元素有key，value俩值{key1&#x3D;value1，key2&#x3D;value2，…}</p><p> 特点：<strong>HashMap、TreeMap、LinkedHashMap</strong>作为重点，key无序不重复（后覆盖前），value可以有多个key。  </p><ul><li>HashMap：无序、不重复、无索引</li><li>LinkedHashMap：有序、不重复、无索引</li></ul><p> <strong>常用API</strong>：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">map.put(<span class="hljs-string">&quot;key_1&quot;</span>,<span class="hljs-number">1</span>);               <span class="hljs-comment">// 添加键值对,已有 key 则覆盖 value</span><br>map.putIfAbsent(<span class="hljs-string">&quot;key_2&quot;</span>,<span class="hljs-number">2</span>);       <span class="hljs-comment">// 添加键值对,已有 key 则不操作</span><br><br>map.remove(<span class="hljs-string">&quot;key_1&quot;</span>);              <span class="hljs-comment">// 删除键值对（按值）           </span><br>map.remove(<span class="hljs-string">&quot;key_2&quot;</span>,<span class="hljs-number">2</span>);            <span class="hljs-comment">// 删除键值对（按键值）</span><br><br>map.get(<span class="hljs-string">&quot;key_1&quot;</span>);                 <span class="hljs-comment">// 获取值, key 不存在返回null</span><br>map.getOrDefault(<span class="hljs-string">&quot;key_2&quot;</span>,-<span class="hljs-number">1</span>);     <span class="hljs-comment">// 获取值, key 不存在返回默认值</span><br><br>map.containsKey(<span class="hljs-string">&quot;key_1&quot;</span>);         <span class="hljs-comment">// 判断 key 是否存在  </span><br>map.containsValue(<span class="hljs-number">1</span>);             <span class="hljs-comment">// 判断 value 是否存在      </span><br><br>map.keySet();<br>map.values();<br></code></pre></td></tr></table></figure><p> &#x3D;&#x3D;遍历的3种方式&#x3D;&#x3D;</p><ul><li><p><strong>键找值</strong></p><p>Step1. 拿keySet集合<br>Step2. 遍历每个键，用键提取值，<code>value = maps.get(key)</code></p></li><li><p><strong>键值对</strong></p><p>Step1. 将Map转化为Set集合，使用Map的实体类型<code>Set&lt;Map.Entry&lt;String,Integer&gt;&gt; entries = maps.entrySet();</code><br>Step2. foreach遍历<code> for(Map.Entry&lt;String,Integer&gt; entry : entries)&#123;entry.getKey / entry.getValue&#125;</code></p></li><li><p><strong>Lambda</strong></p><p>利用Map中的 <code>forEach(BiConsumer&lt;? super K,? super V&gt; action)</code> 方法<br>实现：<code>maps.foreach((k,v) -&gt;&#123;...&#125;)</code></p></li></ul><ol><li><p><strong>HashMap</strong></p><p> <img src="/2025/06/02/JAVA%E5%9F%BA%E7%A1%80/image-20220806164524-ekumbs3.png" alt="image.png"></p></li><li><p><strong>TreeMap</strong></p><p> <img src="/2025/06/02/JAVA%E5%9F%BA%E7%A1%80/image-20220806164828-szdvexz.png" alt="image.png"></p></li><li><p><strong>LinkedHashMap</strong></p><p> <img src="/2025/06/02/JAVA%E5%9F%BA%E7%A1%80/image-20220806164718-0f5mfwq.png" alt="image.png"></p></li></ol></li></ol></li><li><h3 id="补充：集合工具类Collections"><a href="#补充：集合工具类Collections" class="headerlink" title="补充：集合工具类Collections"></a>补充：集合工具类Collections</h3><p> 不属于Collection家族，是一个辅助工具，具体参照API文档，addAll、shuffle、sort等</p><p> <img src="/2025/06/02/JAVA%E5%9F%BA%E7%A1%80/image-20220802161516-3vs7mbp.png" alt="image.png"><img src="/2025/06/02/JAVA%E5%9F%BA%E7%A1%80/image-20220802161653-ize6dfk.png" alt="image.png"></p></li><li><h3 id="补充：集合的嵌套"><a href="#补充：集合的嵌套" class="headerlink" title="补充：集合的嵌套"></a>补充：集合的嵌套</h3><p> <img src="/2025/06/02/JAVA%E5%9F%BA%E7%A1%80/image-20220806171516-grgj1sf.png" alt="image.png"></p></li></ol><p>‍</p><p>‍</p><h1 id="·-正则表达式"><a href="#·-正则表达式" class="headerlink" title="· 正则表达式"></a><strong>· 正则表达式</strong></h1><p> **用规定的字符制定规则，用来校验数据格式的合法性**</p><pre><code class="hljs">==API文档regex.pattern==  ![image.png](image-20220722173410-36y2pfy.png)String的一些方法（如split、replace）都可以使用正则表达式传参==正则表达式爬取信息==</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RegularExpression</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;电影名称：《我和我的祖国》，票价：43元，联系电话：400-100-3233，邮箱地址：xyf@scnu.com&quot;</span> +<br>                <span class="hljs-string">&quot;电影名称：《闯江湖》，票价：63元，联系电话：400-100-2020，邮箱地址：xyf@126.com.cn&quot;</span>;<br>        <span class="hljs-comment">//爬取规则</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">regex</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;(《\\W&#123;1,10&#125;》)|(\\d+元)|(400-?\\d&#123;3,9&#125;-\\d&#123;3,9&#125;)|(\\w&#123;1,30&#125;@[a-zA-Z0-9]&#123;2,20&#125;(\\.[a-zA-Z0-9]&#123;2,20&#125;)&#123;1,2&#125;)&quot;</span>;<br>        <span class="hljs-comment">//爬取规则编译为匹配对象</span><br>        <span class="hljs-type">Pattern</span> <span class="hljs-variable">pattern</span> <span class="hljs-operator">=</span> Pattern.compile(regex);<br>        <span class="hljs-comment">//得到一个内容匹配器对象</span><br>        <span class="hljs-type">Matcher</span> <span class="hljs-variable">matcher</span> <span class="hljs-operator">=</span> pattern.matcher(rs);<br>        <span class="hljs-comment">//开始爬取</span><br>        <span class="hljs-keyword">while</span> (matcher.find())&#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">rs1</span> <span class="hljs-operator">=</span> matcher.group();<br>            System.out.println(rs1);<br>        &#125;<br>    &#125;<br>&#125;<br>    OUT&#123;<br>        《我和我的祖国》<br>        <span class="hljs-number">43</span>元<br>        <span class="hljs-number">400</span>-<span class="hljs-number">100</span>-<span class="hljs-number">3233</span><br>        xyf<span class="hljs-meta">@scnu</span>.com<br>        《闯江湖》<br>        <span class="hljs-number">63</span>元<br>        <span class="hljs-number">400</span>-<span class="hljs-number">100</span>-<span class="hljs-number">2020</span><br>        xyf@<span class="hljs-number">126.</span>com.cn<br>    &#125;<br></code></pre></td></tr></table></figure><h1 id="·-Stream流体系"><a href="#·-Stream流体系" class="headerlink" title="· Stream流体系"></a>· <strong>Stream流体系</strong></h1><ol><li><h3 id="不可变集合（list，set，map）"><a href="#不可变集合（list，set，map）" class="headerlink" title="不可变集合（list，set，map）"></a>不可变集合（list，set，map）</h3><p> <code>List&lt;T&gt; lists = list.of(...)</code>不允许<code>add，set</code>操作</p></li><li><h3 id="Stream流"><a href="#Stream流" class="headerlink" title="Stream流"></a>Stream流</h3><p> <strong>目的：结合Lambda表达式，简化集合和数组操作的API</strong>（不会影响原集合结构（无增删改））</p><p> <img src="/2025/06/02/JAVA%E5%9F%BA%E7%A1%80/image-20220807173135-7qmk6i4.png" alt="image.png"><img src="/2025/06/02/JAVA%E5%9F%BA%E7%A1%80/image-20220807173231-qurlsxs.png" alt="image.png"></p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Map集合获取流</span><br>Map&lt;String, Integer&gt; maps = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><span class="hljs-comment">//key stream</span><br>Stream&lt;String&gt; a = maps.KeySet().stream();<br><span class="hljs-comment">//value stream</span><br>Stream&lt;String&gt; b = maps.values().stream();<br><span class="hljs-comment">//key-value steam</span><br>Stream&lt;Maps.Entry&lt;String,Integer&gt;&gt; c = maps.entrySet().stream();<br><br><span class="hljs-comment">//数组获取流</span><br>Arrays.stream()<br><span class="hljs-comment">//或者</span><br>Stream&lt;String&gt; a = Stream.of() <br></code></pre></td></tr></table></figure><h4 id="Stream流的常用API"><a href="#Stream流的常用API" class="headerlink" title="Stream流的常用API"></a>Stream流的常用API</h4><table><thead><tr><th align="center">方法名称</th><th align="center">方法作用</th><th align="center">方法种类</th><th align="center">是否支持链式调用</th></tr></thead><tbody><tr><td align="center">count</td><td align="center">统计个数</td><td align="center">终结方法</td><td align="center">否</td></tr><tr><td align="center">forEach</td><td align="center">逐一处理</td><td align="center">终结方法</td><td align="center">否</td></tr><tr><td align="center">filter</td><td align="center">过滤</td><td align="center">函数拼接</td><td align="center">是</td></tr><tr><td align="center">limit</td><td align="center">取用前几个</td><td align="center">函数拼接</td><td align="center">是</td></tr><tr><td align="center">skip</td><td align="center">跳过前几个</td><td align="center">函数拼接</td><td align="center">是</td></tr><tr><td align="center">map</td><td align="center">映射</td><td align="center">函数拼接</td><td align="center">是</td></tr><tr><td align="center">concat</td><td align="center">组合</td><td align="center">函数拼接</td><td align="center">是</td></tr></tbody></table><p> 注：<u>终结方法</u>：返回值类型不再是Stream接口本身类型的方法<br>    <u>非终结方法&#x2F;延迟方法</u>：返回值类型仍然是Stream接口自身类型的方法，除了终结方法都是延迟方法。</p><h4 id="Stream流-to-Collection"><a href="#Stream流-to-Collection" class="headerlink" title="Stream流 to Collection"></a>Stream流 to Collection</h4> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>list2.add(<span class="hljs-string">&quot;张老三&quot;</span>);<br>list2.add(<span class="hljs-string">&quot;张小三&quot;</span>);<br>list2.add(<span class="hljs-string">&quot;李四&quot;</span>);<br>list2.add(<span class="hljs-string">&quot;赵五&quot;</span>);<br>list2.add(<span class="hljs-string">&quot;张六&quot;</span>);<br>list2.add(<span class="hljs-string">&quot;王八&quot;</span>);<br>     <br><span class="hljs-comment">// 需求：过滤出姓张的并且长度为3的元素</span><br>Stream&lt;String&gt; stream = list2.stream().filter(name -&gt; name.startsWith(<span class="hljs-string">&quot;张&quot;</span>)).filter(name -&gt; name.length() == <span class="hljs-number">3</span>);<br>     <br><span class="hljs-comment">// stream 收集到单列集合中</span><br>List&lt;String&gt; list = stream.collect(Collectors.toList());<br>System.out.println(list);<br>     <br><span class="hljs-comment">// stream 收集到单列集合中</span><br>Set&lt;String&gt; set = stream.collect(Collectors.toSet());<br>System.out.println(set);<br></code></pre></td></tr></table></figure></li></ol><h1 id="·-异常处理"><a href="#·-异常处理" class="headerlink" title="· 异常处理"></a><strong>· 异常处</strong>理</h1><p><img src="/2025/06/02/JAVA%E5%9F%BA%E7%A1%80/image-20220809103437-xbqysho.png" alt="image.png">​</p><p>​<code>Error</code>​异常是系统级别的严重错误，是不可操作的；<code>Exception</code>​异常分为运行时异常<code>RuntimeException</code>​和编译时异常<code>other</code>​</p><ol><li><h3 id="异常处理方式"><a href="#异常处理方式" class="headerlink" title="异常处理方式"></a>异常处理方式</h3><ul><li><p><strong>throws</strong> ：<code>function throws Exceptions&#123;...&#125;</code></p></li><li><p><strong>try catch</strong> :</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span>&#123;<br>  <span class="hljs-comment">//需要监视的代码段</span><br>&#125;<span class="hljs-keyword">catch</span>(异常类型<span class="hljs-number">1</span> e)&#123;<br>  <span class="hljs-comment">//处理方式</span><br>  e.printStackTrace();<br>&#125;<span class="hljs-keyword">catch</span>(异常类型<span class="hljs-number">2</span> e)&#123;<br>  <span class="hljs-comment">//处理方式</span><br>&#125;<br><span class="hljs-comment">//企业级写法</span><br><span class="hljs-keyword">catch</span>(Exception e)&#123;<br>  e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>调用者决定</strong> ：function将exception throw给上层调用者，上层调用者再做try catch决定如何处理</p></li></ul><p> RuntimeException可以在最外层try catch</p></li><li><h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><ol><li><h4 id="自定义编译时异常"><a href="#自定义编译时异常" class="headerlink" title="自定义编译时异常"></a>自定义编译时异常</h4><p> 定义一个异常类继承Exception -&gt; 重写构造器 -&gt; 出现异常的地方用<code>throw new</code>抛出</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//出现异常的地方用`throw new`抛出</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String arg[])</span>&#123;<br>    <span class="hljs-keyword">try</span>&#123;checkAge(-<span class="hljs-number">23</span>)&#125;<br>    <span class="hljs-keyword">catch</span>(xyfAgeIllegalException e)&#123;e.printStackTrace();&#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">checkAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> <span class="hljs-keyword">throws</span> xyfAgeIllegalException&#123;<br>    <span class="hljs-keyword">if</span> (age&lt;<span class="hljs-number">0</span>||age&gt;<span class="hljs-number">200</span>)&#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">xyfAgeIllegalException</span>(age + <span class="hljs-string">&quot;is illegal!&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        sout(<span class="hljs-string">&quot;年龄合法！&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//重写构造器</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">xyfAgeIllegalException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Exception</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">xyfAgeIllegalException</span><span class="hljs-params">()</span>&#123;&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">xyfAgeIllegalException</span><span class="hljs-params">(String message)</span>&#123;<span class="hljs-built_in">super</span>(message);&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><h4 id="自定义运行时异常"><a href="#自定义运行时异常" class="headerlink" title="自定义运行时异常"></a>自定义运行时异常</h4><p> 定义一个异常类继承RuntimeException -&gt; 重写构造器 -&gt; 出现异常的地方用<code>throw new</code>抛出</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//出现异常的地方用`throw new`抛出</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String arg[])</span>&#123;<br>    <span class="hljs-keyword">try</span>&#123;checkAge(-<span class="hljs-number">23</span>)&#125;<br>    <span class="hljs-keyword">catch</span>(xyfAgeIllegalRuntimeException e)&#123;e.printStackTrace();&#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">checkAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> <span class="hljs-keyword">throws</span> xyfAgeIllegalRuntimeException&#123;<br>    <span class="hljs-keyword">if</span> (age&lt;<span class="hljs-number">0</span>||age&gt;<span class="hljs-number">200</span>)&#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">xyfAgeIllegalRuntimeException</span>(age + <span class="hljs-string">&quot;is illegal!&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        sout(<span class="hljs-string">&quot;年龄合法！&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//重写构造器</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">xyfAgeIllegalRuntimeException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RuntimeException</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">xyfAgeIllegalException</span><span class="hljs-params">()</span>&#123;&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">xyfAgeIllegalException</span><span class="hljs-params">(String message)</span>&#123;<span class="hljs-built_in">super</span>(message);&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li></ol><h1 id="·-日志技术"><a href="#·-日志技术" class="headerlink" title="· 日志技术"></a><strong>· 日志技术</strong></h1><p><strong>Advantage：</strong> 可以将日志信息写入文件或数据库 + 不需修改代码，灵活性好 + 多线程性能较好</p><ol><li><h3 id="Logback框架"><a href="#Logback框架" class="headerlink" title="Logback框架"></a>Logback框架</h3><ul><li><p><strong>三个技术模块</strong><br>logback-core：为其他俩模块奠定基础<br>logback-classic：Log4j的改良版本，且完整实现了<u>slf4j的API</u>（日志规范）<br>logback-access：与Tomcat &amp;&amp; Jetty等Servlet容器集成，以提供HTTP访问日志功能</p></li><li><p><strong>Logback入门</strong></p><p>S1. 导入jar包（logback-classic.jar, logback-core.jar, slf4j-api.jar），至新建的lib文件夹下<br>S2. logback.xml拷贝到src目录下<br>S3. 代码中获取日志的对象<code>public static final logger LOGGER = LoggerFactory.getLogger(&quot;类对象&quot;);</code><br>S4. 使用日志对象输出日志</p></li><li><p><strong>Logback配置</strong></p><p>通过 <u>logback.xml</u> 配置，可以设置<u>日志输出位置和格式</u></p><p>&#x3D;&#x3D;日志输出位置和格式设置&#x3D;&#x3D;<br><appender>可以设置输出位置(CONSOLE or FILE)和日志信息的详细格式</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;CONSOLE&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;...&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">target</span>&gt;</span>System.out<span class="hljs-tag">&lt;/<span class="hljs-name">target</span>&gt;</span> <span class="hljs-comment">&lt;!--.err打红色 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">encoder</span>&gt;</span><br>      <span class="hljs-comment">&lt;!--format输出。%d-日期 %thread-线程名 %-5level-level从左显示5个字符宽度 %msg-日志消息--&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%-5level] %c[%thread] : %msg%n<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">charset</span>&gt;</span>utf-8<span class="hljs-tag">&lt;/<span class="hljs-name">charset</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--输出路径--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">file</span>&gt;</span>C:/code/code1.log<span class="hljs-tag">&lt;/<span class="hljs-name">file</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">rollingPolicy</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;...&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">fileNamePattern</span>&gt;</span>C:/code/code-%d&#123;yyyy-MMdd&#125;.log%i.gz<span class="hljs-tag">&lt;/<span class="hljs-name">fileNamePattern</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">maxFileSize</span>&gt;</span>1MB<span class="hljs-tag">&lt;/<span class="hljs-name">maxFileSize</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">rollingPolicy</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span><br><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">&lt;root&gt; -&gt; &lt;appender-ref&gt;不配置就不记录</span><br><span class="hljs-comment">level用来设置打印级别，有TRACE,DEBUG,INFO,WARN,ERROR,ALL,OFF,default is debug</span><br><span class="hljs-comment">--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">root</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;ALL&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;CONSOLE&quot;</span> /&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;FILE&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span><br></code></pre></td></tr></table></figure><p>&#x3D;&#x3D;日志级别设置&#x3D;&#x3D;</p><p>日志级别有 TRACE&lt;DEBUG&lt;INFO&lt;WARN&lt;ERROR ,ALL,OFF，默认是debug，只输出级别高于设置级别的信息</p></li></ul></li></ol><h1 id="·-IO文件操作"><a href="#·-IO文件操作" class="headerlink" title="· IO文件操作"></a><strong>· IO文件操作</strong></h1><p><strong>File类</strong>可以定位和操作文件，但不能读写文件内容，<strong>I&#x2F;O流技术</strong>可以读写文件</p><p>一些预备知识点：File类使用，方法递归，字符集，I&#x2F;O流，字节流&amp;&amp;字符流</p><ol><li><h3 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h3><p> 代表了操作系统的文件对象（文件，文件夹）</p><p> <strong>主要功能：</strong> 定位文件，删除文件，获取文件信息，创建文件</p><p> 创建File对象：<code>File f = new File(&quot;C:/file/b.xlsx&quot;)</code>​👉pathname支持 <u>绝对路径</u> 和 <u>相对路径</u> （相对工程目录）<br> 字节长度：<code>f.length()</code>​<br> 获取绝对路径：<code>f.getAbsolutePath()</code>​<br> 获取定义的路径：<code>f.getPath()</code>​<br> 获取文件名称：<code>f.getName()</code>​<br> 获取文件的最后修改时间：<code>long time = f.lastModified()</code>​获得时间毫秒值<br>                                      <code>new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;).format()</code>​转换成人话<br> 判断是文件还是文件夹：<code>.isFile() .isDirectory()</code>​</p><p> 创建新文件：<code>f.createNewFile()</code>​ &#x2F;&#x2F;几乎不用，会自动创建<br> 创建一级目录：<code>f.mkdir()</code>​<br> 创建多级目录：<code>f.mkdirs()</code>​<br> 删除文件(夹)：<code>f.delete()</code>​ &#x2F;&#x2F;只能删除空文件夹</p><p> 获取当前目录下所有一级文件名称，返回到字符串数组：<code>public String list()</code>​<br> —————————–对象，返回文件对象数组：<code>public File listFiles()</code>​ &#x2F;&#x2F;调用者<u>不存在&#x2F;为文件</u>时返回null，空文件夹时返回空数组（包括隐藏文件）</p></li><li><h3 id="方法递归Recursion"><a href="#方法递归Recursion" class="headerlink" title="方法递归Recursion"></a>方法递归Recursion</h3><p> 复杂的问题 划分为 较小规模的问题</p><p> 基线情况 + 递归情况 + 递归公式向基线情况靠近</p><ul><li><h4 id="递归经典问题"><a href="#递归经典问题" class="headerlink" title="递归经典问题"></a>递归经典问题</h4><p><img src="/2025/06/02/JAVA%E5%9F%BA%E7%A1%80/image-20220811211111-nsuoy6g.png" alt="image.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-comment">/**</span><br><span class="hljs-comment">x是第x天，f(x)是第x天摘的桃子</span><br><span class="hljs-comment">f(x) - f(x)/2 - 1 = f(x+1)</span><br><span class="hljs-comment">  */</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>      System.out.println(Peaches(<span class="hljs-number">1</span>));<br>  &#125;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">Peaches</span><span class="hljs-params">(<span class="hljs-type">int</span> day)</span>&#123;<br>      <span class="hljs-keyword">if</span>(day == <span class="hljs-number">10</span>)&#123;<br>          <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>      &#125;<br>      <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>*Peaches(day+<span class="hljs-number">1</span>)+<span class="hljs-number">2</span>;<br>      &#125;<br>  &#125;<br></code></pre></td></tr></table></figure></li><li><h4 id="非规律递归–文件搜索"><a href="#非规律递归–文件搜索" class="headerlink" title="非规律递归–文件搜索"></a>非规律递归–文件搜索</h4><p>遍历一级文件对象，判断是否是文件 → 如果是文件，是否是目标 → 如果是文件夹，返回步骤1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>       <span class="hljs-comment">//X盘中找codeblocks.exe</span><br>       searchFile(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;X:/codeblocks&quot;</span>),<span class="hljs-string">&quot;codeblocks.exe&quot;</span>);<br>   &#125;<br><br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> dir 被搜索的源目录</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> fileName  被搜索的文件名称</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">searchFile</span><span class="hljs-params">(File dir,String fileName)</span>&#123;<br>       <span class="hljs-keyword">if</span> (dir!=<span class="hljs-literal">null</span>&amp;&amp;dir.isDirectory())&#123;<br>           <span class="hljs-comment">//可以找</span><br>           File[] files = dir.listFiles();<br>           <span class="hljs-comment">//防止拿了空文件夹</span><br>           <span class="hljs-keyword">if</span> (files!=<span class="hljs-literal">null</span>&amp;&amp;files.length&gt;<span class="hljs-number">0</span>)&#123;<br>               <span class="hljs-keyword">for</span> (File file : files) &#123;<br>                   <span class="hljs-comment">//进去之后判断当前是文件还是文件夹</span><br>                   <span class="hljs-keyword">if</span> (file.isFile())&#123;<br>                       <span class="hljs-keyword">if</span> (file.getName().contains(fileName))&#123;<br>                           System.out.println(<span class="hljs-string">&quot;找到了&quot;</span>+file.getAbsolutePath());<br>                       &#125;<br>                   &#125;<span class="hljs-keyword">else</span>&#123;<br>                       searchFile(file,fileName);<br>                   &#125;<br>               &#125;<br>           &#125;<br>       &#125;<span class="hljs-keyword">else</span> &#123;<br>           System.out.println(dir.getAbsolutePath()+<span class="hljs-string">&quot;不是文件夹&quot;</span>);<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure></li><li><h4 id="非规律递归–啤酒问题"><a href="#非规律递归–啤酒问题" class="headerlink" title="非规律递归–啤酒问题"></a>非规律递归–啤酒问题</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//定义一个static成员变量用于存储可以买的酒数量</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> totalNum;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> lastBottleNum;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> lastCoverNum;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        buy(<span class="hljs-number">10</span>);<br>        System.out.println(<span class="hljs-string">&quot;总数：&quot;</span> + totalNum);<br>        System.out.println(<span class="hljs-string">&quot;剩余盖子：&quot;</span> + lastCoverNum);<br>        System.out.println(<span class="hljs-string">&quot;剩余瓶子：&quot;</span> + lastBottleNum);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">buy</span><span class="hljs-params">(<span class="hljs-type">int</span> money)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">buyNum</span> <span class="hljs-operator">=</span> money / <span class="hljs-number">2</span>; <span class="hljs-comment">//第一次直接可以买的酒数量</span><br>        totalNum += buyNum;<br>        <span class="hljs-comment">//盖子和瓶子换算成钱</span><br>        <span class="hljs-comment">//统计本轮总的盖子数和瓶子数</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">coverNum</span> <span class="hljs-operator">=</span> lastCoverNum + buyNum;   <span class="hljs-comment">//盖子数 = 上一次的盖子数+传进来的money可以直接买的酒数</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">bottleNUm</span> <span class="hljs-operator">=</span> lastBottleNum + buyNum; <span class="hljs-comment">//类上</span><br>        <span class="hljs-comment">//统计可以换算的钱</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">allMoney</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (coverNum&gt;=<span class="hljs-number">4</span>)&#123;<br>            allMoney += (coverNum/<span class="hljs-number">4</span>)*<span class="hljs-number">2</span>;<br>        &#125;<br>        lastCoverNum = coverNum%<span class="hljs-number">4</span>;<br>        <span class="hljs-keyword">if</span> (bottleNUm&gt;=<span class="hljs-number">2</span>)&#123;<br>            allMoney += (bottleNUm/<span class="hljs-number">2</span>)*<span class="hljs-number">2</span>;<br>        &#125;<br>        lastBottleNum = bottleNUm%<span class="hljs-number">2</span>;<br><br>        <span class="hljs-keyword">if</span> (allMoney&gt;=<span class="hljs-number">2</span>)&#123;<br>            buy(allMoney);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><h3 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h3><p> <strong>ASCII</strong>，<strong>GBK</strong>(中国码表,兼容ASCII表,包含了几万个汉字,<u>一个中文以两个字节存储</u>)，<strong>Unicode</strong>(万国码,容纳大多数国家的符号和文字,<u>utf-8后中文以三个字节存储</u>)<br> ​<img src="/2025/06/02/JAVA%E5%9F%BA%E7%A1%80/image-20220815213502-pnk172y.png" alt="image.png"></p><ul><li><p><strong>编码解码操作</strong></p><p>编码 – <code>getBytes(&quot;GBK...&quot;)</code>​编码，返回字节数组</p><p>解码 – S<code>tring rs = new String(字节数组,&quot;GBK...&quot;)</code>​编解码前后的字符集必须一致，否则乱码</p></li></ul></li><li><h3 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h3><p> 磁盘与内存间的输入输出流，用以读写数据</p><p> 按传输的最小单位划分：字节流（音视频文件），字符流（纯文本文件）</p><p> <img src="/2025/06/02/JAVA%E5%9F%BA%E7%A1%80/image-20220821090533-j670u2d.png" alt="image.png"></p><ol><li><p><strong>字节流</strong></p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    一次读一个字节的FileInputStream(性能差，可能乱码)</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//创建一个文件字节输入流管道</span><br><span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(”path/File“);<br><span class="hljs-comment">//读取一个字节，返回</span><br><span class="hljs-type">int</span> <span class="hljs-variable">b1</span> <span class="hljs-operator">=</span> is.read();<br><span class="hljs-comment">//读取下一个，返回（未读到返回-1）</span><br><span class="hljs-type">int</span> <span class="hljs-variable">b2</span> <span class="hljs-operator">=</span> is.read();<br><span class="hljs-comment">//循环形式</span><br><span class="hljs-type">int</span> b;<br><span class="hljs-keyword">while</span>((b = is.read())!=-<span class="hljs-number">1</span>)&#123;...&#125;<br></code></pre></td></tr></table></figure> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    一次读一个字节数组的FileInputStream(可能乱码)</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(”path/File“);<br><span class="hljs-comment">//定义一个字节数组，用于读取()</span><br><span class="hljs-type">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">3</span>];<br><span class="hljs-type">int</span> len;<br><span class="hljs-keyword">while</span>((len = is.read(buffer)) != -<span class="hljs-number">1</span>)&#123;<br>    sout.<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(buffer,<span class="hljs-number">0</span>,len);<br>&#125;<br></code></pre></td></tr></table></figure> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    一次读完全部字节的FileInputStream(solve the messy code problem)</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(”path/File“);<br><span class="hljs-comment">//set buffer长度为文件字节长度(line6,7 is the same)</span><br><span class="hljs-type">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[(<span class="hljs-type">int</span>)f.length()]<br><span class="hljs-type">byte</span>[] buffer = is.readAllBytes();<br></code></pre></td></tr></table></figure><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>public void write(int a)</td><td>写一个字节出去</td></tr><tr><td>public void write(byte[] buffer)</td><td>写一个字节数组</td></tr><tr><td>public void write(byte[] buffer,int pos,int len)</td><td>写一个字节数组的一部分出去</td></tr><tr><td>flush()</td><td>刷新流，可以继续写</td></tr><tr><td>close()</td><td>关闭流，释放资源（关闭前刷新，一旦关闭，无法写数据）</td></tr></tbody></table> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    FileOutputStream</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">OutputStream</span> <span class="hljs-variable">os</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(”path/File“,<span class="hljs-literal">true</span>);<span class="hljs-comment">//true可以保证向文件追加数据而不是先清空再写</span><br><span class="hljs-type">byte</span>[] buffer = <span class="hljs-string">&quot;something&quot;</span>.getBytes();<br>os.write(<span class="hljs-string">&quot;/r/n&quot;</span>.getBytes());<span class="hljs-comment">//换行</span><br>os.write(buffer);<br>os.close(); <br></code></pre></td></tr></table></figure><blockquote><p><strong>文件拷贝</strong></p><p>Step1. 根据数据源创建字节输入流对象<br>Step2. 根据目的地创建字节输出流对象<br>Step3. 读写数据，复制视频<br>Step4. 释放资源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(”path/File“);<br><span class="hljs-type">OutputStream</span> <span class="hljs-variable">os</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(”path/File“);<br><span class="hljs-type">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>]；<br><span class="hljs-type">int</span> len;<br><span class="hljs-keyword">while</span>(len=is.read(buffer)!=-<span class="hljs-number">1</span>)&#123;<br>os.write(buffer,<span class="hljs-number">0</span>,len);<br>os.close();<br>is.close();<br></code></pre></td></tr></table></figure><p><img src="/2025/06/02/JAVA%E5%9F%BA%E7%A1%80/image-20220821224054-yqfu1t8.png" alt="image.png"></p></blockquote><blockquote><p><strong>资源释放的方式</strong></p><p>try-catch-finally&#x2F;try-with-resource</p><p>因为finally语句一定会执行(除非JVM退出)，因此适合做资源释放的工作.close()<br>如果finally中有return的话，上面语句的return不会执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// JDK7更新的资源释放方式</span><br><span class="hljs-keyword">try</span>(<br><span class="hljs-comment">//定义流对象，只能放置资源对象（implements了Closeable/AutoCloseable接口的对象），用完自动关闭</span><br><span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(”path/File“);<br><span class="hljs-type">OutputStream</span> <span class="hljs-variable">os</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(”path/File“);<br>)&#123;...&#125;<br><span class="hljs-keyword">catch</span>&#123;...&#125;<br></code></pre></td></tr></table></figure></blockquote></li><li><p><strong>字符流</strong></p><p> 按单个字符读取，读取中文不会乱码(编码格式一致)，更合适</p><p> 构造器：<code>public FileReader(file/path)</code>​、<code>public FileWriter(file/path,true)</code>​</p><table><thead><tr><th>method</th><th>statement</th></tr></thead><tbody><tr><td>public int read()</td><td>每次读取一个字符，读完返回-1</td></tr><tr><td>public int read(char[] buffer)</td><td>读取字符数组，返回字符个数，读完返回-1</td></tr><tr><td>void write(…)</td><td>可以写字符，字符数组(一部分)，字符串(一部分)</td></tr><tr><td>flush()</td><td>刷新</td></tr><tr><td>close()</td><td>关闭流，释放</td></tr></tbody></table> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    一次读一个字节的FileReader(性能差)</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">Reader</span> <span class="hljs-variable">fr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(<span class="hljs-string">&quot;path/file&quot;</span>);<br><span class="hljs-keyword">while</span> ((code=fr.read())!=-<span class="hljs-number">1</span>)&#123;<br>    sout.(<span class="hljs-type">char</span>)code;<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">    一次读一个字节数组的FileReader</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">char</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[<span class="hljs-number">1024</span>];<br><span class="hljs-type">int</span> len;<br><span class="hljs-keyword">while</span>(len=fr.read(buffer)!=-<span class="hljs-number">1</span>)&#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(buffer,<span class="hljs-number">0</span>,len);<br>    sout.rs;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li><li><h3 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h3><p> &#x3D;&#x3D;自带缓冲区，提高原始流的性能&#x3D;&#x3D;</p><p> <img src="/2025/06/02/JAVA%E5%9F%BA%E7%A1%80/image-20220825150235-ts9sija.png" alt="image.png">​</p><ul><li><p><strong>字节缓冲流</strong></p><p>​<code>BufferedInputStream</code>​、<code>BufferedOutputStream</code>​(自带了8kb的缓冲池)</p><p>​<code>InputStream bis = new BufferedInputStream(is)</code>​直接将FileInputStream包装成BufferedInputStream</p></li><li><p><strong>字符缓冲流</strong></p><p>​<code>BufferedReader</code>​ ，多了一个<code>readLine</code>​方法</p><p>​<code>BufferedWriter</code>​，多了一个<code>newLine</code>​方法</p></li></ul><blockquote><p><strong>代码与文件编码不一致的乱码问题</strong></p><ul><li><p>字符输入转换流（InputStreamReader）</p><p>InputStreamReader(InputStream in, String charsetName)</p></li><li><p>字符输出转换流（OutputStreamReader）&#x3D;“String”.getBytes()</p><p>控制写出的字符使用的编码</p><p>OutputStreamWriter(OutputStream out, Charset cs)</p></li></ul></blockquote></li><li><h3 id="序列化对象"><a href="#序列化对象" class="headerlink" title="序列化对象"></a>序列化对象</h3><ul><li><h5 id="对象序列化"><a href="#对象序列化" class="headerlink" title="对象序列化"></a>对象序列化</h5><p>定义：以内存为基准，将内存的对象存储到磁盘文件中</p><p>使用<strong>对象字节输出流ObjectOutputStream</strong></p><table><thead><tr><th>构造器</th><th>statement</th></tr></thead><tbody><tr><td>public ObjectOutputStream(OutputStream out)</td><td>低级字节输出流包装成高级的对象字节输出流</td></tr></tbody></table><p>对象class必须implements Serializable才能序列化</p></li><li><h5 id="对象反序列化"><a href="#对象反序列化" class="headerlink" title="对象反序列化"></a>对象反序列化</h5><p>定义：以内存为基准，将磁盘文件中的对象数据恢复成内存中的对象</p><p>使用<strong>对象字节输入流ObjectInputStream</strong></p><table><thead><tr><th>构造器</th><th>statement</th></tr></thead><tbody><tr><td>public ObjectInputStream(InputStream in)</td><td>低级字节输入流包装成高级的对象字节输入流<br /></td></tr></tbody></table><p>​<code>private transient password</code>​敏感信息可以用transient修饰，不参与序列化</p><p>可以定义final字段来规定序列化的版本号</p></li></ul></li><li><h3 id="打印流"><a href="#打印流" class="headerlink" title="打印流"></a>打印流</h3><p> 两种：FileOutputStream -&gt; PrintStream 或者 FileWriter -&gt; PrintWriter</p><p> 最强大的写数据到文件流，可以实现所见即所得</p><table><thead><tr><th>构造器</th><th>statement</th></tr></thead><tbody><tr><td>public PrintStream(OutputStream os)</td><td>直接通向字节输出流管道<br /></td></tr><tr><td>public PrintStream(File f)</td><td>直接通向文件对象</td></tr><tr><td>public PrintStream(String filepath)</td><td>直接通向文件路径</td></tr><tr><td>…</td><td>…</td></tr></tbody></table><table><thead><tr><th>method</th><th>statement</th></tr></thead><tbody><tr><td>public print(xxx xx)</td><td>打印任意类型数据<br /></td></tr></tbody></table><p> 打印功能上PrintStream与PrintWriter无异（归属有异，写数据上PrintStream 只能写字节数据）</p></li><li><h3 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h3><p> Map -&gt; HashTable -&gt; Properties</p><p> 其实就是一个Map集合，但不当集合用（因为HashMap更好用）</p><p> 核心作用：<strong>Properties代表一个属性文件，可以把自己对象中的键值对信息存入一个属性文件中</strong></p><p> 属性文件：.properties结尾的文件，里面的内容都是key&#x3D;value，后续做系统配置信息</p><p> method：<code>properties.store()</code>​、<code>properties.getProperties()</code>​、<code>properties.setProperties()</code>​</p></li><li><h3 id="Commons-IO"><a href="#Commons-IO" class="headerlink" title="Commons-IO"></a>Commons-IO</h3><p> apache基金会提供的有关IO操作的类库，主要的类有FileUtils，IOUtils</p><p> 详细可见：<a href="https://www.cnblogs.com/johnnyzen/p/18291766">https://www.cnblogs.com/johnnyzen/p/18291766</a>，或<a href="https://commons.apache.org/proper/commons-io/">官网</a></p></li></ol><p>‍</p><ul><li><h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a><strong>线程</strong></h1><p>多线程的创建、Thread类的常用方法、线程安全、线程同步、线程通信、线程池、定时器、线程状态…</p><ol><li><h3 id="创建Thread"><a href="#创建Thread" class="headerlink" title="创建Thread"></a>创建Thread</h3><ol><li><p>方案一（继承Thread类）</p><p> ① 定义一个myThread子类&#x3D;&#x3D;继承&#x3D;&#x3D;java.lang.Thread，重写run()</p><p> ② 创建myThread类的对象</p><p> ③ 调用线程对象的start()方法启动线程</p><p> <strong>缺点</strong>：继承Thread类，无法继承其他类，不利于扩展</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//多线程创建方式一:继承Thread类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">createThread</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">myThread</span>();<br>        thread.start();<br>        task;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">myThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br><span class="hljs-comment">//    重写run()</span><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        task;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>方案二（实现Runnable接口）</p><p> ① 定义一个线程任务类MyRunnable实现Runnable接口，重写run()</p><p> ② 创建MyRunnable任务对象</p><p> ③ 把MyRunnable的任务对象交给Thread处理</p><p> ④ 调用线程对象的start()方法启动线程</p><p> <strong>缺点</strong>：多了一层对象包装，线程的执行结果无法直接return（第一种也无法直接return）</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 实现Runnable接口，创建线程</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">createThread2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//创建任务对象</span><br>        <span class="hljs-type">Runnable</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyRunnable</span>();<br>        <span class="hljs-comment">//把任务对象交给Thread处理</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(target);<br>        <span class="hljs-comment">//启动线程</span><br>        t.start();<br>        task;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        task;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p> <strong>另一种写法（匿名内部类）</strong> </p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">createThreadOther</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Runnable</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>                    System.out.println(<span class="hljs-string">&quot;子线程执行输出：&quot;</span>+i);<br>                &#125;<br>            &#125;<br>        &#125;;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(target);<br>        t.start();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            System.out.println(<span class="hljs-string">&quot;主线程执行输出：&quot;</span>+i);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//lambda表达式简化</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">createThreadOther</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>          <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)&#123;<br>        System.out.println(<span class="hljs-string">&quot;子线程执行输出：&quot;</span>+i);<br>      &#125;<br>    &#125;).start();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            System.out.println(<span class="hljs-string">&quot;主线程执行输出：&quot;</span>+i);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>方案三（JDK5.0 Callable&amp;FutureTask，解决不能直接return线程执行结果的问题）</p><p> ① 得到任务对象</p><ul><li>定义类实现Callable接口，重写call()，封装要做的事</li><li>用FutureTask把Callable对象封装成线程任务对象</li></ul><p> ② 线程任务对象交给Thread处理</p><p> ③ 调用Thread的start()启动线程，执行任务</p><p> ④ 线程执行完毕后，用FutureTask的get()获取任务执行的结果</p><p> <strong>缺点</strong>：编码复杂</p><p> <strong>优点</strong>：扩展性强，实现接口的同时可继承其他类；可以得到线程执行的结果</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.Callable;<br><span class="hljs-keyword">import</span> java.util.concurrent.ExecutionException;<br><span class="hljs-keyword">import</span> java.util.concurrent.FutureTask;<br><span class="hljs-comment">// Callable+FutureTask</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">createThread3</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 3.创建Callable任务对象</span><br>        Callable&lt;String&gt; call = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyCallable</span>(<span class="hljs-number">100</span>);<br>        <span class="hljs-comment">// 4.把Callable对象封装成FutureTask对象（FutureTask是Runable的对象）</span><br>        FutureTask&lt;String&gt; f1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;&gt;(call);<br>        <span class="hljs-comment">// 5.交给线程</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(f1);<br>        t1.start();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">rs1</span> <span class="hljs-operator">=</span> f1.get();<br>            System.out.println(<span class="hljs-string">&quot;第一个结果是：&quot;</span>+rs1);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 1.定义任务类 实现Callable接口</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCallable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Callable</span>&lt;String&gt;&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> n;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyCallable</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-built_in">this</span>.n = n;<br>    &#125;<br>    <span class="hljs-comment">// 2.重写call(),线程的任务方法</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= n; i++) &#123;<br>            sum+=i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;子线程返回的结果是：&quot;</span>+sum;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li><li><h3 id="Thread的常用方法"><a href="#Thread的常用方法" class="headerlink" title="Thread的常用方法"></a>Thread的常用方法</h3><ul><li><p><strong>如何区分不同线程</strong></p><table><thead><tr><th>method</th><th>statement</th></tr></thead><tbody><tr><td>getName()</td><td>获取当前线程名</td></tr><tr><td>setName(String name)</td><td>修改线程名</td></tr><tr><td>currentThread()</td><td>获取当前线程对象</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xyf.thread.APIofThread;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">distinguishThread</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyTHread</span>();<br>        t1.setName(<span class="hljs-string">&quot;no1&quot;</span>);<br>        t1.start();<br>        System.out.println(t1.getName());<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyTHread</span>();<br>        t2.setName(<span class="hljs-string">&quot;no2&quot;</span>);<br>        t2.start();<br>        System.out.println(t2.getName());<br>        <span class="hljs-comment">//to get main thread</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>        System.out.println(m.getName());<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            System.out.println(<span class="hljs-string">&quot;main线程输出：&quot;</span>+i);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyTHread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;子线程输出：&quot;</span>+i);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>也可以在MyThread类中修改构造器</p><p>Thread的构造器</p><table><thead><tr><th>constructor</th><th>statement</th></tr></thead><tbody><tr><td>public Thread(Stirng name)</td><td>为当前线程指定名称</td></tr><tr><td>public Thread(Runable target)</td><td>封装Runnable对象成为线程对象</td></tr><tr><td>public Thread(Runable target,Stirng name)</td><td>封装Runnable对象成为，并指定名称</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">MyThread</span><span class="hljs-params">(String name)</span>&#123;<br>    <span class="hljs-comment">//调用父类Thread的构造器</span><br>    <span class="hljs-built_in">super</span>(name);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>线程的休眠方法</strong></p><table><thead><tr><th>method</th><th>statement</th></tr></thead><tbody><tr><td>public static void sleep(long time)</td><td>线程休眠time时间再执行，单位ms</td></tr></tbody></table></li></ul></li><li><h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><p> 多个Thread同时操作同一个共享资源时可能会出现的业务安全问题</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Account</span>&#123;<br>    <span class="hljs-keyword">private</span> String cardID;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> money;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Account</span><span class="hljs-params">(String cardID, <span class="hljs-type">double</span> money)</span> &#123;<br>        <span class="hljs-built_in">this</span>.cardID = cardID;<br>        <span class="hljs-built_in">this</span>.money = money;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Account</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getCardID</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> cardID;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setCardID</span><span class="hljs-params">(String cardID)</span> &#123;<br>        <span class="hljs-built_in">this</span>.cardID = cardID;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getMoney</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> money;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setMoney</span><span class="hljs-params">(<span class="hljs-type">double</span> money)</span> &#123;<br>        <span class="hljs-built_in">this</span>.money = money;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drawMoney</span><span class="hljs-params">(<span class="hljs-type">double</span> money)</span> &#123;<br>        <span class="hljs-comment">//1.判断谁来取钱</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> Thread.currentThread().getName();<br>        <span class="hljs-comment">//2.判断账户钱够不够</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.money&gt;=money)&#123;<br>            <span class="hljs-comment">//3.取钱，更新余额</span><br>            System.out.println(name+<span class="hljs-string">&quot;取钱成功，取出：&quot;</span>+money+<span class="hljs-string">&quot;元&quot;</span>);<br>            <span class="hljs-built_in">this</span>.money-=money;<br>            System.out.println(name+<span class="hljs-string">&quot;取钱后剩余：&quot;</span>+<span class="hljs-built_in">this</span>.money);<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            System.out.println(name+<span class="hljs-string">&quot;取钱失败，余额不足&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DrawThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br>    <span class="hljs-comment">//取钱线程类</span><br>    <span class="hljs-keyword">private</span> Account account;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DrawThread</span><span class="hljs-params">(Account account,String name)</span>&#123;<br>        <span class="hljs-built_in">super</span>(name);<br>        <span class="hljs-built_in">this</span>.account=account;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        account.drawMoney(<span class="hljs-number">100000</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">run</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//账户实例（用户共享账户）</span><br>        <span class="hljs-type">Account</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Account</span>(<span class="hljs-string">&quot;123456&quot;</span>,<span class="hljs-number">100000</span>);<br>        <span class="hljs-comment">//创建两个用户线程</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">DrawThread</span>(a,<span class="hljs-string">&quot;Tom&quot;</span>).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">DrawThread</span>(a,<span class="hljs-string">&quot;Ivan&quot;</span>).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3><p> <strong>核心思想</strong></p><ul><li><p><strong>锁</strong> <strong>lock</strong></p><p>将共享资源上锁，一次只能一个Thread进入，访问完毕后解锁，Other thread才能进</p></li></ul><ol><li><p>&#x3D;&#x3D;上锁方法一：同步代码块&#x3D;&#x3D;</p><p> <strong>Function</strong>：把出现线程安全的code上锁</p><p> <strong>Principal</strong>：每次只能一个Thread进入，执行完毕后自动解锁，其他Thread才能执行</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span>(同步锁对象)&#123;<br>  <span class="hljs-comment">//   ↑使用共享资源作为锁对象(实例方法用this，静态方法用类名.class)</span><br>  <span class="hljs-comment">//操作共享资源的代码</span><br>  ...<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>&#x3D;&#x3D;上锁方法二：同步方法&#x3D;&#x3D;</p><p> <strong>Function</strong>：把出现线程安全的function上锁</p><p> <strong>Principal</strong>：same</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">修饰符 <span class="hljs-keyword">synchronized</span> 返回值类型 方法名称(para1,para2,...)&#123;<br>  <span class="hljs-comment">//操作共享资源的代码</span><br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><p> <strong>底层原理</strong>：其实方法前加<code>synchronized</code>​与同步代码块方法是一样的，底层有隐式锁对象锁住整个方法代码，实例-this，静态-类名.class</p></li><li><p>&#x3D;&#x3D;上锁方法三：Lock锁&#x3D;&#x3D;</p><p> JDK5后提供了Lock锁对象，Lock是接口不能实例化，用其实现类<code>public ReentrantLock()</code>​ 构建Lock锁对象</p><p> ​<code>lock()/unlock()</code>​方法上&#x2F;解锁，最好放在try-finally结构中保证始终解锁</p><p> ​<code>lock.tryLock(1, TimeUnit.SECONDS)</code>​，程序可以通过trylock的返回值做一些额外处理，而不是无限等待下去</p></li></ol></li><li><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p> 一个复用线程的技术，工作线程 + 任务队列</p><ol><li><h5 id="创建线程池"><a href="#创建线程池" class="headerlink" title="创建线程池"></a>创建线程池</h5><p> JDK5起提供了一个代表线程池的<u>接口</u>：<code>ExecutorService</code>​</p><ul><li><p><strong>方法一（推荐）</strong></p><p>使用<code>ExecutorService</code>​的实现类&#x3D;&#x3D;​<code>ThreadPoolExecutor</code>​&#x3D;&#x3D;​自创建一个线程池对象</p><p>ThreadPoolExecutor提供的有参构造器的参数含义</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>corePoolSize</td><td>指定线程池核心线程数量<br />“正式工”</td></tr><tr><td>maximumPoolSize</td><td>最大线程数<br />“正式工+临时工”</td></tr><tr><td>keepAliveTime</td><td>指定临时线程的存活时间</td></tr><tr><td>unit</td><td>临时线程存活的时间单位（秒，分，时，天）<br /><code>TimeUnit.SECONDS</code>​…</td></tr><tr><td>workQueue</td><td>指定线程池的任务队列<br /><code>new ArrayBlockingQueue&lt;&gt;(3)</code>​</td></tr><tr><td>threadFactory</td><td>指定线程池的线程工厂<br />“负责招聘的HR”<br /><code>Executors.defaultThreadFactory()</code>​</td></tr><tr><td>handler</td><td>任务拒绝策略<br /><code>new ThreadPoolExecutor.AbortPolicy()</code>​</td></tr></tbody></table></li><li><p><strong>方法二</strong></p><p>使用线程池的工具类<code>Executors</code>​，调用其方法返回不同的线程池对象</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>​<code>pulic static ExecutorService newFixedThreadPool(int nThreads)</code>​</td><td>创建固定线程数量的线程池，如果线程因异常结束，系统会创建新线程替代</td></tr><tr><td>​<code>pulic static ExecutorService newSingleThreadExecutor()</code>​</td><td>创建只有一个线程的线程池对象，如果线程因异常结束，系统会创建新线程替代</td></tr><tr><td>​<code>pulic static ExecutorService newcachedThreadPool()</code>​</td><td>线程数随任务数增加，执行完毕且空闲60s的线程会被回收</td></tr><tr><td>​<code>pulic static ScheduledExecutorService newScheduledThreadPool(int corePoolSize)</code>​</td><td>创建一个线程池，在给定延迟后执行任务，或是定期执行任务</td></tr></tbody></table><p><strong>Executors可能存在的问题</strong>（alibaba开发手册）<br>1）<code>FixedThreadPool</code>​和<code>SingleThreadPool</code>​：<br>允许的请求队列长度为Integer.MAX_VALUE，可能会导致堆积大量的请求，从而导致OOM<br>2）<code>cachedThreadPool</code>​和<code>ScheduledThreadPool</code>​：<br>允许的创建线程数量为Integer.MAX_VALUE，可能会创建大量的线程，从而导致OOM</p></li></ul></li><li><h5 id="Future类"><a href="#Future类" class="headerlink" title="Future类"></a>Future类</h5><p> Future是一个用于获取异步结果的接口、</p><p> 一般来说，当我们执行一个长时间运行的任务时，使用Future就可以让我们暂时去处理其他的任务，等长任务执行完毕再返回其结果。<br> 经常会使用到Future的场景有：1. 计算密集场景。2. 处理大数据量。3. 远程方法调用等。</p></li><li><h5 id="ExecutorService的常用方法"><a href="#ExecutorService的常用方法" class="headerlink" title="ExecutorService的常用方法"></a>ExecutorService的常用方法</h5><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>​<code>void execute(Runable command)</code>​</td><td>执行Runable任务</td></tr><tr><td>​<code>Future&lt;T&gt; submit(Callable&lt;T&gt; task)</code>​</td><td>执行Callable任务，返回未来任务对象</td></tr><tr><td>​<code>void shutdown()</code>​</td><td>等全部任务执行完成后，关闭线程池</td></tr><tr><td>​<code>List&lt;Runable&gt; shutDownNow()</code>​</td><td>立刻关闭线程池，停止正在执行的任务，并返回队列中未执行的任务</td></tr></tbody></table></li><li><h5 id="临时线程"><a href="#临时线程" class="headerlink" title="临时线程"></a>临时线程</h5><p> 新的任务提交时，&#x3D;&#x3D;核心线程都在执行&#x3D;&#x3D;，&#x3D;&#x3D;任务队列也满了&#x3D;&#x3D;，且&#x3D;&#x3D;支持创建临时线程&#x3D;&#x3D;时，才会<u>创建临时线程</u></p></li><li><h5 id="任务拒绝策略"><a href="#任务拒绝策略" class="headerlink" title="任务拒绝策略"></a>任务拒绝策略</h5><table><thead><tr><th>策略</th><th>说明</th></tr></thead><tbody><tr><td>​<code>ThreadPoolExecutor.AbortPolicy()</code>​</td><td>丢弃任务 并抛出异常，为默认策略</td></tr><tr><td>​<code>ThreadPoolExecutor.DiscardPolicy()</code>​</td><td>丢弃任务 不抛出异常</td></tr><tr><td>​<code>ThreadPoolExecutor.DiscardOldestPolicy()</code>​</td><td>丢弃等待最久的任务，把当前任务加入队列中</td></tr><tr><td>​<code>ThreadPoolExecutor.CallerRunsPolicy()</code>​</td><td>由主线程负责调用任务的<code>run()</code>​方法，从而绕过线程池直接执行线程</td></tr></tbody></table></li><li><h5 id="并发-并行"><a href="#并发-并行" class="headerlink" title="并发 &amp; 并行"></a>并发 &amp; 并行</h5><ul><li><p>并发</p><p>process中的thread是由CPU调度的，但CPU核心数有限，为了保证所有线程执行，CPU会轮询<br>由于CPU切换速度很快，给人的感觉是线程同时执行。这就是并发</p></li><li><p>并行</p><p>同一时刻，多个线程被CPU执行</p></li></ul></li></ol></li></ol></li><li><h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h1><ol><li><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul><li><p><strong>IP</strong></p><p>Java中使用<code>InetAddress</code>​类实现IP地址</p><table><thead><tr><th><span data-type="text" style="background-color: var(--b3-font-background5);">常用方法</span></th><th>说明</th></tr></thead><tbody><tr><td>public static InetAddress getLocalHost() throws UnknownHostException</td><td>获取本机ip，返回InetAddress对象</td></tr><tr><td>public String getHostName()</td><td>获取主机名</td></tr><tr><td>public String getHostAddress()</td><td>获取ip</td></tr><tr><td>public static InetAddress getByName(String host) throws UnknownHostException</td><td>根据ip或域名，返回InetAddress对象</td></tr><tr><td>public boolean isReachable(int timeout) throws IOException</td><td>判断主机毫秒内与调用方法的ip是否能连通</td></tr></tbody></table></li><li><p><strong>端口</strong></p><p>周知端口：0 - 1023，被预先定义的应用占用<br>注册端口：1024 - 49151，分配给用户进程或某些应用程序<br>动态端口：49152 - 65535，动态分配</p></li><li><p><strong>协议</strong></p><p>UDP（User Datagram Protocol，用户数据报协议）：无连接，不可靠<br>TCP（Transmission Control Protocol，传输控制协议）：面向连接，可靠，三次握手四次挥手</p></li></ul></li><li><h3 id="UDP通信"><a href="#UDP通信" class="headerlink" title="UDP通信"></a>UDP通信</h3><p> 不事先建立连接，发送端将数据(&lt;&#x3D;64KB)、接收端IP等信息封装为一个数据包，发出去就不跟踪了</p><p> ​<code>java.net.DatagramSocket</code>​包用于实现UDP通信</p><table><thead><tr><th>构造器</th><th>说明</th></tr></thead><tbody><tr><td>public DatagramSocket()</td><td>创建客户端socket对象，系统会随机分配一个端口号</td></tr><tr><td>public DatagramSocket(int port)</td><td>创建服务端的socket对象，并指定端口号</td></tr></tbody></table><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>public void send(DatagramPacket dp)</td><td>发送数据包</td></tr><tr><td>public void receive(DatagramPacket dp)</td><td>使用数据包接收数据</td></tr></tbody></table><p> <span data-type="text" style="color: var(--b3-font-color8);">其中，</span><u>DatagramPacket</u><span data-type="text" style="color: var(--b3-font-color8);">是一种数据包类</span></p><table><thead><tr><th>构造器</th><th>说明</th></tr></thead><tbody><tr><td>public DatagramPacket(byte buf[], int length, InetAddress address, int port)</td><td>创建客户端socket对象，系统会随机分配一个端口号</td></tr><tr><td>public DatagramPacket(byte buf[], int length)</td><td>创建服务端的socket对象，并指定端口号</td></tr></tbody></table><ul><li><p><strong>一发一收</strong></p><p><strong>客户端（发送）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1. 创建发送端对象</span><br><span class="hljs-type">DatagramSocket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramSocket</span>();<br><span class="hljs-comment">// 2. 创建数据包</span><br><span class="hljs-type">byte</span>[] dataInBytes = <span class="hljs-string">&quot;我是要发送的数据&quot;</span>.getBytes();<br><span class="hljs-type">DatagramPacket</span> <span class="hljs-variable">packet</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramPacket</span>(dataInBytes, dataInBytes.length, InetAddress.getByName(<span class="hljs-string">&quot;ip地址&quot;</span>)， <span class="hljs-number">8080</span>);<br><span class="hljs-comment">// 3. 发送数据包</span><br>socket.send(packet);<br></code></pre></td></tr></table></figure><p><strong>服务端（接收）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1. 创建服务端对象</span><br><span class="hljs-type">DatagramSocket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramSocket</span>(<span class="hljs-number">8080</span>);<br><span class="hljs-comment">// 2. 创建一个用于接收的数据包</span><br><span class="hljs-type">byte</span>[] buf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>*<span class="hljs-number">64</span>];<br><span class="hljs-type">DatagramPacket</span> <span class="hljs-variable">packet</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramPacket</span>(buf, buf.length);<br><span class="hljs-comment">// 3. 接收数据，将数据封装到数据包对象</span><br>socket.receive();<br><span class="hljs-type">String</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(buf, <span class="hljs-number">0</span>, packet.getLength());<br></code></pre></td></tr></table></figure></li><li><p><strong>多发多收</strong></p><p><strong>客户端（发送）</strong><br>思路：使用<code>while(true)</code>​不断接收用户输入，直到用户输入exit</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1. 创建发送端对象</span><br><span class="hljs-type">DatagramSocket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramSocket</span>();<br><span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>    <span class="hljs-comment">// 2. 创建数据包</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> sc.nextLine();<br>    <span class="hljs-keyword">if</span>(<span class="hljs-string">&quot;msg&quot;</span>.equals(<span class="hljs-string">&quot;exit&quot;</span>))&#123;...;<span class="hljs-keyword">break</span>;&#125;<br>    <span class="hljs-type">byte</span>[] dataInBytes = msg.getBytes();<br>    <span class="hljs-type">DatagramPacket</span> <span class="hljs-variable">packet</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramPacket</span>(dataInBytes, dataInBytes.length, InetAddress.getByName(<span class="hljs-string">&quot;ip地址&quot;</span>)， <span class="hljs-number">8080</span>);<br>    <span class="hljs-comment">// 3. 发送数据包</span><br>    socket.send(packet);<br>    socket.close();<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>服务端（接收）</strong><br>思路：<code>while(true)</code>​不断执行<code>receive</code>​方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1. 创建服务端对象</span><br><span class="hljs-type">DatagramSocket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramSocket</span>(<span class="hljs-number">8080</span>);<br><span class="hljs-comment">// 2. 创建一个用于接收的数据包</span><br><span class="hljs-type">byte</span>[] buf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>*<span class="hljs-number">64</span>];<br><span class="hljs-type">DatagramPacket</span> <span class="hljs-variable">packet</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramPacket</span>(buf, buf.length);<br><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>    <span class="hljs-comment">// 3. 接收数据，将数据封装到数据包对象</span><br>    socket.receive();<br>    <span class="hljs-type">String</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(buf, <span class="hljs-number">0</span>, packet.getLength());<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><h3 id="TCP通信"><a href="#TCP通信" class="headerlink" title="TCP通信"></a>TCP通信</h3><p> 面向连接，可靠通信，三次握手，四次挥手</p><p> ​<code>java.net.Socket</code>​类实现TCP通信，基于IO流管道通信</p><table><thead><tr><th>构造器</th><th>说明</th></tr></thead><tbody><tr><td>public Socket(String host, int port)</td><td>根据指定服务器ip、端口号请求与服务器建立连接，连接通过获得了客户端的socket</td></tr></tbody></table><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>public OutputStream getOutputStream()</td><td>获得字节输出流对象</td></tr><tr><td>public InputStream getInputStream()</td><td>获得字节输入流对象</td></tr></tbody></table><ul><li><p><strong>一发一收</strong></p><p><strong>客户端（发送）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1. 创建Socket管道对象，请求与服务端的Socket连接</span><br><span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Socket</span>(<span class="hljs-string">&quot;ip&quot;</span>, <span class="hljs-number">8080</span>);<br><span class="hljs-comment">// 2. 从socket管道中得到一个字节输出流</span><br><span class="hljs-type">OutputStream</span> <span class="hljs-variable">os</span> <span class="hljs-operator">=</span> socket.getOutputStream();<br><span class="hljs-comment">// 3. 特殊数据流</span><br><span class="hljs-type">DataOutputStream</span> <span class="hljs-variable">dos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataOutputStream</span>(os);<br>dos.writeInt(<span class="hljs-number">1</span>)；<br>dos.writeUTF(<span class="hljs-string">&quot;要发送的UTF编码字符&quot;</span>);<br><span class="hljs-comment">// 4. 释放资源</span><br>socket.close();<br></code></pre></td></tr></table></figure><p><strong>服务端（接收）</strong></p><p><span data-type="text" style="color: var(--b3-font-color1);">服务端是通过</span><code>java.net.ServerSocket</code>​​​​<span data-type="text" style="color: var(--b3-font-color1);">实现的</span></p><table><thead><tr><th>构造器</th><th>说明</th></tr></thead><tbody><tr><td>public ServerSocket(int port)</td><td>为服务端程序注册端口</td></tr></tbody></table><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>public Socket accept()</td><td>阻塞等待客户端的连接请求，与客户端连接成功后，返回服务端侧的Socket对象</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1. 创建一个ServerSocket对象</span><br><span class="hljs-type">ServerSocket</span> <span class="hljs-variable">ss</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span>(<span class="hljs-number">8080</span>);<br><span class="hljs-comment">// 2. 等待客户端连接</span><br><span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> ss.accept();<br><span class="hljs-comment">// 3. 获取输入流，读取客户端发送的信息</span><br><span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> socket.getInputStream();<br><span class="hljs-comment">// 4. 将字节输入流包装为特殊数据输入流</span><br><span class="hljs-type">DataInputStream</span> <span class="hljs-variable">dis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataInputStream</span>(is);<br><span class="hljs-comment">// 5. 读取数据</span><br><span class="hljs-type">int</span> <span class="hljs-variable">data1</span> <span class="hljs-operator">=</span> dis.readInt();<br><span class="hljs-type">String</span> <span class="hljs-variable">data2</span> <span class="hljs-operator">=</span> dis.readUTF();<br></code></pre></td></tr></table></figure></li><li><p><strong>多发多收</strong></p><p><strong>客户端（发送）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1. 创建Socket管道对象，请求与服务端的Socket连接</span><br><span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Socket</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">8080</span>);<br><span class="hljs-comment">// 2. 从socket管道中得到一个字节输出流</span><br><span class="hljs-type">OutputStream</span> <span class="hljs-variable">os</span> <span class="hljs-operator">=</span> socket.getOutputStream();<br><span class="hljs-comment">// 3. 特殊数据流</span><br><span class="hljs-type">DataOutputStream</span> <span class="hljs-variable">dos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataOutputStream</span>(os);<br><span class="hljs-comment">// 4. while(True)接输入数据</span><br><span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br><span class="hljs-keyword">while</span>(True)&#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> sc.nextLine();<br>    <span class="hljs-keyword">if</span>(msg.equals(<span class="hljs-string">&quot;exit&quot;</span>))&#123;...&#125;<br>    dos.writeUTF();<br>    dos.flush();<br>&#125;<br><span class="hljs-comment">// 4. 释放资源</span><br>socket.close();<br></code></pre></td></tr></table></figure><p><strong>服务端（接收）</strong></p><p>只要在读数据时用死循环即可</p></li></ul></li><li><h3 id="TCP同时接收多客户端消息❗"><a href="#TCP同时接收多客户端消息❗" class="headerlink" title="TCP同时接收多客户端消息❗"></a>TCP同时接收多客户端消息❗</h3><p> <strong>问题</strong>：上述所有的通信方法，服务端不能支持接收多个客户端的消息</p><p> <strong>思路</strong>：主线程不断接收客户端管道，每接收一个管道，便交由一个独立的子线程专门处理该管道的消息</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java">main&#123;<br>  <span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> ss.accept();<br>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerReader</span>(socket).start();<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServerReader</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123; <span class="hljs-comment">// Thread实现了Runnable，继承Thread相等于实现了Runnable</span><br>  <span class="hljs-keyword">private</span> Socket socket;<br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">ServerReader</span><span class="hljs-params">(Socket socket)</span>&#123;<br>      <span class="hljs-built_in">this</span>.socket = socket;<br>  &#125;<br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>      <span class="hljs-comment">// 读取管道的消息</span><br>      <span class="hljs-keyword">try</span>&#123;<br>          <span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> socket.getInputStream();<br>          <span class="hljs-type">DataInputStream</span> <span class="hljs-variable">dis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataInputStream</span>(is);<br>          <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>              <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> dis.readUTF();<br>          &#125;<br>      &#125; <span class="hljs-keyword">catch</span> (Exception e)&#123;<br>          e.printStackTrace();<br>          sout(<span class="hljs-string">&quot;服务端下线了&quot;</span>);<br>      &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p><strong>每次请求都开一个新线程，资源浪费，如何解决？</strong></p><p>短连接的业务场景，如B&#x2F;S架构，可以考虑使用线程池进行优化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ServerSocket</span> <span class="hljs-variable">ss</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span>(<span class="hljs-number">8080</span>);<br><span class="hljs-comment">// 创建线程池</span><br><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(corePoolSize:<span class="hljs-number">3</span>, maximumPoolSize:<span class="hljs-number">10</span>, keepAliveTime:<span class="hljs-number">10</span>, TimeUnit.SECONDS, <br>                                                <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="hljs-number">100</span>), Executors.defaultThreadFactory(), <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>.AbortPolicy());<br><span class="hljs-keyword">while</span>(True)&#123;<br>    <span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> ss.accept();<br>    <span class="hljs-comment">// 把客户端管道包装成一个任务交给线程池处理</span><br>    pool.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerReader</span>(socket));<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ol></li><li><h1 id="高级技术"><a href="#高级技术" class="headerlink" title="高级技术"></a>高级技术</h1><ul><li><h3 id="Junit单元测试"><a href="#Junit单元测试" class="headerlink" title="Junit单元测试"></a>Junit单元测试</h3><p>针对最小的功能单元：<strong>方法function</strong>，编写测试代码进行测试</p><p>为需要测试的业务类，定义对应的测试类，并为每个业务方法编写对应的<u>测试方法</u>（要求：public，无参，无返回值，@Test注解）<br>在测试方法中编写测试用例，要尽可能全面覆盖</p><p>做断言<code>Assert</code>​，对结果进行勘误</p></li><li><h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><ol><li><p><strong>定义</strong></p><p> <span data-type="text" style="color: var(--b3-font-color8);">加载类，并允许以编程的方式解剖类中的各种成分</span>（如成员变量&#x2F;方法&#x2F;构造器）</p></li><li><p><strong>步骤</strong></p><p> ① <strong>获取类对象</strong>​<strong>​<code>Class</code>​</strong>​<br>  <code>Class c1 = 类名.class</code>​<br>  调用Class提供的方法：<code>public static Class forName(String package)</code>​<br>  Object提供的方法：<code>public Class getClass(); Class c = 对象.getClass();</code>​<br> ② 获取类的<strong>构造器</strong>对象<code>Constructor</code>​<br>  <code>Constructor con = c1.</code>​<code>getDeclaredConstructor()</code>​​​​<br><br>   获取某类的构造器对象之后，可以拿构造器再创建对象，功能上等于Dog dog &#x3D; new Dog()，也就是<u>反射</u><br>  <code>Dog dog = (dog)con.newInstance()</code>​<br> ③ 获取类的<strong>成员变量</strong>对象<code>Field</code>​<br>  <code>Field[] fields = c1.</code>​<code>getDeclaredFields()</code>​​​​<br>   获取的成员变量对象可以为其设置值<code>，也可以获取值 field.set(dog, &quot;1&quot;)</code>​，<code>String hobby = (String)field.get(dog)</code>​<br> ④ 获取类的<strong>成员方法</strong>对象<code>Method</code>​<br> <code> Method[] methods = c1.</code>​<code>getDeclaredMethods()</code>​​​​<br>   <code>method.invoke(dog)</code>​</p></li><li><p><strong>如何应用</strong></p><p> 得到一个类的全部成分，并操作<br> 破坏封装性（暴力反射）<br> 绕过泛型的约束</p><p> <span data-type="text" style="color: var(--b3-font-color8);">适合做Java的框架，主流框架都会用反射设计功能</span></p></li></ol></li><li><h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><p>让调用程序根据注解信息来决定如何执行此程序</p><p>注解可以加在类、构造器、方法、成员变量、参数等上</p><ul><li><h5 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> 注解名 &#123;<br>  String <span class="hljs-title function_">str</span><span class="hljs-params">()</span>;<br>  <span class="hljs-type">int</span> <span class="hljs-title function_">age</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-number">10</span>;<br>  String[] address();<br>&#125;<br>@注解名<span class="hljs-number">1</span>(str=<span class="hljs-string">&quot;str&quot;</span>, age=<span class="hljs-number">1</span>, address=&#123;<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;&quot;</span>&#125;)<br><span class="hljs-comment">// value是一个特殊属性，使用时若只有一个value属性，则写注解时可以不写属性名</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> 注解名<span class="hljs-number">1</span> &#123;<br>  String <span class="hljs-title function_">value</span><span class="hljs-params">()</span>;<br>&#125;<br>@注解名<span class="hljs-number">1</span>(<span class="hljs-string">&quot;str&quot;</span>)<br></code></pre></td></tr></table></figure></li><li><h5 id="注解原理"><a href="#注解原理" class="headerlink" title="注解原理"></a>注解原理</h5><p>注解本身是一个接口，继承自<code>Annotation</code>​类，我们定义的注解成员，实际上是抽象方法</p></li><li><h5 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">@元注解<br>@元注解<br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> 注解()&#123;&#125;<br></code></pre></td></tr></table></figure><table><thead><tr><th>常见的元注解</th><th>说明</th></tr></thead><tbody><tr><td>@Target(ElementType.xx)</td><td>声明被修饰的注解能在哪些位置生效<br />1. TYPE ，类 &#x2F; 接口<br />2. FIELD ，成员变量<br />3. METHOD ，成员方法<br />4. PARAMETER，方法参数<br />5. CONSTRUCTOR，构造器<br />6. LOCAL_VARIABLE，局部变量</td></tr><tr><td>@Retention(RetentionPolicy.xx)</td><td>声明注解的保留周期<br />1. SOURCE ，作用在源码阶段，字节码中不存在<br />2. CLASS，默认值，作用在字节码中，run时不存在<br />3. RUNTIME，一直保留到运行阶段（常用）</td></tr></tbody></table></li><li><h5 id="注解解析"><a href="#注解解析" class="headerlink" title="注解解析"></a>注解解析</h5><p>判断类、方法、成员变量上是否有注解，并把注解内容解析</p><p>先用反射获得Class对象，，因为反射对象都实现了<code>AnnotationElement</code>​接口，所以他们都有解析注解的能力</p><table><thead><tr><th>​<code>AnnotationElement</code>​接口</th><th>说明</th></tr></thead><tbody><tr><td>public Annotation[] getDeclaredAnnotations()</td><td>获取当前对象上的注解</td></tr><tr><td>public T getDeclaredAnnotation(Class<T> annotationClass)</td><td>获取指定的注解对象</td></tr><tr><td>public boolean isAnnotationPresent(Class<Annotatio> annotationClass)</td><td>判断当前对象上是否存在某个注解</td></tr></tbody></table></li></ul></li><li><h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><p>动态代理是一种设计模式</p><p><strong>代理</strong><br>对象实现的任务太多，可以通过代理转移部分功能<br>代理通过实现接口来获得被代理对象的功能<br>​<code>java.lang.reflect.proxy</code>​类提供了为对象生成代理的方法 ↓<br><span data-type="text" style="color: var(--b3-font-color8);">public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)</span><br><span data-type="text" style="color: var(--b3-font-color8);">参数一：指定类加载器，加载生成的代理类<br>参数二：指定接口，用于指定生成的代理有哪些方法<br>参数三：指定生成对象的功能</span></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">starservice</span>()&#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">sing</span><span class="hljs-params">(String name)</span>;<br>    String <span class="hljs-title function_">dance</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">star</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">starservice</span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sing</span><span class="hljs-params">(String name)</span>&#123;<br>        <span class="hljs-string">&quot;啦啦啦～&quot;</span>.sout;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dance</span><span class="hljs-params">(String name)</span>&#123;<br>        <span class="hljs-string">&quot;跳～&quot;</span>.sout;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProxyUtil</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> starservice <span class="hljs-title function_">createProxy</span><span class="hljs-params">(star s)</span>&#123;<br>        <span class="hljs-type">starservice</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> (starservice)Proxy.newProxyInstance(<br>                                            ProxyUtil.class.getClassLoader(),<br>                                            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;starservice.class&#125;或者s.getClass().getInterfaces(),<br>                                            <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvocationHandler</span>()&#123;<br>                                            <span class="hljs-meta">@Override</span> <br>                                            <span class="hljs-keyword">public</span> Obejcet <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable&#123;<br>                                                <span class="hljs-comment">// 参数1：proxy接收到的对象本身</span><br>                                                <span class="hljs-comment">// 参数2：method代表正在被代理的方法 sing/dance</span><br>                                                <span class="hljs-comment">// 参数3：args代表正在被代理方法的参数</span><br>                                                <span class="hljs-type">String</span> <span class="hljs-variable">methodName</span> <span class="hljs-operator">=</span> method.getName();<br>                                                <span class="hljs-comment">// 代理功能</span><br>                                                <span class="hljs-keyword">if</span>(<span class="hljs-string">&quot;sing&quot;</span>.equals(methodName))&#123;...&#125;<br>                                                <span class="hljs-comment">// 原对象功能</span><br>                                                <span class="hljs-type">Object</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> method.invoke(s, args);<br>                                                <span class="hljs-keyword">return</span> res;<br>                                            &#125;<br>                            &#125;);<br>        <span class="hljs-keyword">return</span> proxy;<br>    &#125;<br>&#125;<br><br>main&#123;<br>    <span class="hljs-type">Star</span> <span class="hljs-variable">star</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Star</span>(<span class="hljs-string">&quot;刘德华&quot;</span>);<br>    <span class="hljs-comment">// 创建代理对象</span><br>    <span class="hljs-type">starservice</span> <span class="hljs-variable">star</span> <span class="hljs-operator">=</span> ProxyUtil.createProxy(star);<br>    <span class="hljs-comment">// 代理对象proxy底层会调用重写的invoke方法</span><br>    proxy.sing(<span class="hljs-string">&quot;歌名&quot;</span>);<br>    proxy.dance();<br>&#125;<br></code></pre></td></tr></table></figure><p>‍</p></li></ul></li></ul><p>‍</p>]]></content>
    
    
    <categories>
      
      <category>开发技术</category>
      
      <category>后端开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发技术</tag>
      
      <tag>笔记</tag>
      
      <tag>后端</tag>
      
      <tag>更新中</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>调制识别HOM去噪方法</title>
    <link href="/2025/05/24/%E8%B0%83%E5%88%B6%E8%AF%86%E5%88%ABHOM%E5%8E%BB%E5%99%AA%E6%96%B9%E6%B3%95/"/>
    <url>/2025/05/24/%E8%B0%83%E5%88%B6%E8%AF%86%E5%88%ABHOM%E5%8E%BB%E5%99%AA%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>本文章复现的是<a href="https://ieeexplore.ieee.org/author/37086426257">Sofiane Kharbech</a>等，于2020年在IEEE Wireless Communications Letters发表的论文<a href="https://ieeexplore.ieee.org/document/8968406">《Denoising Higher-Order Moments for Blind Digital Modulation Identification in Multiple-Antenna Systems》</a>（多天线系统中数字调制盲识别的高阶矩去噪方法）</p><span id="more"></span><h3 id="论文复现"><a href="#论文复现" class="headerlink" title="论文复现"></a>论文复现</h3><p>本文章复现的是<a href="https://ieeexplore.ieee.org/author/37086426257">Sofiane Kharbech</a>等，于2020年在IEEE Wireless Communications Letters发表的论文<a href="https://ieeexplore.ieee.org/document/8968406">《Denoising Higher-Order Moments for Blind Digital Modulation Identification in Multiple-Antenna Systems》</a>（多天线系统中数字调制盲识别的高阶矩去噪方法）</p><p>首先编码三个函数文件，分别实现：</p><ol><li><p><code>f_HOS_Extraction.m</code><br> 从接收信号中提取高阶统计量（HOS）</p> <figure class="highlight m"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs m">function HOS<span class="hljs-built_in">=</span>f_HOS_Extraction(M,SNR,K,Nt,Nr,pbee,cfo,phznoise)<br>switch M<br>   case <span class="hljs-number">1</span><br>      x <span class="hljs-built_in">=</span> randi([<span class="hljs-number">0</span>,<span class="hljs-number">1</span>],<span class="hljs-number">1</span>,Nt*K);<br>      x_mod <span class="hljs-built_in">=</span> pskmod(x,<span class="hljs-number">2</span>);<br>   case <span class="hljs-number">2</span><br>      x <span class="hljs-built_in">=</span> randi([<span class="hljs-number">0</span>,<span class="hljs-number">3</span>],<span class="hljs-number">1</span>,Nt*K);<br>      x_mod <span class="hljs-built_in">=</span> pskmod(x,<span class="hljs-number">4</span>);<br>   case <span class="hljs-number">3</span><br>      x <span class="hljs-built_in">=</span> randi([<span class="hljs-number">0</span>,<span class="hljs-number">7</span>],<span class="hljs-number">1</span>,Nt*K);<br>      x_mod <span class="hljs-built_in">=</span> pskmod(x,<span class="hljs-number">8</span>);<br>   case <span class="hljs-number">4</span><br>      x <span class="hljs-built_in">=</span> randi([<span class="hljs-number">0</span>,<span class="hljs-number">3</span>],<span class="hljs-number">1</span>,Nt*K);<br>      x_mod <span class="hljs-built_in">=</span> pammod(x,<span class="hljs-number">4</span>);<br>   case <span class="hljs-number">5</span><br>      x <span class="hljs-built_in">=</span> randi([<span class="hljs-number">0</span>,<span class="hljs-number">7</span>],<span class="hljs-number">1</span>,Nt*K);<br>      x_mod <span class="hljs-built_in">=</span> pammod(x,<span class="hljs-number">8</span>);<br>   case <span class="hljs-number">6</span><br>      x <span class="hljs-built_in">=</span> randi([<span class="hljs-number">0</span>,<span class="hljs-number">15</span>],<span class="hljs-number">1</span>,Nt*K);<br>      x_mod <span class="hljs-built_in">=</span> qammod(x,<span class="hljs-number">16</span>);<br>   otherwise<br>      disp(<span class="hljs-string">&#x27;Unknown modulation type&#x27;</span>);<br>end<br>scale <span class="hljs-built_in">=</span> modnorm(x_mod,<span class="hljs-string">&#x27;avpow&#x27;</span>,<span class="hljs-number">1</span>);   <span class="hljs-comment">% scaling factor</span><br>x_mod <span class="hljs-built_in">=</span> x_mod*scale;                <span class="hljs-comment">% scaling avg. power to 1W</span><br><span class="hljs-comment">%------------------------------------------------&gt; Channel (MIMO + AWGN)</span><br>H <span class="hljs-built_in">=</span> randn(Nr,Nt)+<span class="hljs-number">1</span>i*randn(Nr,Nt);<br>y_mimo <span class="hljs-built_in">=</span> H*reshape(x_mod,Nt,[]);<br>cfo_mat <span class="hljs-built_in">=</span> repmat(exp(<span class="hljs-number">2</span>i*pi*(<span class="hljs-number">1</span>:<span class="hljs-number">1</span>:K)*cfo),Nr,<span class="hljs-number">1</span>);<br>y_mimo <span class="hljs-built_in">=</span> y_mimo.*cfo_mat;<br><span class="hljs-built_in">if</span> phznoise ~<span class="hljs-built_in">=</span><span class="hljs-number">0</span><br>   for cptNr<span class="hljs-built_in">=</span><span class="hljs-number">1</span>:Nr<br>       y_mimo(cptNr,:) <span class="hljs-built_in">=</span> phznoise(y_mimo(cptNr,:).<span class="hljs-string">&#x27;).&#x27;</span>;<br>   end<br>end<br>y_mimo_SNR <span class="hljs-built_in">=</span> awgn(y_mimo,SNR,<span class="hljs-string">&#x27;measured&#x27;</span>);<br>Pb <span class="hljs-built_in">=</span> mean(abs(reshape(y_mimo_SNR-y_mimo,<span class="hljs-number">1</span>,[]).^<span class="hljs-number">2</span>)) + pbee; <span class="hljs-comment">% noise power</span><br><br>R <span class="hljs-built_in">=</span> mean(real(x_mod).^<span class="hljs-number">4</span>) / mean(real(x_mod).^<span class="hljs-number">2</span>);<br>[W,yeg] <span class="hljs-built_in">=</span> f_SCMA(Nt,Nr,y_mimo_SNR,R);<br>Pbf <span class="hljs-built_in">=</span> Pb*W.<span class="hljs-string">&#x27;*conj(W); % power of the filtered noise</span><br><span class="hljs-string"></span><br><span class="hljs-string">% bf = W.&#x27;</span>*(y_mimo_SNR-y_mimo)  <span class="hljs-comment">% fchk</span><br><span class="hljs-comment">% mean(abs(bf(1,:).^2))         % fchk</span><br><br><span class="hljs-comment">%----&gt; HOS extraction</span><br><br>for cpt<span class="hljs-built_in">=</span><span class="hljs-number">1</span>:Nt<br>    HOS(cpt,:) <span class="hljs-built_in">=</span> f_CalcHOS(yeg(cpt,:),Pbf(cpt,cpt));<br>end<br><br></code></pre></td></tr></table></figure></li><li><p><code>f_CalcHOS.m</code><br> 该函数计算输入信号的各种高阶矩和累积量。它计算矩，如m20， m40, m60，以及累积量，如c40， c60等。</p> <figure class="highlight m"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs m"><span class="hljs-comment">% x  : the signal</span><br><span class="hljs-comment">% Pb : the noise power</span><br>function hos<span class="hljs-built_in">=</span>f_CalcHOS(x, Pb)<br>x<span class="hljs-built_in">=</span>x-mean(x);<br><br>m20<span class="hljs-built_in">=</span>real(mean(x.^<span class="hljs-number">2</span>));<br>m22<span class="hljs-built_in">=</span>real(mean(conj(x).^<span class="hljs-number">2</span>));<br>m40<span class="hljs-built_in">=</span>real(mean(x.^<span class="hljs-number">4</span>));<br>m60<span class="hljs-built_in">=</span>real(mean(x.^<span class="hljs-number">6</span>));<br><br>m21y<span class="hljs-built_in">=</span>real(mean(x.*(conj(x))));<br>m41y<span class="hljs-built_in">=</span>real(mean((x.^<span class="hljs-number">3</span>).*(conj(x))));<br>m42y<span class="hljs-built_in">=</span>real(mean((x.^<span class="hljs-number">2</span>).*(conj(x).^<span class="hljs-number">2</span>)));<br>m43y<span class="hljs-built_in">=</span>real(mean(x.*(conj(x).^<span class="hljs-number">3</span>)));<br>m61y<span class="hljs-built_in">=</span>real(mean((x.^<span class="hljs-number">5</span>).*(conj(x))));<br>m62y<span class="hljs-built_in">=</span>real(mean((x.^<span class="hljs-number">4</span>).*(conj(x).^<span class="hljs-number">2</span>)));<br>m63y<span class="hljs-built_in">=</span>real(mean((x.^<span class="hljs-number">3</span>).*(conj(x).^<span class="hljs-number">3</span>)));<br>m84y<span class="hljs-built_in">=</span>real(mean((x.^<span class="hljs-number">4</span>).*(conj(x).^<span class="hljs-number">4</span>)));<br><br><span class="hljs-comment">% denoising</span><br>m21<span class="hljs-built_in">=</span>m21y-Pb;<br>m41<span class="hljs-built_in">=</span>m41y-<span class="hljs-number">3</span>*m20*Pb;<br>m42<span class="hljs-built_in">=</span>m42y-<span class="hljs-number">2</span>*Pb^<span class="hljs-number">2</span>-<span class="hljs-number">4</span>*Pb*m21;<br>m43<span class="hljs-built_in">=</span>m43y-<span class="hljs-number">3</span>*m22*Pb;<br>m61<span class="hljs-built_in">=</span>m61y-<span class="hljs-number">5</span>*m40*Pb;<br>m62<span class="hljs-built_in">=</span>m62y-<span class="hljs-number">12</span>*m20*Pb^<span class="hljs-number">2</span>-<span class="hljs-number">8</span>*m41*Pb;<br>m63<span class="hljs-built_in">=</span>m63y-<span class="hljs-number">18</span>*m21*Pb^<span class="hljs-number">2</span>-<span class="hljs-number">9</span>*m42*Pb-<span class="hljs-number">6</span>*Pb^<span class="hljs-number">3</span>;<br>m84<span class="hljs-built_in">=</span>m84y-<span class="hljs-number">16</span>*m63*Pb-<span class="hljs-number">72</span>*m42*Pb^<span class="hljs-number">2</span>-<span class="hljs-number">96</span>*m21*Pb^<span class="hljs-number">3</span>-<span class="hljs-number">24</span>*Pb^<span class="hljs-number">4</span>;<br><br><span class="hljs-comment">%--------------------------&gt; Cumulants &lt;--------------------------%</span><br><br>c40<span class="hljs-built_in">=</span>m40-<span class="hljs-number">3</span>*(m20.^<span class="hljs-number">2</span>);<br>c60<span class="hljs-built_in">=</span>m60-<span class="hljs-number">15</span>*m20*m40+<span class="hljs-number">30</span>*(m20.^<span class="hljs-number">3</span>);<br><br>c41<span class="hljs-built_in">=</span>m41-<span class="hljs-number">3</span>*m20*m21;<br>c42<span class="hljs-built_in">=</span>m42-(abs(m20).^<span class="hljs-number">2</span>)-<span class="hljs-number">2</span>*(m21.^<span class="hljs-number">2</span>);<br>c61<span class="hljs-built_in">=</span>m61-<span class="hljs-number">5</span>*m21*m40-<span class="hljs-number">10</span>*m20*m41+<span class="hljs-number">30</span>*m21*(m20.^<span class="hljs-number">2</span>);<br>c62<span class="hljs-built_in">=</span>m62-<span class="hljs-number">6</span>*m42*m20-<span class="hljs-number">8</span>*m21*m41-m22*m40+<span class="hljs-number">6</span>*m22*m20^<span class="hljs-number">2</span>+<span class="hljs-number">24</span>*m20*m21^<span class="hljs-number">2</span>;<br>c63<span class="hljs-built_in">=</span>m63-<span class="hljs-number">9</span>*m42*m21+<span class="hljs-number">12</span>*(m21.^<span class="hljs-number">3</span>)-<span class="hljs-number">3</span>*m20*m43-<span class="hljs-number">3</span>*m22*m41+<span class="hljs-number">18</span>*m20*m21*m22;<br><br><span class="hljs-comment">%--------------------------&gt; Normalization &lt;--------------------------%</span><br><br>m40_n<span class="hljs-built_in">=</span>m40/m21^<span class="hljs-number">2</span>;<br>m41_n<span class="hljs-built_in">=</span>m41/m21^<span class="hljs-number">2</span>;<br>m42_n<span class="hljs-built_in">=</span>m42/m21^<span class="hljs-number">2</span>;<br>m60_n<span class="hljs-built_in">=</span>m60/m21^<span class="hljs-number">3</span>;<br>m61_n<span class="hljs-built_in">=</span>m61/m21^<span class="hljs-number">3</span>;<br>m62_n<span class="hljs-built_in">=</span>m62/m21^<span class="hljs-number">3</span>;<br>m63_n<span class="hljs-built_in">=</span>m63/m21^<span class="hljs-number">3</span>;<br>m84_n<span class="hljs-built_in">=</span>m84/m21^<span class="hljs-number">4</span>;<br><br>c40_n<span class="hljs-built_in">=</span>c40/m21^<span class="hljs-number">2</span>;<br>c41_n<span class="hljs-built_in">=</span>c41/m21^<span class="hljs-number">2</span>;<br>c42_n<span class="hljs-built_in">=</span>c42/m21^<span class="hljs-number">2</span>;<br>c60_n<span class="hljs-built_in">=</span>c60/m21^<span class="hljs-number">3</span>;<br>c61_n<span class="hljs-built_in">=</span>c61/m21^<span class="hljs-number">3</span>;<br>c62_n<span class="hljs-built_in">=</span>c62/m21^<span class="hljs-number">3</span>;<br>c63_n<span class="hljs-built_in">=</span>c63/m21^<span class="hljs-number">3</span>;<br><br>m41y_n<span class="hljs-built_in">=</span>m41y/m21y^<span class="hljs-number">2</span>;<br>m42y_n<span class="hljs-built_in">=</span>m42y/m21y^<span class="hljs-number">2</span>;<br>m61y_n<span class="hljs-built_in">=</span>m61y/m21y^<span class="hljs-number">3</span>;<br>m62y_n<span class="hljs-built_in">=</span>m62y/m21y^<span class="hljs-number">3</span>;<br>m63y_n<span class="hljs-built_in">=</span>m63y/m21y^<span class="hljs-number">3</span>;<br>m84y_n<span class="hljs-built_in">=</span>m84y/m21y^<span class="hljs-number">4</span>;<br><br>hos<span class="hljs-built_in">=</span>real([m40_n m41_n m41y_n m42_n m42y_n m60_n m61_n m61y_n m62_n m62y_n m63_n m63y_n m84_n m84y_n ...<br>          c40_n c41_n c42_n c60_n c61_n c62_n c63_n]);<br></code></pre></td></tr></table></figure></li><li><p><code>f_SCMA.m</code><br> 该函数为MIMO系统执行信号盲源分离（BSS）。利用提取的信号特征和噪声特征，对接收信号进行白化变换，然后利用随机梯度下降（SGD）估计BSS的分离矩阵W。</p> <figure class="highlight m"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs m">function [G,yeg]<span class="hljs-built_in">=</span>f_SCMA(Nt,Nr,y_mimo_SNR,R)<br><span class="hljs-comment">%----------------------------------&gt; Pre-processing: batch whitening</span><br>Ry <span class="hljs-built_in">=</span> (y_mimo_SNR*y_mimo_SNR<span class="hljs-string">&#x27;)/size(y_mimo_SNR,2);</span><br><span class="hljs-string">[U,SIG] = eig(Ry);                          % Eigendecomposition</span><br><span class="hljs-string">SIG = SIG(Nr:-1:(Nr-Nt+1),Nr:-1:(Nr-Nt+1)); % Required condition: Nr&gt;=Nt</span><br><span class="hljs-string">U = U(:,Nr:-1:(Nr-Nt+1));</span><br><span class="hljs-string">B = (SIG^-0.5)*U&#x27;</span>; <span class="hljs-comment">% Whitening matrix</span><br>YW <span class="hljs-built_in">=</span> B*y_mimo_SNR; <span class="hljs-comment">% Whited signals</span><br><br><span class="hljs-comment">%----------------------------------&gt; Estimating the separator W    </span><br>W <span class="hljs-built_in">=</span> eye(Nt);                       <span class="hljs-comment">% Initialization</span><br><span class="hljs-comment">% W = toeplitz(1:Nt);</span><br><span class="hljs-comment">% W = toeplitz(1:Nr,1:Nt);</span><br>mu<span class="hljs-built_in">=</span><span class="hljs-number">1</span>e-<span class="hljs-number">2</span>;                           <span class="hljs-comment">% Step size</span><br><span class="hljs-comment">% mu=5e-3;</span><br>for ns<span class="hljs-built_in">=</span><span class="hljs-number">1</span>:size(YW,<span class="hljs-number">2</span>)                <span class="hljs-comment">% Stochastic gradient descent (SGD)</span><br>    YW_ns <span class="hljs-built_in">=</span> YW(:,ns);<br>    z_ns <span class="hljs-built_in">=</span> W.<span class="hljs-string">&#x27;*YW_ns;</span><br><span class="hljs-string">    for n=1:Nt</span><br><span class="hljs-string">        e = (real(z_ns(n)).^2-R).*real(z_ns(n));</span><br><span class="hljs-string">        W(:,n) = W(:,n)-mu.*e.*conj(YW_ns);</span><br><span class="hljs-string">    end</span><br><span class="hljs-string">    W = f_GramSchmidt(W); % Post-processing: orthonormalization</span><br><span class="hljs-string">end</span><br><span class="hljs-string"></span><br><span class="hljs-string">%----------------------------------&gt; Applying BSS</span><br><span class="hljs-string">yeg = W.&#x27;</span>*YW;<br>G <span class="hljs-built_in">=</span> B.<span class="hljs-string">&#x27;*W;</span><br><span class="hljs-string">function Q = f_GramSchmidt(W)</span><br><span class="hljs-string">Q = zeros(size(W));</span><br><span class="hljs-string">Q(:,1) = W(:,1)/norm(W(:,1));</span><br><span class="hljs-string">for i=2:size(W,2)</span><br><span class="hljs-string">    s_proj = 0;</span><br><span class="hljs-string">    for j=1:i-1</span><br><span class="hljs-string">        s_proj = s_proj+((Q(:,j)&#x27;</span>*W(:,i))/(Q(:,j)<span class="hljs-string">&#x27;*Q(:,j)))*Q(:,j);</span><br><span class="hljs-string">    end</span><br><span class="hljs-string">    e = W(:,i)-s_proj;</span><br><span class="hljs-string">    Q(:,i) = e/norm(e);</span><br><span class="hljs-string">end</span><br></code></pre></td></tr></table></figure></li></ol><p>随后，我们需要生成高阶统计（HOS）特征的数据集。模拟各种调制方案下的MIMO传输，计算每个传输信号的HOS特征，并将数据组织成矩阵。生成的数据集是一个三维矩阵（mat_HOS），形状为&#x3D;&#x3D;特征向量 × 样本指标 × MIMO系统的天线指标&#x3D;&#x3D;。</p><figure class="highlight m"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs m"><span class="hljs-comment">% 1) 本文件用于生成指定数字调制方式和传输配置的高阶统计量(HOS)数据集</span><br><span class="hljs-comment">% 2) 生成的数据集名为&#x27;mat_HOS&#x27;，为三维矩阵：</span><br><span class="hljs-comment">%    - 第一维：HOS向量（特征维度）</span><br><span class="hljs-comment">%    - 第二维：样本索引（HOS向量编号）</span><br><span class="hljs-comment">%    - 第三维：天线编号（MIMO系统接收天线）</span><br><span class="hljs-comment">% 3) 若&#x27;rng shuffle&#x27;不可用，使用以下替代方案：</span><br><span class="hljs-comment">% clk=clock;</span><br><span class="hljs-comment">% RandStream.setGlobalStream(RandStream(&#x27;mt19937ar&#x27;,&#x27;Seed&#x27;,str2num(strrep(num2str(clk(4:6)),&#x27; &#x27;,&#x27;&#x27;))*1e3));</span><br><span class="hljs-comment">% 4) 若未自动启用并行处理，执行以下操作：</span><br><span class="hljs-comment">% parpool(&#x27;local&#x27;,3)        % 启动3个本地工作进程</span><br><span class="hljs-comment">% Linux系统可能需要先运行：</span><br><span class="hljs-comment">% ! sudo chmod -R 777 /home/user_name/.matlab/local_cluster_jobs/R2017a</span><br><span class="hljs-comment">% 注：若无并行计算工具箱，需将最内层循环的parfor改为for</span><br><span class="hljs-comment">% 5) 运行结束后保存工作区：</span><br><span class="hljs-comment">% 需保留所有变量，供DetectionResults.m生成结果</span><br>rng shuffle<br>clc<br>clear<br><span class="hljs-comment">%--------------------------------------------&gt; Parameters</span><br>Nt <span class="hljs-built_in">=</span> <span class="hljs-number">2</span>;    <span class="hljs-comment">% 发射天线数量</span><br>Nr <span class="hljs-built_in">=</span> <span class="hljs-number">6</span>;    <span class="hljs-comment">% 接收天线数量</span><br>K <span class="hljs-built_in">=</span> <span class="hljs-number">4000</span>;  <span class="hljs-comment">% 传输的MIMO符号数量</span><br>M <span class="hljs-built_in">=</span> [<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span>]; <span class="hljs-comment">% 调制类型索引（对应不同调制方式）, cf. &#x27;f_HOS_Extraction.m&#x27; for the names</span><br><span class="hljs-comment">% M = [1 2 3];</span><br>SNR <span class="hljs-built_in">=</span> -<span class="hljs-number">2</span>:<span class="hljs-number">1</span>:<span class="hljs-number">15</span>;     <span class="hljs-comment">% 信噪比范围（-2dB到15dB）</span><br>lMC <span class="hljs-built_in">=</span> <span class="hljs-number">2000</span>;        <span class="hljs-comment">% 蒙特卡洛模拟次数</span><br>eestd <span class="hljs-built_in">=</span> <span class="hljs-number">0</span>;         <span class="hljs-comment">% 噪声功率估计误差标准差</span><br>cfo <span class="hljs-built_in">=</span> <span class="hljs-number">0</span>;           <span class="hljs-comment">% 载波频率偏移</span><br><span class="hljs-comment">% cfo = 1e-4;</span><br>phznoise <span class="hljs-built_in">=</span> <span class="hljs-number">0</span>;      <span class="hljs-comment">% 相位噪声模型</span><br><span class="hljs-comment">% phznoise = comm.PhaseNoise(&#x27;Level&#x27;,-3,&#x27;FrequencyOffset&#x27;,2e-3,&#x27;SampleRate&#x27;,1);</span><br><br><span class="hljs-comment">%--------------------------------------------&gt; Main processing</span><br>mat_HOS <span class="hljs-built_in">=</span> []; <span class="hljs-comment">% HOS特征（特征×样本×天线）</span><br>for cptSNR<span class="hljs-built_in">=</span><span class="hljs-number">1</span>:length(SNR)<br>    for cptM<span class="hljs-built_in">=</span><span class="hljs-number">1</span>:length(M)<br>        Pb_ee <span class="hljs-built_in">=</span> eestd*randn(<span class="hljs-number">1</span>,lMC);<br>        parfor cptMC<span class="hljs-built_in">=</span><span class="hljs-number">1</span>:lMC<br>            <span class="hljs-comment">% 特征提取函数</span><br>            HOS <span class="hljs-built_in">=</span> f_HOS_Extraction(M(cptM),SNR(cptSNR),K,Nt,Nr,Pb_ee(cptMC),cfo,phznoise);<br>            <span class="hljs-comment">% 拼接特征矩阵（第三维为天线，第二维为样本）</span><br>            mat_HOS <span class="hljs-built_in">=</span> [mat_HOS; permute(HOS,[<span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span>])];    <br>        end<br>        disp([<span class="hljs-string">&#x27;M = &#x27;</span> num2str(M(cptM)) <span class="hljs-string">&#x27; completed.&#x27;</span>])       <br>    end<br>end<br>mat_HOS <span class="hljs-built_in">=</span> permute(mat_HOS,[<span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span>]);<span class="hljs-comment">% 调整维度为[特征数×样本数×天线数]</span><br>clearvars -except M SNR Nt Nr lMC mat_HOS<br></code></pre></td></tr></table></figure><p>最后，我们使用HOS数据集（mat_HOS）根据计算的特征对调制类型进行分类。它通过绘制正确识别概率（PCI）作为信噪比的函数来评估调制识别的性能。</p><figure class="highlight m"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs m"><span class="hljs-comment">% 1) 本文件用于绘制特定场景下正确识别概率（PCI）随信噪比（SNR）变化曲线</span><br><span class="hljs-comment">% 2) 支持三种特征组合场景：</span><br><span class="hljs-comment">%    - &#x27;仅使用高阶累积量（HOC）&#x27;</span><br><span class="hljs-comment">%    - &#x27;HOC + 未去噪高阶矩（HOM）&#x27;</span><br><span class="hljs-comment">%    - &#x27;HOC + 去噪后HOM&#x27;</span><br><span class="hljs-comment">% 3) 运行前需加载&#x27;GenDataset.m&#x27;生成的所有变量</span><br>HOSth <span class="hljs-built_in">=</span> &#123; <span class="hljs-comment">% Theoretical HOS值，对应论文表2</span><br><span class="hljs-string">&#x27;   &#x27;</span>  <span class="hljs-string">&#x27;B-PSK&#x27;</span> <span class="hljs-string">&#x27;Q-PSK&#x27;</span> <span class="hljs-string">&#x27;8-PSK&#x27;</span> <span class="hljs-string">&#x27;4-ASK&#x27;</span> <span class="hljs-string">&#x27;8-ASK&#x27;</span> <span class="hljs-string">&#x27;16-QAM&#x27;</span>    ;<br><span class="hljs-string">&#x27;M40&#x27;</span>    <span class="hljs-number">1</span>      -<span class="hljs-number">1</span>       <span class="hljs-number">0</span>       <span class="hljs-number">1.64</span>    <span class="hljs-number">1.77</span>    -<span class="hljs-number">0.67</span>     ;<br><span class="hljs-string">&#x27;M41&#x27;</span>    <span class="hljs-number">1</span>       <span class="hljs-number">0</span>       <span class="hljs-number">0</span>       <span class="hljs-number">1.64</span>    <span class="hljs-number">1.77</span>     <span class="hljs-number">0</span>        ;<br><span class="hljs-string">&#x27;M42&#x27;</span>    <span class="hljs-number">1</span>       <span class="hljs-number">1</span>       <span class="hljs-number">1</span>       <span class="hljs-number">1.64</span>    <span class="hljs-number">1.77</span>     <span class="hljs-number">1.32</span>     ;<br><span class="hljs-string">&#x27;M60&#x27;</span>    <span class="hljs-number">1</span>       <span class="hljs-number">0</span>       <span class="hljs-number">0</span>       <span class="hljs-number">2.92</span>    <span class="hljs-number">3.62</span>     <span class="hljs-number">0</span>        ;<br><span class="hljs-string">&#x27;M61&#x27;</span>    <span class="hljs-number">1</span>      -<span class="hljs-number">1</span>       <span class="hljs-number">0</span>       <span class="hljs-number">2.92</span>    <span class="hljs-number">3.62</span>    -<span class="hljs-number">1.32</span>     ;<br><span class="hljs-string">&#x27;M62&#x27;</span>    <span class="hljs-number">1</span>       <span class="hljs-number">0</span>       <span class="hljs-number">0</span>       <span class="hljs-number">2.92</span>    <span class="hljs-number">3.62</span>     <span class="hljs-number">0</span>        ;<br><span class="hljs-string">&#x27;M63&#x27;</span>    <span class="hljs-number">1</span>       <span class="hljs-number">1</span>       <span class="hljs-number">1</span>       <span class="hljs-number">2.92</span>    <span class="hljs-number">3.62</span>     <span class="hljs-number">1.96</span>     ;<br><span class="hljs-string">&#x27;M84&#x27;</span>    <span class="hljs-number">1</span>       <span class="hljs-number">1</span>       <span class="hljs-number">1</span>       <span class="hljs-number">5.25</span>    <span class="hljs-number">7.92</span>     <span class="hljs-number">3.12</span>     ;<br><span class="hljs-string">&#x27;C40&#x27;</span>   -<span class="hljs-number">2</span>      -<span class="hljs-number">1</span>       <span class="hljs-number">0</span>      -<span class="hljs-number">1.36</span>   -<span class="hljs-number">1.42</span>    -<span class="hljs-number">0.68</span>     ;<br><span class="hljs-string">&#x27;C41&#x27;</span>   -<span class="hljs-number">2</span>       <span class="hljs-number">0</span>       <span class="hljs-number">0</span>      -<span class="hljs-number">1.36</span>   -<span class="hljs-number">1.42</span>     <span class="hljs-number">0</span>        ;<br><span class="hljs-string">&#x27;C42&#x27;</span>   -<span class="hljs-number">2</span>      -<span class="hljs-number">1</span>      -<span class="hljs-number">1</span>      -<span class="hljs-number">1.36</span>   -<span class="hljs-number">1.42</span>    -<span class="hljs-number">0.68</span>     ;<br><span class="hljs-string">&#x27;C60&#x27;</span>    <span class="hljs-number">16</span>      <span class="hljs-number">0</span>       <span class="hljs-number">0</span>       <span class="hljs-number">8.32</span>    <span class="hljs-number">7.19</span>     <span class="hljs-number">0</span>        ;<br><span class="hljs-string">&#x27;C61&#x27;</span>    <span class="hljs-number">16</span>      <span class="hljs-number">4</span>       <span class="hljs-number">0</span>       <span class="hljs-number">8.32</span>    <span class="hljs-number">7.19</span>     <span class="hljs-number">2.08</span>     ;<br><span class="hljs-string">&#x27;C62&#x27;</span>    <span class="hljs-number">16</span>      <span class="hljs-number">0</span>       <span class="hljs-number">0</span>       <span class="hljs-number">8.32</span>    <span class="hljs-number">7.19</span>     <span class="hljs-number">0</span>        ;<br><span class="hljs-string">&#x27;C63&#x27;</span>    <span class="hljs-number">16</span>      <span class="hljs-number">4</span>       <span class="hljs-number">4</span>       <span class="hljs-number">8.32</span>    <span class="hljs-number">7.19</span>     <span class="hljs-number">2.08</span>     ;<br>&#125;;<br>HOSth <span class="hljs-built_in">=</span> cell2mat(HOSth(<span class="hljs-number">2</span>:end,<span class="hljs-number">2</span>:end));<br>lSNR <span class="hljs-built_in">=</span> length(SNR); <span class="hljs-comment">% SNR点数</span><br>lM <span class="hljs-built_in">=</span> length(M); <span class="hljs-comment">% 调制类型数</span><br>lMMC <span class="hljs-built_in">=</span> lM*lMC; <span class="hljs-comment">% 总样本数 = 调制类型数*蒙特卡洛次数</span><br>stat <span class="hljs-built_in">=</span> zeros(<span class="hljs-number">4</span>+Nt,lSNR*lMMC); <span class="hljs-comment">% 统计矩阵初始化</span><br>count <span class="hljs-built_in">=</span> <span class="hljs-number">1</span>;<br>for cptSNR<span class="hljs-built_in">=</span><span class="hljs-number">1</span>:lSNR<br>    for cptM<span class="hljs-built_in">=</span><span class="hljs-number">1</span>:lM<br>        for cptMC<span class="hljs-built_in">=</span><span class="hljs-number">1</span>:lMC           <br>            stat(<span class="hljs-number">1</span>,count) <span class="hljs-built_in">=</span> SNR(cptSNR);<span class="hljs-comment">% 记录SNR</span><br>            stat(<span class="hljs-number">2</span>,count) <span class="hljs-built_in">=</span> M(cptM); <span class="hljs-comment">% 记录真实调制索引</span><br>            count <span class="hljs-built_in">=</span> count+<span class="hljs-number">1</span>;      <br>        end<br>    end<br>end<br><span class="hljs-comment">%% 下面的代码使用那种方式就取消注释哪种方式即可</span><br><span class="hljs-comment">% HOSth = HOSth(9:end,:);        % &#x27;HOC only&#x27;时取消注释</span><br>for cptNt<span class="hljs-built_in">=</span><span class="hljs-number">1</span>:Nt<br>    <span class="hljs-comment">% HOC only</span><br>    <span class="hljs-comment">%mat_HOS_cptNt = mat_HOS(15:end,:,cptNt);</span><br>    <span class="hljs-comment">% HOC + 未去噪HOM</span><br>    mat_HOS_cptNt <span class="hljs-built_in">=</span> mat_HOS([<span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">8</span> <span class="hljs-number">10</span> <span class="hljs-number">12</span> <span class="hljs-number">14</span> <span class="hljs-number">15</span> <span class="hljs-number">16</span> <span class="hljs-number">17</span> <span class="hljs-number">18</span> <span class="hljs-number">19</span> <span class="hljs-number">20</span> <span class="hljs-number">21</span>],:,cptNt);<br>    <span class="hljs-comment">% HOC + 去噪HOM</span><br>    <span class="hljs-comment">% mat_HOS_cptNt = mat_HOS([1 2 4 6 7 9 11 13 15 16 17 18 19 20 21],:,cptNt);</span><br>    [~,resUz] <span class="hljs-built_in">=</span> min(pdist2(HOSth<span class="hljs-string">&#x27;,mat_HOS_cptNt&#x27;</span>,<span class="hljs-string">&#x27;euclidean&#x27;</span>)); <span class="hljs-comment">% MD classifier</span><br>    stat(<span class="hljs-number">2</span>+cptNt,:)<span class="hljs-built_in">=</span>resUz;<br>end<br><span class="hljs-comment">% 多天线结果融合</span><br><span class="hljs-built_in">if</span> Nt<span class="hljs-built_in">=</span><span class="hljs-built_in">=</span><span class="hljs-number">1</span><br>   stat(<span class="hljs-number">4</span>,:) <span class="hljs-built_in">=</span> stat(<span class="hljs-number">3</span>,:); <span class="hljs-comment">% 单天线直接复制</span><br><span class="hljs-built_in">else</span><br>   stat(<span class="hljs-number">3</span>+Nt,:) <span class="hljs-built_in">=</span> <span class="hljs-keyword">mode</span>(stat(<span class="hljs-number">3</span>:<span class="hljs-number">2</span>+Nt,:)); <span class="hljs-comment">% frequency (number of occurrences)</span><br>end<br>stat(<span class="hljs-number">4</span>+Nt,:) <span class="hljs-built_in">=</span> double(stat(<span class="hljs-number">2</span>,:)<span class="hljs-built_in">=</span><span class="hljs-built_in">=</span>stat(<span class="hljs-number">3</span>+Nt,:)); <span class="hljs-comment">% 生成二进制正确性标记向量（1=正确，0=错误）</span><br>pci <span class="hljs-built_in">=</span> zeros(<span class="hljs-number">1</span>,lSNR);<br>end_ <span class="hljs-built_in">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-comment">% 按SNR分段统计正确识别率</span><br>for cptSNR<span class="hljs-built_in">=</span><span class="hljs-number">1</span>:lSNR<br>    beg_ <span class="hljs-built_in">=</span> end_+<span class="hljs-number">1</span>;<br>    end_ <span class="hljs-built_in">=</span> beg_+lMMC-<span class="hljs-number">1</span>; <span class="hljs-comment">% 当前SNR对应的数据段</span><br>    pci(cptSNR) <span class="hljs-built_in">=</span> sum(stat(<span class="hljs-number">4</span>+Nt,beg_:end_))/lMMC; <span class="hljs-comment">% 正确率</span><br>end<br>figure<br>plot(SNR,pci,<span class="hljs-string">&#x27;-o&#x27;</span>,<span class="hljs-string">&#x27;LineWidth&#x27;</span>,<span class="hljs-number">1.5</span>)   <span class="hljs-comment">% 添加样式：实线+圆圈标记</span><br>xlabel(<span class="hljs-string">&#x27;SNR&#x27;</span>, <span class="hljs-string">&#x27;FontSize&#x27;</span>, <span class="hljs-number">12</span>)<br>ylabel(<span class="hljs-string">&#x27;正确识别概率&#x27;</span>, <span class="hljs-string">&#x27;FontSize&#x27;</span>, <span class="hljs-number">12</span>)<br>grid on<br>set(gca, <span class="hljs-string">&#x27;FontWeight&#x27;</span>, <span class="hljs-string">&#x27;bold&#x27;</span>)       <span class="hljs-comment">% 坐标轴字体加粗</span><br></code></pre></td></tr></table></figure><p>到这里，对论文的复现就完成了。</p><h3 id="One-More-Thing"><a href="#One-More-Thing" class="headerlink" title="One More Thing"></a>One More Thing</h3><p>如果需要实现对某一信号分类的效果，也就是输入信号x，输出信号的调制方式1-6的效果，可以对代码做如下改进。</p><figure class="highlight m"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><code class="hljs m"><span class="hljs-comment">% 主函数，用于调制方式识别</span><br>function modulation_type <span class="hljs-built_in">=</span> modulate_and_identify(input_signal, SNR, Nt, Nr, K, pbee, cfo, phznoise)<br>    <span class="hljs-comment">% 1. 生成高阶统计量（HOS）</span><br>    HOS <span class="hljs-built_in">=</span> f_HOS_Extraction(input_signal, SNR, K, Nt, Nr, pbee, cfo, phznoise);<br>    <span class="hljs-comment">% 2. 理论HOS值，用于后续匹配</span><br>    HOSth <span class="hljs-built_in">=</span> &#123; <br>        <span class="hljs-string">&#x27;   &#x27;</span>  <span class="hljs-string">&#x27;B-PSK&#x27;</span> <span class="hljs-string">&#x27;Q-PSK&#x27;</span> <span class="hljs-string">&#x27;8-PSK&#x27;</span> <span class="hljs-string">&#x27;4-ASK&#x27;</span> <span class="hljs-string">&#x27;8-ASK&#x27;</span> <span class="hljs-string">&#x27;16-QAM&#x27;</span>;<br>        <span class="hljs-string">&#x27;M40&#x27;</span>   <span class="hljs-number">1</span>     -<span class="hljs-number">1</span>       <span class="hljs-number">0</span>       <span class="hljs-number">1.64</span>   <span class="hljs-number">1.77</span>   -<span class="hljs-number">0.67</span>;<br>        <span class="hljs-string">&#x27;M41&#x27;</span>   <span class="hljs-number">1</span>      <span class="hljs-number">0</span>       <span class="hljs-number">0</span>       <span class="hljs-number">1.64</span>   <span class="hljs-number">1.77</span>    <span class="hljs-number">0</span>;<br>        <span class="hljs-string">&#x27;M42&#x27;</span>   <span class="hljs-number">1</span>      <span class="hljs-number">1</span>       <span class="hljs-number">1</span>       <span class="hljs-number">1.64</span>   <span class="hljs-number">1.77</span>    <span class="hljs-number">1.32</span>;<br>        <span class="hljs-string">&#x27;M60&#x27;</span>   <span class="hljs-number">1</span>      <span class="hljs-number">0</span>       <span class="hljs-number">0</span>       <span class="hljs-number">2.92</span>   <span class="hljs-number">3.62</span>    <span class="hljs-number">0</span>;<br>        <span class="hljs-string">&#x27;M61&#x27;</span>   <span class="hljs-number">1</span>     -<span class="hljs-number">1</span>       <span class="hljs-number">0</span>       <span class="hljs-number">2.92</span>   <span class="hljs-number">3.62</span>   -<span class="hljs-number">1.32</span>;<br>        <span class="hljs-string">&#x27;M62&#x27;</span>   <span class="hljs-number">1</span>      <span class="hljs-number">0</span>       <span class="hljs-number">0</span>       <span class="hljs-number">2.92</span>   <span class="hljs-number">3.62</span>    <span class="hljs-number">0</span>;<br>        <span class="hljs-string">&#x27;M63&#x27;</span>   <span class="hljs-number">1</span>      <span class="hljs-number">1</span>       <span class="hljs-number">1</span>       <span class="hljs-number">2.92</span>   <span class="hljs-number">3.62</span>    <span class="hljs-number">1.96</span>;<br>        <span class="hljs-string">&#x27;M84&#x27;</span>   <span class="hljs-number">1</span>      <span class="hljs-number">1</span>       <span class="hljs-number">1</span>       <span class="hljs-number">5.25</span>   <span class="hljs-number">7.92</span>    <span class="hljs-number">3.12</span>;<br>        <span class="hljs-string">&#x27;C40&#x27;</span>  -<span class="hljs-number">2</span>     -<span class="hljs-number">1</span>       <span class="hljs-number">0</span>      -<span class="hljs-number">1.36</span>  -<span class="hljs-number">1.42</span>   -<span class="hljs-number">0.68</span>;<br>        <span class="hljs-string">&#x27;C41&#x27;</span>  -<span class="hljs-number">2</span>      <span class="hljs-number">0</span>       <span class="hljs-number">0</span>      -<span class="hljs-number">1.36</span>  -<span class="hljs-number">1.42</span>    <span class="hljs-number">0</span>;<br>        <span class="hljs-string">&#x27;C42&#x27;</span>  -<span class="hljs-number">2</span>     -<span class="hljs-number">1</span>      -<span class="hljs-number">1</span>      -<span class="hljs-number">1.36</span>  -<span class="hljs-number">1.42</span>   -<span class="hljs-number">0.68</span>;<br>        <span class="hljs-string">&#x27;C60&#x27;</span>  <span class="hljs-number">16</span>      <span class="hljs-number">0</span>       <span class="hljs-number">0</span>       <span class="hljs-number">8.32</span>   <span class="hljs-number">7.19</span>    <span class="hljs-number">0</span>;<br>        <span class="hljs-string">&#x27;C61&#x27;</span>  <span class="hljs-number">16</span>      <span class="hljs-number">4</span>       <span class="hljs-number">0</span>       <span class="hljs-number">8.32</span>   <span class="hljs-number">7.19</span>    <span class="hljs-number">2.08</span>;<br>        <span class="hljs-string">&#x27;C62&#x27;</span>  <span class="hljs-number">16</span>      <span class="hljs-number">0</span>       <span class="hljs-number">0</span>       <span class="hljs-number">8.32</span>   <span class="hljs-number">7.19</span>    <span class="hljs-number">0</span>;<br>        <span class="hljs-string">&#x27;C63&#x27;</span>  <span class="hljs-number">16</span>      <span class="hljs-number">4</span>       <span class="hljs-number">4</span>       <span class="hljs-number">8.32</span>   <span class="hljs-number">7.19</span>    <span class="hljs-number">2.08</span>;<br>    &#125;;<br>    HOSth <span class="hljs-built_in">=</span> cell2mat(HOSth(<span class="hljs-number">2</span>:end,<span class="hljs-number">2</span>:end));<br>    <span class="hljs-comment">% 3. 使用高阶矩进行调制识别</span><br>    [~, resUz] <span class="hljs-built_in">=</span> min(pdist2(HOSth<span class="hljs-string">&#x27;, HOS&#x27;</span>, <span class="hljs-string">&#x27;euclidean&#x27;</span>)); <span class="hljs-comment">% 最小距离分类法</span><br>    <span class="hljs-comment">% 4. 输出识别结果</span><br>    modulation_type <span class="hljs-built_in">=</span> get_modulation_type(resUz);<br>    disp([<span class="hljs-string">&#x27;识别的调制方式为: &#x27;</span>, modulation_type]);<br>end<br><br><span class="hljs-comment">% 调制方式的映射函数</span><br>function modulation_type <span class="hljs-built_in">=</span> get_modulation_type(index)<br>    modulation_types <span class="hljs-built_in">=</span> &#123;<span class="hljs-string">&#x27;B-PSK&#x27;</span>, <span class="hljs-string">&#x27;Q-PSK&#x27;</span>, <span class="hljs-string">&#x27;8-PSK&#x27;</span>, <span class="hljs-string">&#x27;4-ASK&#x27;</span>, <span class="hljs-string">&#x27;8-ASK&#x27;</span>, <span class="hljs-string">&#x27;16-QAM&#x27;</span>&#125;;<br>    modulation_type <span class="hljs-built_in">=</span> modulation_types&#123;index&#125;; <span class="hljs-comment">% 获取对应的调制方式</span><br>end<br><br><span class="hljs-comment">% HOS提取函数</span><br>function HOS <span class="hljs-built_in">=</span> f_HOS_Extraction(input_signal, SNR, K, Nt, Nr, pbee, cfo, phznoise)<br>    <span class="hljs-comment">% 信号预处理</span><br>    x <span class="hljs-built_in">=</span> input_signal;  <span class="hljs-comment">% 输入信号</span><br>    scale <span class="hljs-built_in">=</span> modnorm(x, <span class="hljs-string">&#x27;avpow&#x27;</span>, <span class="hljs-number">1</span>);   <span class="hljs-comment">% 归一化</span><br>    x_mod <span class="hljs-built_in">=</span> x * scale;  <span class="hljs-comment">% 归一化信号</span><br>    <span class="hljs-comment">% MIMO信道模拟</span><br>    H <span class="hljs-built_in">=</span> randn(Nr, Nt) + <span class="hljs-number">1</span>i * randn(Nr, Nt);<br>    y_mimo <span class="hljs-built_in">=</span> H * reshape(x_mod, Nt, []);<br>    <span class="hljs-comment">% 载波频率偏移（CFO）和相位噪声模型</span><br>    cfo_mat <span class="hljs-built_in">=</span> repmat(exp(<span class="hljs-number">2</span>i * pi * (<span class="hljs-number">1</span>:<span class="hljs-number">1</span>:K) * cfo), Nr, <span class="hljs-number">1</span>);<br>    y_mimo <span class="hljs-built_in">=</span> y_mimo .* cfo_mat;<br>    <span class="hljs-built_in">if</span> phznoise ~<span class="hljs-built_in">=</span> <span class="hljs-number">0</span><br>        for cptNr <span class="hljs-built_in">=</span> <span class="hljs-number">1</span>:Nr<br>            y_mimo(cptNr, :) <span class="hljs-built_in">=</span> phznoise(y_mimo(cptNr, :).<span class="hljs-string">&#x27;);</span><br><span class="hljs-string">        end</span><br><span class="hljs-string">    end</span><br><span class="hljs-string">    % 加噪声</span><br><span class="hljs-string">    y_mimo_SNR = awgn(y_mimo, SNR, &#x27;</span>measured<span class="hljs-string">&#x27;);</span><br><span class="hljs-string">    Pb = mean(abs(reshape(y_mimo_SNR - y_mimo, 1, []).^2)) + pbee; % 噪声功率估计</span><br><span class="hljs-string">    % BSS（盲源分离）</span><br><span class="hljs-string">    R = mean(real(x_mod).^4) / mean(real(x_mod).^2);</span><br><span class="hljs-string">    [W, yeg] = f_SCMA(Nt, Nr, y_mimo_SNR, R);</span><br><span class="hljs-string">    Pbf = Pb * W.&#x27;</span> * conj(W); <span class="hljs-comment">% 滤波后的噪声功率</span><br>    <span class="hljs-comment">% HOS特征提取</span><br>    for cpt <span class="hljs-built_in">=</span> <span class="hljs-number">1</span>:Nt<br>        HOS(cpt, :) <span class="hljs-built_in">=</span> f_CalcHOS(yeg(cpt, :), Pbf(cpt, cpt));<br>    end<br>end<br><br><span class="hljs-comment">% SCMA函数：用于盲源分离</span><br>function [G, yeg] <span class="hljs-built_in">=</span> f_SCMA(Nt, Nr, y_mimo_SNR, R)<br>    Ry <span class="hljs-built_in">=</span> (y_mimo_SNR * y_mimo_SNR<span class="hljs-string">&#x27;) / size(y_mimo_SNR, 2);</span><br><span class="hljs-string">    [U, SIG] = eig(Ry);  % 特征分解</span><br><span class="hljs-string">    SIG = SIG(Nr:-1:(Nr-Nt+1), Nr:-1:(Nr-Nt+1)); % 确保Nr&gt;=Nt</span><br><span class="hljs-string">    U = U(:, Nr:-1:(Nr-Nt+1));</span><br><span class="hljs-string">    B = (SIG^-0.5) * U&#x27;</span>;  <span class="hljs-comment">% 白化矩阵</span><br>    YW <span class="hljs-built_in">=</span> B * y_mimo_SNR;  <span class="hljs-comment">% 白化信号</span><br>    <span class="hljs-comment">% 初始化分离矩阵</span><br>    W <span class="hljs-built_in">=</span> eye(Nt);<br>    mu <span class="hljs-built_in">=</span> <span class="hljs-number">1</span>e-<span class="hljs-number">2</span>;  <span class="hljs-comment">% 步长</span><br>    <span class="hljs-comment">% 随机梯度下降（SGD）算法</span><br>    for ns <span class="hljs-built_in">=</span> <span class="hljs-number">1</span>:size(YW, <span class="hljs-number">2</span>)<br>        YW_ns <span class="hljs-built_in">=</span> YW(:, ns);<br>        z_ns <span class="hljs-built_in">=</span> W.<span class="hljs-string">&#x27; * YW_ns;</span><br><span class="hljs-string">        for n = 1:Nt</span><br><span class="hljs-string">            e = (real(z_ns(n)).^2 - R) .* real(z_ns(n));</span><br><span class="hljs-string">            W(:, n) = W(:, n) - mu * e .* conj(YW_ns);</span><br><span class="hljs-string">        end</span><br><span class="hljs-string">        W = f_GramSchmidt(W); % 正交化处理</span><br><span class="hljs-string">    end</span><br><span class="hljs-string">    yeg = W.&#x27;</span> * YW;<br>    G <span class="hljs-built_in">=</span> B.<span class="hljs-string">&#x27; * W;</span><br><span class="hljs-string">end</span><br><span class="hljs-string"></span><br><span class="hljs-string">% Gram-Schmidt正交化处理</span><br><span class="hljs-string">function Q = f_GramSchmidt(W)</span><br><span class="hljs-string">    Q = zeros(size(W));</span><br><span class="hljs-string">    Q(:, 1) = W(:, 1) / norm(W(:, 1));</span><br><span class="hljs-string"></span><br><span class="hljs-string">    for i = 2:size(W, 2)</span><br><span class="hljs-string">        s_proj = 0;</span><br><span class="hljs-string">        for j = 1:i-1</span><br><span class="hljs-string">            s_proj = s_proj + ((Q(:, j)&#x27;</span> * W(:, i)) / (Q(:, j)<span class="hljs-string">&#x27; * Q(:, j))) * Q(:, j);</span><br><span class="hljs-string">        end</span><br><span class="hljs-string"></span><br><span class="hljs-string">        e = W(:, i) - s_proj;</span><br><span class="hljs-string">        Q(:, i) = e / norm(e);</span><br><span class="hljs-string">    end</span><br><span class="hljs-string">end</span><br><span class="hljs-string"></span><br><span class="hljs-string">% HOS计算函数</span><br><span class="hljs-string">function hos = f_CalcHOS(x, Pb)</span><br><span class="hljs-string">    x = x - mean(x);</span><br><span class="hljs-string"></span><br><span class="hljs-string">    m20 = real(mean(x.^2));</span><br><span class="hljs-string">    m22 = real(mean(conj(x).^2));</span><br><span class="hljs-string">    m40 = real(mean(x.^4));</span><br><span class="hljs-string">    m60 = real(mean(x.^6));</span><br><span class="hljs-string"></span><br><span class="hljs-string">    m21y = real(mean(x .* (conj(x))));</span><br><span class="hljs-string">    m41y = real(mean((x.^3) .* (conj(x))));</span><br><span class="hljs-string">    m42y = real(mean((x.^2) .* (conj(x).^2)));</span><br><span class="hljs-string">    m43y = real(mean(x .* (conj(x).^3)));</span><br><span class="hljs-string">    m61y = real(mean((x.^5) .* (conj(x))));</span><br><span class="hljs-string">    m62y = real(mean((x.^4) .* (conj(x).^2)));</span><br><span class="hljs-string">    m63y = real(mean((x.^3) .* (conj(x).^3)));</span><br><span class="hljs-string">    m84y = real(mean((x.^4) .* (conj(x).^4)));</span><br><span class="hljs-string"></span><br><span class="hljs-string">    m21 = m21y - Pb;</span><br><span class="hljs-string">    m41 = m41y - 3 * m20 * Pb;</span><br><span class="hljs-string">    m42 = m42y - 2 * Pb^2 - 4 * Pb * m21;</span><br><span class="hljs-string">    m43 = m43y - 3 * m22 * Pb;</span><br><span class="hljs-string">    m61 = m61y - 5 * m40 * Pb;</span><br><span class="hljs-string">    m62 = m62y - 12 * m20 * Pb^2 - 8 * m41 * Pb;</span><br><span class="hljs-string">    m63 = m63y - 18 * m21 * Pb^2 - 9 * m42 * Pb - 6 * Pb^3;</span><br><span class="hljs-string">    m84 = m84y - 16 * m63 * Pb - 72 * m42 * Pb^2 - 96 * m21 * Pb^3 - 24 * Pb^4;</span><br><span class="hljs-string"></span><br><span class="hljs-string">    c40 = m40 - 3 * (m20.^2);</span><br><span class="hljs-string">    c60 = m60 - 15 * m20 * m40 + 30 * (m20.^3);</span><br><span class="hljs-string"></span><br><span class="hljs-string">    c41 = m41 - 3 * m20 * m21;</span><br><span class="hljs-string">    c42 = m42 - (abs(m20).^2) - 2 * (m21.^2);</span><br><span class="hljs-string">    c61 = m61 - 5 * m21 * m40 - 10 * m20 * m41 + 30 * m21 * (m20.^2);</span><br><span class="hljs-string">    c62 = m62 - 6 * m42 * m20 - 8 * m21 * m41 - m22 * m40 + 6 * m22 * m20^2 + 24 * m20 * m21^2;</span><br><span class="hljs-string">    c63 = m63 - 9 * m42 * m21 + 12 * (m21.^3) - 3 * m20 * m43 - 3 * m22 * m41 + 18 * m20 * m21 * m22;</span><br><span class="hljs-string"></span><br><span class="hljs-string">    hos = real([m40 m41 m42 m60 m61 m62 m63 m84 c40 c41 c42 c60 c61 c62 c63]);</span><br><span class="hljs-string">end</span><br><span class="hljs-string"></span><br><span class="hljs-string">Nt = 2;       % 发射天线数量</span><br><span class="hljs-string">Nr = 6;       % 接收天线数量</span><br><span class="hljs-string">K = 4000;     % 传输的MIMO符号数量</span><br><span class="hljs-string">SNR = 10;     % 信噪比（dB）</span><br><span class="hljs-string">pbee = 0.01;  % 噪声功率估计误差</span><br><span class="hljs-string">cfo = 1e-4;   % 载波频率偏移</span><br><span class="hljs-string">phznoise = 0; % 相位噪声模型（0代表无相位噪声）</span><br><span class="hljs-string">% 生成一个模拟的输入信号（例如，16-QAM调制）</span><br><span class="hljs-string">M = 6; % 假设已知的调制类型为16-QAM（M = 6）</span><br><span class="hljs-string">x = randi([0, 15], 1, Nt * K); % 生成16-QAM信号的符号</span><br><span class="hljs-string">x_mod = qammod(x, 16);          % 调制为16-QAM信号</span><br><span class="hljs-string">input_signal = x_mod;           % 输入信号</span><br><span class="hljs-string">% 调用调制识别函数</span><br><span class="hljs-string">modulation_type = modulate_and_identify(input_signal, SNR, Nt, Nr, K, pbee, cfo, phznoise);</span><br><span class="hljs-string">% 显示结果</span><br><span class="hljs-string">disp([&#x27;</span>识别的调制方式为: <span class="hljs-string">&#x27;, modulation_type]);</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>论文复现</category>
      
      <category>信号处理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>论文复现</tag>
      
      <tag>信号处理</tag>
      
      <tag>调制识别</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>汤小丹操作系统大学教材书后答案</title>
    <link href="/2025/05/23/%E6%B1%A4%E5%B0%8F%E4%B8%B9OS%E4%B9%A6%E5%90%8E%E7%AD%94%E6%A1%88/"/>
    <url>/2025/05/23/%E6%B1%A4%E5%B0%8F%E4%B8%B9OS%E4%B9%A6%E5%90%8E%E7%AD%94%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<p>汤小丹操作系统大学教材课本书后答案（代表性题目节选，非完整答案）</p><span id="more"></span><h2 id="第一章·OS引论"><a href="#第一章·OS引论" class="headerlink" title="第一章·OS引论"></a>第一章·OS引论</h2><h5 id="1-1-设计现代OS的主要目标是什么？"><a href="#1-1-设计现代OS的主要目标是什么？" class="headerlink" title="1.1 设计现代OS的主要目标是什么？"></a>1.1 设计现代OS的主要目标是什么？</h5><blockquote><p>有效性 、方便性 、可扩充性 、开放性</p></blockquote><h5 id="1-2-OS-的作用可表现在哪几个方面？"><a href="#1-2-OS-的作用可表现在哪几个方面？" class="headerlink" title="1.2 OS 的作用可表现在哪几个方面？"></a>1.2 OS 的作用可表现在哪几个方面？</h5><blockquote><p>1.OS 作为用户与计算机硬件系统之间的接</p><p>2.作为计算机系统资源的管理者</p><p>3.OS 实现了对计算机资源的抽象</p></blockquote><h5 id="1-3-为什么说操作系统实现了对计算机资源的抽象？"><a href="#1-3-为什么说操作系统实现了对计算机资源的抽象？" class="headerlink" title="1.3 为什么说操作系统实现了对计算机资源的抽象？"></a>1.3 为什么说操作系统实现了对计算机资源的抽象？</h5><blockquote><p>1、<strong>IO设备管理</strong>软件实现了对计算机硬件操作的第一个层次的抽象；</p><p>2、<strong>文件管理软件</strong>实现了对硬件资源操作的第二个层次的抽象；</p><p>3、依此类推，如果在文件管理软件上再覆盖一层<strong>面向用户的窗口软件</strong>，则用户便可再窗口环境下方便地使用计算机，从而形成一台功能更强的虚拟机；</p><p>4、OS是铺设再计算机硬件上的多层软件的集合，它们不仅增强了系统的功能，还<strong>隐藏了对硬件操作的具体细节</strong>，实现了对计算机硬件操作的多个层次的抽象模型；</p></blockquote><h5 id="1-4-推动多道批处理系统形成和发展的主要动力"><a href="#1-4-推动多道批处理系统形成和发展的主要动力" class="headerlink" title="1.4 推动多道批处理系统形成和发展的主要动力"></a>1.4 推动多道批处理系统形成和发展的主要动力</h5><blockquote><p>（1 ）对计算机资源的利用率的追求</p><p>（2 ）方便用户；</p><p>（3 ）器件的不断更新换代；</p><p>（4 ）计算机体系结构的不断发展。</p></blockquote><h5 id="1-6-推动分时系统发展的动力"><a href="#1-6-推动分时系统发展的动力" class="headerlink" title="1.6 推动分时系统发展的动力"></a>1.6 推动分时系统发展的动力</h5><blockquote><p>（1）CPU的分时使用缩短了作业的平均周转时间；</p><p>（2）<strong>人机交互</strong>能力使用户能直接控制自己的作业；</p><p>（3）<strong>主机的共享</strong>使多用户能同时使用同一台计算机，独立地处理自己的作业。</p></blockquote><h5 id="1-7-实现分时系统的关键问题，如何解决？"><a href="#1-7-实现分时系统的关键问题，如何解决？" class="headerlink" title="1.7 实现分时系统的关键问题，如何解决？"></a>1.7 实现分时系统的关键问题，如何解决？</h5><blockquote><p>及时接受，及时处理</p><p>针对及时接收问题<br>设置<strong>多路卡</strong>，使主机能同时接收用户从各个终端上输入的数据；<br><strong>为每个终端配置缓冲区</strong>，暂存用户键入的命令或数据。</p><p>针对及时处理问题<br>应使<strong>所有的用户作业都直接进入内存</strong>，并且为每个作业分配一个时间片，允许作业只在自己的时间片内运行，这样在不长的时间内，能使每个作业都运行一次。</p></blockquote><h5 id="1-11-OS的几大特性，最基本特征"><a href="#1-11-OS的几大特性，最基本特征" class="headerlink" title="1.11 OS的几大特性，最基本特征"></a>1.11 OS的几大特性，最基本特征</h5><blockquote><p>并发性、共享性、虚拟性和异步性；最基本的特征是并发性和共享性。</p></blockquote><h5 id="1-13-什么是时分复用技术-举例说明它能提高资源利用率的根本原因是什么"><a href="#1-13-什么是时分复用技术-举例说明它能提高资源利用率的根本原因是什么" class="headerlink" title="1.13 什么是时分复用技术? 举例说明它能提高资源利用率的根本原因是什么?"></a>1.13 什么是时分复用技术? 举例说明它能提高资源利用率的根本原因是什么?</h5><blockquote><p>将资源在不同的时间片内分配给各进程以使该资源被重复利用，从而提高资源的利用率，使得用户感觉自己独占主机，而处理机在这期间也被充分的利用。</p></blockquote><h5 id="1-14-是什么原因使操作系统具有异步性特征？"><a href="#1-14-是什么原因使操作系统具有异步性特征？" class="headerlink" title="1.14 是什么原因使操作系统具有异步性特征？"></a>1.14 是什么原因使操作系统具有异步性特征？</h5><blockquote><p>一是<strong>进程的异步性</strong>，进程以人们不可预知的速度向前推进，</p><p>二是<strong>程序的不可再现性</strong>，即程序执行的结果有时是不确定的，</p><p>三是<strong>程序执行时间的不可预知性</strong>，即每个程序何时执行，执行顺序以及完成时间是不确定的。</p></blockquote><h5 id="1-15-处理机管理有哪些主要功能？它们的主要任务是什么？"><a href="#1-15-处理机管理有哪些主要功能？它们的主要任务是什么？" class="headerlink" title="1.15 处理机管理有哪些主要功能？它们的主要任务是什么？"></a>1.15 处理机管理有哪些主要功能？它们的主要任务是什么？</h5><blockquote><p><strong>进程管理</strong>：为作业创建进程，撤销已结束进程，控制进程在运行过程中的状态转换。</p><p><strong>进程同步</strong>：为多个进程（含线程）的运行进行协调。</p><p><strong>进程通信</strong>：用来实现在相互合作的进程之间的信息交换。</p><p><strong>处理机调度</strong>：</p><p>（1 ）作业调度。从后备队里按照一定的算法 ，选出若干个作业，为他们分配运行所需</p><p>的资源（首选是分配内存）。</p><p>（2 ）进程调度：从进程的就绪队列中，按照一定算法选出一个进程，把处理机分配给它，并设置运行现场，使进程投入执行。</p></blockquote><h5 id="1-16-内存管理有哪些主要功能-他们的主要任务是什么？"><a href="#1-16-内存管理有哪些主要功能-他们的主要任务是什么？" class="headerlink" title="1.16 内存管理有哪些主要功能? 他们的主要任务是什么？"></a>1.16 内存管理有哪些主要功能? 他们的主要任务是什么？</h5><blockquote><p><strong>内存分配</strong>：为每道程序分配内存。</p><p><strong>内存保护</strong>：确保每道用户程序都只在自己的内存空间运行，彼此互不干扰。</p><p><strong>地址映射</strong>：将地址空间的逻辑地址转换为内存空间与对应的物理地址。</p><p><strong>内存扩充</strong>：用于实现请求调用功能，置换功能等。</p></blockquote><h5 id="1-17-设备管理有哪些主要功能？其主要任务是什么？"><a href="#1-17-设备管理有哪些主要功能？其主要任务是什么？" class="headerlink" title="1.17 设备管理有哪些主要功能？其主要任务是什么？"></a>1.17 设备管理有哪些主要功能？其主要任务是什么？</h5><blockquote><p>缓冲管理、设备分配、设备处理。虚拟设备</p><p>完成用户提出的 I&#x2F;O 请求，为用户分配 I&#x2F;O 设备；提高 CPU 和 I&#x2F;O 设备的利用率；提高 I&#x2F;O 速度；以及方便用户使用 I&#x2F;O 设备 .</p></blockquote><h2 id="第二章·进程的描述与控制"><a href="#第二章·进程的描述与控制" class="headerlink" title="第二章·进程的描述与控制"></a>第二章·进程的描述与控制</h2><h5 id="2-1-什么是前趋图？为什么要引入前趋图？"><a href="#2-1-什么是前趋图？为什么要引入前趋图？" class="headerlink" title="2.1 什么是前趋图？为什么要引入前趋图？"></a>2.1 什么是前趋图？为什么要引入前趋图？</h5><blockquote><p>前趋图 (Precedence Graph) 是一个有向无循环图，记为DAG(DirectedAcyclic Graph) ，用于描述进程之间执行的前后关系。</p></blockquote><h5 id="2-2-画出下面四条语句的前趋图"><a href="#2-2-画出下面四条语句的前趋图" class="headerlink" title="2.2 画出下面四条语句的前趋图:"></a>2.2 画出下面四条语句的前趋图:</h5><pre><code class="hljs">S1=a: =x+y;S2=b:=z+1;S3=c:=a–b ;S4=w:=c+1;</code></pre><p><img src="/2025/05/23/%E6%B1%A4%E5%B0%8F%E4%B8%B9OS%E4%B9%A6%E5%90%8E%E7%AD%94%E6%A1%88/image-20220627211017-rpcrdez.png"></p><h5 id="2-3-什么程序并发执行会产生间断性特征？"><a href="#2-3-什么程序并发执行会产生间断性特征？" class="headerlink" title="2.3 什么程序并发执行会产生间断性特征？"></a>2.3 什么程序并发执行会产生间断性特征？</h5><blockquote><p>程序在并发执行时，由于它们共享系统资源，为完成同一项任务需要相互合作，致使这些并发执行的进程之间，形成了相互制约关系，从而使得进程在执行期间出现间断性。</p></blockquote><h5 id="2-4-程序并发执行时为什么会失去封闭性和可再现性？"><a href="#2-4-程序并发执行时为什么会失去封闭性和可再现性？" class="headerlink" title="&#x3D;&#x3D;2.4 程序并发执行时为什么会失去封闭性和可再现性？&#x3D;&#x3D;"></a>&#x3D;&#x3D;2.4 程序并发执行时为什么会失去封闭性和可再现性？&#x3D;&#x3D;</h5><blockquote><p>程序并发执行时，多个程序共享系统中的各种资源，因而这些资源的状态由多个程序改变</p></blockquote><h5 id="2-6-试从动态性，并发性和独立性上比较进程和程序。"><a href="#2-6-试从动态性，并发性和独立性上比较进程和程序。" class="headerlink" title="2.6 试从动态性，并发性和独立性上比较进程和程序。"></a>2.6 试从动态性，并发性和独立性上比较进程和程序。</h5><blockquote><p>动态性是进程最基本的特性，而程序只是一组有序的指令集合，是静态实体。</p><p>并发性是进程的重要特征，而程序是不能并发执行的。</p><p>独立性是指进程实体是一个能<strong>独立运行</strong>的基本单位，程序不能作为独立单位参加运行。</p></blockquote><h5 id="2-11-试说明进程在三个基本状态之间转换的典型原因。"><a href="#2-11-试说明进程在三个基本状态之间转换的典型原因。" class="headerlink" title="2.11 试说明进程在三个基本状态之间转换的典型原因。"></a>2.11 试说明进程在三个基本状态之间转换的典型原因。</h5><blockquote><p>（1）就绪状态一执行状态：进程分配到CPU资源</p><p>（2）执行状态一就绪状态：时间片用完</p><p>（3）执行状态一阻塞状态：I&#x2F;0请求</p><p>（4）阻塞状态一就绪状态：I&#x2F;0完成</p></blockquote><h5 id="2-18-试说明引起进程阻塞戒被唤醒的主要事件是什么？"><a href="#2-18-试说明引起进程阻塞戒被唤醒的主要事件是什么？" class="headerlink" title="2.18 试说明引起进程阻塞戒被唤醒的主要事件是什么？"></a>2.18 试说明引起进程阻塞戒被唤醒的主要事件是什么？</h5><blockquote><p>a.请求系统服务；b.启动某种操作；c.新数据尚未到达；d.无新工作可做</p></blockquote><h5 id="2-19-为什么要在0S中引入线程"><a href="#2-19-为什么要在0S中引入线程" class="headerlink" title="2.19 为什么要在0S中引入线程?"></a>2.19 为什么要在0S中引入线程?</h5><blockquote><p>减少程序在并发执行时所付出的时空开销，使0S具有更好的并发性，提高CPU的利用率</p><p>&#x3D;&#x3D;进程是分配资源的基本单位，而线程则是系统调度的基本单位&#x3D;&#x3D;</p></blockquote><h5 id="2-20-试说明线程具有哪些属性"><a href="#2-20-试说明线程具有哪些属性" class="headerlink" title="2.20 试说明线程具有哪些属性?"></a>2.20 试说明线程具有哪些属性?</h5><blockquote><p>（1）轻型实体（2) 独立调度和分派的基本单位（3)可并发执行（4)共享进程资源</p></blockquote><h5 id="2-21-试从调度性，并取性，拥有资源及系统开销方面对进程和线程进行比较。"><a href="#2-21-试从调度性，并取性，拥有资源及系统开销方面对进程和线程进行比较。" class="headerlink" title="2.21 试从调度性，并取性，拥有资源及系统开销方面对进程和线程进行比较。"></a>2.21 试从调度性，并取性，拥有资源及系统开销方面对进程和线程进行比较。</h5><blockquote><p>（1)  调度性。线程在0S中作为调度和分派的基本单位，进程只作为资源拥有的基本单位。</p><p>（2）并发性。进程可以并发执行，一个进程的多个线程也可并发执行。</p><p>（3）拥有资源。进程始终是拥有资源的基本单位，线程只拥有运行时必不可少的资源，本身基本不拥有系统资源，但可以访问隶属进程的资源。</p><p>（4）系统开销。操作系统在创建、撤消和切换进程时付出的开销显著大于线程。</p></blockquote><h2 id="第三章·处理机调度与死锁"><a href="#第三章·处理机调度与死锁" class="headerlink" title="第三章·处理机调度与死锁"></a>第三章·处理机调度与死锁</h2><h5 id="3-1-高级调度与低级调度的主要任务？为什么要引入中级调度"><a href="#3-1-高级调度与低级调度的主要任务？为什么要引入中级调度" class="headerlink" title="3.1 高级调度与低级调度的主要任务？为什么要引入中级调度"></a>3.1 高级调度与低级调度的主要任务？为什么要引入中级调度</h5><blockquote><p>（1）高级调度又称为&#x3D;&#x3D;作业调度&#x3D;&#x3D;。它是批处理系统中使用的一种调度。其主要任务是从外存的后备队列上选择一个或多个作业调入内存，并为其<u>创建进程、分配必要的资源，然后再将所创建的进程控制块插入就绪队列中</u>。</p><p>（2）低级调度又称&#x3D;&#x3D;进程调度&#x3D;&#x3D;。它是距离硬件最近的一级调度。其主要任务是从就绪队列上选择一个（或多个）进程，使其获得CPU。</p><p>（3）&#x3D;&#x3D;引入中级调度的目的&#x3D;&#x3D;是为了提高内存利用率和系统吞吐量。其功能是，让那些暂时不能运行的进程不再占用宝贵的内存资源，而是调其到外存上等候。此时的进程状态为挂起状态。当这些进程重新具备运行条件且内存空闲时，由中级调度选择一部分挂起状态的进程调入内存并将其状态变为就绪状态。</p></blockquote><h5 id="3-2-处理机调度算法的目标？-批处理系统的目标？"><a href="#3-2-处理机调度算法的目标？-批处理系统的目标？" class="headerlink" title="3.2 处理机调度算法的目标？ 批处理系统的目标？"></a>3.2 处理机调度算法的目标？ 批处理系统的目标？</h5><blockquote><p>1.资源利用率，公平性，平衡性，策略强制执行。</p><p>2.平均周转时间短，系统吞吐量高，处理机利用率高。</p></blockquote><h5 id="3-6-高响应比优先调度算法？优点？"><a href="#3-6-高响应比优先调度算法？优点？" class="headerlink" title="3.6 高响应比优先调度算法？优点？"></a>3.6 高响应比优先调度算法？优点？</h5><blockquote><p>因为其同时兼顾了等待时间和运行时间，将该两种因素相结合，让优先级高的程序优先运行。</p></blockquote><h5 id="3-8-抢占调度中抢占的原则？"><a href="#3-8-抢占调度中抢占的原则？" class="headerlink" title="3.8 抢占调度中抢占的原则？"></a>3.8 抢占调度中抢占的原则？</h5><blockquote><p>抢占的原则是：</p><pre><code class="hljs">  1. **优先权原则** ：允许优先级高的进程抢优先级低进程的  2. **短进程优先** ：新到的短时间进程，可以抢占当前长进程的处理机。  3. **时间片原则** ：按照时间片来分配时间来，时间结束就要停止该进程的执行，重新等待时间片分配</code></pre></blockquote><h5 id="3-9-选择调度方式和调度算法的准则？"><a href="#3-9-选择调度方式和调度算法的准则？" class="headerlink" title="3.9 选择调度方式和调度算法的准则？"></a>3.9 选择调度方式和调度算法的准则？</h5><blockquote><p>（1）面向<strong>用户</strong>的准则：周转时间短，响应时间快，截止时间的保证，优先权准则。<br>（2）面向<strong>系统</strong>的准则：系统吞吐量高，处理机利用率好，各类资源的平衡利用。</p></blockquote><h5 id="3-12-比较FCFS和SJF两种进程调度算法"><a href="#3-12-比较FCFS和SJF两种进程调度算法" class="headerlink" title="3.12 比较FCFS和SJF两种进程调度算法"></a>3.12 比较FCFS和SJF两种进程调度算法</h5><blockquote><p><strong>相同点</strong> </p><p>性质相同：都是作为一种调度算法 </p><p>作用对象相同：都可以用于作业调度和进程调度 </p><p><strong>不同点</strong> </p><p>算法思想不同： FCFS算法是指进程调度时是从就绪的进程队列中选择一个最先进入该队列的进程，为之分配处理机，使之投入运行的一种调度算法。 </p><pre><code class="hljs">SJF算法是指以作业的长短来计算优先级，作业越短，其优先级越高，越优先将他们调入内存运行。 优缺点相对 FCFS有利于长作业，不利于短作业 SJF有利于短作业，不利于长作业</code></pre></blockquote><h5 id="3-13-如何确定时间片的大小"><a href="#3-13-如何确定时间片的大小" class="headerlink" title="&#x3D;&#x3D;3.13 如何确定时间片的大小&#x3D;&#x3D;"></a>&#x3D;&#x3D;3.13 如何确定时间片的大小&#x3D;&#x3D;</h5><blockquote><p>时间片应略大于一次典型交互所需的时间</p></blockquote><h5 id="3-15-为什么-多级反馈队列调度算法-能较好的满足各方面用户的需求？"><a href="#3-15-为什么-多级反馈队列调度算法-能较好的满足各方面用户的需求？" class="headerlink" title="3.15 为什么 多级反馈队列调度算法 能较好的满足各方面用户的需求？"></a>3.15 为什么 多级反馈队列调度算法 能较好的满足各方面用户的需求？</h5><blockquote><p>用时间片大小来分配队列：也就是每个规定的队列中的进程，无论长短都用相同长度的时间片</p><p>假设当前进程在此队列中的平均分配的时间片用完了，它还没执行完，就把它放到下一个队列的队尾，排队执行下一个队列再给它 <strong>下一个队列所平均分配的时间片</strong> 。</p><pre><code class="hljs">  在**短批处理作业用户**来说，短作业在第一个队列或者第二队列就被执行完了，效率也十分快，对于**长批处理作业用**户来说，它在尽可能不影响其它进程的情况下，不断在两个或者多个队列中运行，也不用担心长时间得不到处理的情况</code></pre></blockquote><h5 id="3-21-什么是最早截止时间优先调度算法？举例"><a href="#3-21-什么是最早截止时间优先调度算法？举例" class="headerlink" title="3.21 什么是最早截止时间优先调度算法？举例"></a>3.21 什么是最早截止时间优先调度算法？举例</h5><blockquote><p>根据任务的截止时间来确定任务的优先级的算法，任务截止时间越早，其优先级愈高。</p></blockquote><h5 id="3-23-“优先级倒置”现象，怎么解决？"><a href="#3-23-“优先级倒置”现象，怎么解决？" class="headerlink" title="&#x3D;&#x3D;3.23 “优先级倒置”现象，怎么解决？&#x3D;&#x3D;"></a>&#x3D;&#x3D;3.23 “优先级倒置”现象，怎么解决？&#x3D;&#x3D;</h5><blockquote><p><strong>优先级倒置</strong>：高优先级进程被低优先级进程延迟或阻塞的现象。</p><p><strong>解决方法</strong>可以是规定进程在进入临界区后，其所占有的处理机不允许被抢占。</p></blockquote><h5 id="3-27-死锁？原因和条件"><a href="#3-27-死锁？原因和条件" class="headerlink" title="3.27 死锁？原因和条件"></a>3.27 死锁？原因和条件</h5><blockquote><p>如果一组进程中的每一个进程都在等待仅该组进程中的其他进程才能引发的事件，那么该组进程是死锁的。</p><p>原因：（1） 因为系统资源不足。</p><pre><code class="hljs">  （2） 进程运行推进的顺序不合适。  （3） 资源分配不当等。</code></pre><p>条件：（1） 互斥：一个资源每次只能被一个进程使用。</p><pre><code class="hljs">  （2） 请求与保持：一个进程因请求资源而阻塞时，对已获得的资源保持不放。  （3） 不可抢占：进程已获得的资源，在末使用完之前，不能强行剥夺。  （4）循环等待：若干进程之间形成一种头尾相接的循环等待资源关系。</code></pre></blockquote><h5 id="3-29-哪些途径预防死锁"><a href="#3-29-哪些途径预防死锁" class="headerlink" title="3.29 哪些途径预防死锁"></a>3.29 哪些途径预防死锁</h5><blockquote><p><strong>破坏</strong>死锁形成条件</p><p>请求和保持：在运行初获得所需资源，后逐步释放并请求新资源</p><p>不可抢占：占用资源的进程的需求不被满足，就释放它的所有资源</p><p>循环等待：所有资源类型线性排序，赋予序号</p></blockquote><h5 id="3-31-银行家算法中出现以下情况"><a href="#3-31-银行家算法中出现以下情况" class="headerlink" title="3.31 银行家算法中出现以下情况"></a>3.31 银行家算法中出现以下情况</h5><table><thead><tr><th align="center">Process</th><th align="center">Allocation(已分配)</th><th align="center">Need(需要)</th><th align="center">Available(可分配)</th></tr></thead><tbody><tr><td align="center">P0</td><td align="center">0032</td><td align="center">0012</td><td align="center">1622</td></tr><tr><td align="center">P1</td><td align="center">1000</td><td align="center">1750</td><td align="center"></td></tr><tr><td align="center">P2</td><td align="center">1354</td><td align="center">2356</td><td align="center"></td></tr><tr><td align="center">P3</td><td align="center">0332</td><td align="center">0652</td><td align="center"></td></tr><tr><td align="center">P4</td><td align="center">0014</td><td align="center">0656</td><td align="center"></td></tr></tbody></table><h6 id="1-状态是否安全"><a href="#1-状态是否安全" class="headerlink" title="1.状态是否安全"></a>1.状态是否安全</h6><h6 id="2-若P2提出请求request-1，2，2，2-，sys能否分配资源给它"><a href="#2-若P2提出请求request-1，2，2，2-，sys能否分配资源给它" class="headerlink" title="2.若P2提出请求request(1，2，2，2)，sys能否分配资源给它"></a>2.若P2提出请求request(1，2，2，2)，sys能否分配资源给它</h6><blockquote><ol><li><p>就是是否有安全序列<br> P0-&gt;P3-&gt;P4-&gt;P1-&gt;P2<br> 安全</p><table><thead><tr><th align="center">Process</th><th align="center">Work(可分配)</th><th align="center">Need(需要)</th><th align="center">Allocation(已分配)</th><th align="center">Work+Allocation(剩余有)</th></tr></thead><tbody><tr><td align="center">P0</td><td align="center">1622</td><td align="center">0012</td><td align="center">0032</td><td align="center">1654</td></tr><tr><td align="center">P3</td><td align="center">1654</td><td align="center">0652</td><td align="center">0332</td><td align="center">1986</td></tr><tr><td align="center">P4</td><td align="center">1986</td><td align="center">0656</td><td align="center">0014</td><td align="center">199 10</td></tr><tr><td align="center">P1</td><td align="center">199 10</td><td align="center">1750</td><td align="center">1000</td><td align="center">299 10</td></tr><tr><td align="center">P2</td><td align="center">299 10</td><td align="center">2356</td><td align="center">1354</td><td align="center">3 12 14 14</td></tr></tbody></table></li><li><p>P2提出(1，2，2，2)<br> (1，2，2，2)≤Need(2，3，5，6)，是合理的<br> (1，2，2，2)≤Available(1，6，2，2)，是可以满足的<br> 1622-1222&#x3D;0400，0400不能得出安全序列，所以不能分配给他</p></li></ol></blockquote><h2 id="第四章·存储器管理"><a href="#第四章·存储器管理" class="headerlink" title="第四章·存储器管理"></a>第四章·存储器管理</h2><h5 id="4-1-为什么配置层次式存储器？"><a href="#4-1-为什么配置层次式存储器？" class="headerlink" title="4.1 为什么配置层次式存储器？"></a>4.1 为什么配置层次式存储器？</h5><blockquote><p>设置多个存储器可以使存储器的两端能够并行工作，设多级存储系统，例如cache能够最大程度提升系统的性能，设置缓冲可以大大减少IO次数。</p><p><img src="/2025/05/23/%E6%B1%A4%E5%B0%8F%E4%B8%B9OS%E4%B9%A6%E5%90%8E%E7%AD%94%E6%A1%88/9b8822896b390d607a14b18a41fb291-20220626164139-53n1x1o.png" title="层次式存储"></p></blockquote><h5 id="4-2-哪几种方式将程序装入内存？分别适用于什么场合？"><a href="#4-2-哪几种方式将程序装入内存？分别适用于什么场合？" class="headerlink" title="4.2 哪几种方式将程序装入内存？分别适用于什么场合？"></a>4.2 哪几种方式将程序装入内存？分别适用于什么场合？</h5><blockquote><ol><li><strong>绝对装入方式</strong> ：用户程序经过编译后，将产生绝对(物理)地址的目标代码。将目标模块装入到内存中事先指定的位置(只适用于单道)</li><li><strong>可重定位装入方式</strong> ：由于在内存中的0号位只有一个，且本身就已存储了大量的程序，它可以根据内存的具体情况将装入到内存的适当位置。（可重定位的所有逻辑地址与实际装入内存后的物理地址不同。）它可以用于多道程序环境。但是它必须要求程序在运行时，不允许程序在运行的时候在内存中移动位置</li><li><strong>动态重定位</strong> ：使用它装入的时，先把它装入模块装入到内存之后，并不是立即把逻辑地址换为物理地址，而是在程序真正要指定的时候才换，为避免速度缓慢，它中间会有一个<strong>重定位寄存器</strong>的支持。</li></ol></blockquote><h5 id="4-7-为何引入动态重定位？如何实现"><a href="#4-7-为何引入动态重定位？如何实现" class="headerlink" title="4.7 为何引入动态重定位？如何实现"></a>4.7 为何引入动态重定位？如何实现</h5><blockquote><p>引入原因：程序在运行过程中经常要在内存中移动位置，为了保证这些被移动了的程序还能正常执行，必须对程序和数据的地址加以修改，即重定位。引入重定位的目的就是为了满足程序的这种需要。<br><strong>实现</strong>：要在不影响指令执行速度的同时实现地址变换，必须有硬件地址变换机构的支持，即须在系统中增设一个<strong>重定位寄存器</strong>，<u>用它来存放程序在内存中的起始地址</u>。程序在执行时，真正访问的内存地址是<u>相对地址与重定位寄存器中的地址相加</u>而形成的。</p></blockquote><h5 id="4-8-基于顺序搜索的动态分区算法，分为哪几种"><a href="#4-8-基于顺序搜索的动态分区算法，分为哪几种" class="headerlink" title="4.8 基于顺序搜索的动态分区算法，分为哪几种"></a>4.8 基于顺序搜索的动态分区算法，分为哪几种</h5><blockquote><p>依次搜索空闲分区链上的空闲分区，去寻找一个其大小都满足要求的分区。</p><p>  1.<strong>首次适应(first fit,FF)算法</strong></p><p>  FF算法要求空闲分区链以地址递增的次序链接，链首开始往后找，直到找到为止，没有就失败返回</p><p>  2.<strong>循环首次适应(next fit,NF)算法</strong></p><p>  每次从上一次找到的空闲区的下一段开始找，设置一个始查寻指针</p><p>  3.<strong>最佳适应(best fit,BF)算法</strong></p><p>  将空闲分区按容量从小到大分配。但是分配后切下来剩下的部分总是最小的。</p><p>  4.<strong>最坏适应(worst fit,WF)算法</strong></p><p>  总挑最大的从中切部分使用，空闲分区按大小从小到大排列，以至于存储器中缺乏大的空闲分区。</p></blockquote><h5 id="4-9-首次适应算法回收内存，可能出现什么情况？如何处理？"><a href="#4-9-首次适应算法回收内存，可能出现什么情况？如何处理？" class="headerlink" title="4.9 首次适应算法回收内存，可能出现什么情况？如何处理？"></a>4.9 首次适应算法回收内存，可能出现什么情况？如何处理？</h5><blockquote><p>1、回收区与插入点的<strong>前一个空闲分区F1相邻接</strong>，此时应将回收区与插入点的前一分区合并，不必为回收分区分配新表项，而只须修改其前一分区F1的大小。</p><p>2、回收区与插入点的<strong>后一个空闲分区F2相邻接</strong>，此时应将两分区合并，形成新的空闲分区，但用回收区的首址作为新空闲分区的首址，大小为两者之和。</p><p>3、回收区同时与插入点的<strong>前、后两个分区邻接</strong>，此时将三个分区合并，使用F1的表项和F1的首址，取消F2的表项,大小为三者之和。</p><p>4、回收区<strong>既不与F1邻接，又不与F2邻接</strong>。这时应为回收区单独建立一新表项,添写回收区的首址和大小，并根据其首址插入到空闲链中的适当位置。</p></blockquote><h5 id="4-10-基于索引搜索的动态分区分配算法，分为哪几种？"><a href="#4-10-基于索引搜索的动态分区分配算法，分为哪几种？" class="headerlink" title="4.10 基于索引搜索的动态分区分配算法，分为哪几种？"></a>4.10 基于索引搜索的动态分区分配算法，分为哪几种？</h5><blockquote><p>为了提高搜索空间的分区的速度，在中大型系统中往往会采用基于索引搜索的动态分区分配算法</p><p>哈希算法、快速适应算法以及伙伴系统</p></blockquote><h5 id="4-11-令buddyk-x-为大小为2k、地址为x的块的伙伴系统地址，写出buddyk-x-的通用表达式"><a href="#4-11-令buddyk-x-为大小为2k、地址为x的块的伙伴系统地址，写出buddyk-x-的通用表达式" class="headerlink" title="&#x3D;&#x3D;4.11 令buddyk(x)为大小为2k、地址为x的块的伙伴系统地址，写出buddyk(x)的通用表达式&#x3D;&#x3D;"></a>&#x3D;&#x3D;4.11 令buddyk(x)为大小为2k、地址为x的块的伙伴系统地址，写出buddyk(x)的通用表达式&#x3D;&#x3D;</h5><blockquote><p>buddy<sub>k</sub>(x) &#x3D; x+2<sup>k</sup> （当x mod 2<sup>k+1</sup>&#x3D;0）</p><p>buddy<sub>k</sub>(x) &#x3D; x-2<sup>k</sup> （当x mod 2<sup>k+1</sup>&#x3D;2<sup>k</sup>）</p></blockquote><h5 id="4-12-分区存储管理常用的分配策略？比较优缺点"><a href="#4-12-分区存储管理常用的分配策略？比较优缺点" class="headerlink" title="4.12 分区存储管理常用的分配策略？比较优缺点"></a>4.12 分区存储管理常用的分配策略？比较优缺点</h5><blockquote><p><strong>首次适应算法</strong>的优缺点：保留了高址部分的大空闲区；低址部分不断被划分，留下许多<strong>碎片</strong>，且每次分区分配查找时都是从低址部分开始，会增加查找时的系统开销。</p><p><strong>循环首次适应算法</strong>的优缺点：使内存中的空闲分区分布得更为均匀，减少了查找时的系统开销；<strong>缺乏大的空闲分区</strong>，从而导致不能装入大型作业。</p><p><strong>最佳适应算法</strong>的优缺点：每次分配给文件的都是最适合该文件大小的分区；内存中留下许多<strong>碎片</strong>。</p><p><strong>最坏适应算法</strong>的优缺点：给文件分配分区后剩下的的空闲区不至于太小，<strong>产生碎片的几率最小</strong>，对中小型文件分配分区操作有利；使存储器中<strong>缺乏大的空闲区</strong>，对大型文件的分区分配不利。</p></blockquote><h5 id="4-13-为什么引入对换？对换的类型？"><a href="#4-13-为什么引入对换？对换的类型？" class="headerlink" title="4.13 为什么引入对换？对换的类型？"></a>4.13 为什么引入对换？对换的类型？</h5><blockquote><p>在多道环境下，一方面，在内存中的某些进程由于某事件尚未发生而被阻塞，但它却占用了大量的内存空间，甚至有时可能出现在内存中所有进程都被阻塞而迫使CPU停止下来等待的情况；</p><p>　　另一方面，却又有着许多作业在外存上等待，因无内存而不能进入内存运行的情况。显然这对系统资源是一种严重的浪费，且使系统吞吐量下降。为了解决这一问题，在操作系统中引入了对换（也称交换）技术。<br>　　可以将整个进程换入、换出（<strong>整体对换</strong>），也可以将进程的一部分（页、段）换入、换出（<strong>页面(分段)对换</strong>）。前者主要用于缓解目前系统中内存的不足，后者主要用于实现虚拟存储。</p></blockquote><h5 id="4-18-什么是页面？什么是物理块？页面大小如何确定？"><a href="#4-18-什么是页面？什么是物理块？页面大小如何确定？" class="headerlink" title="4.18 什么是页面？什么是物理块？页面大小如何确定？"></a>4.18 什么是页面？什么是物理块？页面大小如何确定？</h5><blockquote><p>页面：分页存储管理将进程的<strong>逻辑地址空间</strong>分成若干个页，并为各页加以编号。</p><p>物理块：把内存的<strong>物理地址空间</strong>分成若干个块，并为各块加以编号。</p><p>页面大小应选择适中，且页面大小应该是2的幂，通常为1KB~8KB。</p></blockquote><h5 id="4-19-what-is-页表？页表的作用是什么？"><a href="#4-19-what-is-页表？页表的作用是什么？" class="headerlink" title="4.19 what is 页表？页表的作用是什么？"></a>4.19 what is 页表？页表的作用是什么？</h5><blockquote><p>页表是分页式存储管理使用的数据结构。一个进程分为多少页，它的页表就有多少行。每一行记录进程的一页和它存放的物理块的页号、块号对应关系。页表用于进行地址变换。</p></blockquote><h5 id="4-20-为实现分页存储管理，需要哪些硬件支持？"><a href="#4-20-为实现分页存储管理，需要哪些硬件支持？" class="headerlink" title="&#x3D;&#x3D;4.20 为实现分页存储管理，需要哪些硬件支持？&#x3D;&#x3D;"></a>&#x3D;&#x3D;4.20 为实现分页存储管理，需要哪些硬件支持？&#x3D;&#x3D;</h5><blockquote><p>需要有<strong>页表机制</strong>、<strong>地址变换机构</strong>的硬件支持。</p></blockquote><h5 id="4-22-具有快表时是如何地址变换的"><a href="#4-22-具有快表时是如何地址变换的" class="headerlink" title="&#x3D;&#x3D;4.22 具有快表时是如何地址变换的&#x3D;&#x3D;"></a>&#x3D;&#x3D;4.22 具有快表时是如何地址变换的&#x3D;&#x3D;</h5><blockquote><p>1.系统将有效地址(逻辑地址)中的页号与<strong>页表寄存器</strong>中的内容比较，若<strong>页号太大</strong>，表示访问越界，于是产生<strong>越界中断</strong></p><p>2.IF未出现越界情况，地址变换机构自动地将页号P送入<strong>输入寄存器</strong>，再确定所需要的页是否在<strong>快表(高速缓存)</strong> 中。<br>IF在则直接读出该页所对应的物理块号，并送入<strong>物理地址寄存器</strong>；<br>IF在快表中未找到对应的页表项，需再访问内存中页表，找到后，把读出的页表项存入快表中的一个寄存器单元中，以取代一个老页表项。</p><p>同时，再将<strong>页内地址</strong>直接送入<strong>物理地址寄存器</strong>， 从而完成了从逻辑地址到物理地址的转换。</p><p><img src="/2025/05/23/%E6%B1%A4%E5%B0%8F%E4%B8%B9OS%E4%B9%A6%E5%90%8E%E7%AD%94%E6%A1%88/278c9c9279d5df643f7304e6b781111-20220627154123-lgb7gq5.png"></p></blockquote><h5 id="4-24-具有快表的段页式存储管理系统中，如何实现地址变换？"><a href="#4-24-具有快表的段页式存储管理系统中，如何实现地址变换？" class="headerlink" title="&#x3D;&#x3D;4.24 具有快表的段页式存储管理系统中，如何实现地址变换？&#x3D;&#x3D;"></a>&#x3D;&#x3D;4.24 具有快表的段页式存储管理系统中，如何实现地址变换？&#x3D;&#x3D;</h5><blockquote><p>1.段号与段表寄存器中记录的段表长度比较，判断越界</p><p>2.无越界，段号与段表寄存器的段表始址求出该段的页表始址</p><p>3.页表始址与逻辑地址中的页号求出对应页表项，读出该页所在的物理块号b，再利用块号b和页内地址来构成物理地址。</p><p><img src="/2025/05/23/%E6%B1%A4%E5%B0%8F%E4%B8%B9OS%E4%B9%A6%E5%90%8E%E7%AD%94%E6%A1%88/f6889844895424c7da8655c79b3c933-20220627160250-h16db83.png"></p></blockquote><h5 id="4-26-分页和分段存储管理有何区别"><a href="#4-26-分页和分段存储管理有何区别" class="headerlink" title="4.26 分页和分段存储管理有何区别"></a>4.26 分页和分段存储管理有何区别</h5><blockquote><p>同：分页和分段都采用离散分配的方式，且都要通过地址映射机构来实现地址变换</p><p>区别：<br>1. 页是<strong>信息的物理单位</strong>，分页是为实现离散分配方式，以消减内存的碎片，提高内存的利用率，满足系统管理的需要，而不是用户的需要<br>    段是<strong>信息的逻辑单位</strong>，它含有一组其意义相对完整的信息，目的是为了能更好地满足用户的需要</p><pre><code class="hljs">2. 页的**大小**固定且由系统确定，而段的大小却不固定，决定于用户所编写的程序3. 分页的作业地址空间是**一维**的，而分段的作业地址空间是**二维**的。4. 段是信息的逻辑单位，便于存储保护和信息的共享，页的**保护和共享**受到限制。</code></pre></blockquote><h2 id="第五章·虚拟存储器"><a href="#第五章·虚拟存储器" class="headerlink" title="第五章·虚拟存储器"></a>第五章·虚拟存储器</h2><h5 id="5-1-常规存储器管理方式有哪两大特征？对系统性能有何影响？"><a href="#5-1-常规存储器管理方式有哪两大特征？对系统性能有何影响？" class="headerlink" title="5.1 常规存储器管理方式有哪两大特征？对系统性能有何影响？"></a>5.1 常规存储器管理方式有哪两大特征？对系统性能有何影响？</h5><blockquote><ol><li><strong>一次性</strong> ：是指作业必须一次性全部装到内存中才能开始运行</li><li><strong>驻留性</strong> :也就是在作业装入内存后，整个作业一直在内存中。直到作业结束。</li></ol><p>  上述两大特性使得许多在程序运行中不用或暂时不用的程序(数据)<strong>占据了大量的内存空间</strong>，而一些需要运行的作业又无法再装进运行。</p></blockquote><h5 id="5-2-时间局限性，空间局限性"><a href="#5-2-时间局限性，空间局限性" class="headerlink" title="&#x3D;&#x3D;5.2 时间局限性，空间局限性&#x3D;&#x3D;"></a>&#x3D;&#x3D;5.2 时间局限性，空间局限性&#x3D;&#x3D;</h5><blockquote><p>最近被访问的单元，很可能在不久的将来还要被访问<br>最近被访问的单元，很可能它附近的单元也即将被访问</p></blockquote><h5 id="5-3-虚存特征，最本质特征"><a href="#5-3-虚存特征，最本质特征" class="headerlink" title="5.3 虚存特征，最本质特征"></a>5.3 虚存特征，最本质特征</h5><blockquote><ul><li><strong>多次性</strong> ：是指无需在作业运行时一次性地全部装入内存，而是允许被分成多次调入内存运行。（利用了局部性原理）</li><li>对换性（交换性）：是指无需在作业运行时一直常驻内存，而是允许在作业的运行过程中，进行换进和换出。</li><li>虚拟性：是指从逻辑上扩充内存的容量，使用户所看到的的内存容量，远大于实际的内存容量。</li></ul></blockquote><h5 id="5-4-虚存需要哪些硬件支持？"><a href="#5-4-虚存需要哪些硬件支持？" class="headerlink" title="5.4  虚存需要哪些硬件支持？"></a>5.4  虚存需要哪些硬件支持？</h5><blockquote><p>请求分页的页表机制+缺页中断机构+地址变换机构</p></blockquote><h5 id="5-5-实现虚存的关键技术"><a href="#5-5-实现虚存的关键技术" class="headerlink" title="5.5 实现虚存的关键技术"></a>5.5 实现虚存的关键技术</h5><blockquote><p><img src="/2025/05/23/%E6%B1%A4%E5%B0%8F%E4%B8%B9OS%E4%B9%A6%E5%90%8E%E7%AD%94%E6%A1%88/94d5227f4647b9b45e0134b6bee9bba-20220627162414-dfxz0pf.png"><img src="/2025/05/23/%E6%B1%A4%E5%B0%8F%E4%B8%B9OS%E4%B9%A6%E5%90%8E%E7%AD%94%E6%A1%88/a184f24cf5b06131769ab2b75e695ea-20220627162441-4lii2lh.png" alt="a184f24cf5b06131769ab2b75e695ea.png"></p></blockquote><h5 id="5-7-缺页中断机构与一般的中断有何区别？"><a href="#5-7-缺页中断机构与一般的中断有何区别？" class="headerlink" title="5.7 缺页中断机构与一般的中断有何区别？"></a>5.7 缺页中断机构与一般的中断有何区别？</h5><blockquote><p>（1）在<strong>指令执行期间</strong>产生和处理中断信号，CPU通常在一条指令执行完后检查是否有中断请求。而缺页中断是在指令执行期间，发现所要访问的指令或数据不在内存时产生和处理的。</p><p>（2）<strong>一条指令</strong>在执行期间可能产生<strong>多次</strong>缺页中断。如一条读取数据的多字节指令，指令本身跨越两个页面，若指令后一部分所在页面和数据所在页面均不在内存，则该指令的执行至少产生两次缺页中断。</p></blockquote><h5 id="5-8-请求分页系统地址变换过程"><a href="#5-8-请求分页系统地址变换过程" class="headerlink" title="5.8 请求分页系统地址变换过程"></a>5.8 请求分页系统地址变换过程</h5><blockquote><p><img src="/2025/05/23/%E6%B1%A4%E5%B0%8F%E4%B8%B9OS%E4%B9%A6%E5%90%8E%E7%AD%94%E6%A1%88/image-20220627171237-p6cx0e5.png"></p><p>新增操作</p><ol><li>请求调页（查找页表项时对状态位进行判断）</li><li>页面置换（若内存块没空间给外存调入，就用页面置换算法置换一个页面出去）</li><li>操作时要修改页表项</li></ol></blockquote><h5 id="5-12-在请求分页系统有哪几种页面置换算法"><a href="#5-12-在请求分页系统有哪几种页面置换算法" class="headerlink" title="5.12 在请求分页系统有哪几种页面置换算法"></a>5.12 在请求分页系统有哪几种页面置换算法</h5><blockquote><p>先进先出FIFO、最近最少使用LFU、最佳置换OPT、最近最久未使用LRU、CLOCK、改进型CLOCK</p></blockquote><h5 id="5-13-用FIFO，假设页面走向为4、3、2、1、4、3、5、4、3、2、1、5，当分配物理块分别为3，4时，计算缺页次数和缺页率"><a href="#5-13-用FIFO，假设页面走向为4、3、2、1、4、3、5、4、3、2、1、5，当分配物理块分别为3，4时，计算缺页次数和缺页率" class="headerlink" title="5.13 用FIFO，假设页面走向为4、3、2、1、4、3、5、4、3、2、1、5，当分配物理块分别为3，4时，计算缺页次数和缺页率"></a>5.13 用FIFO，假设页面走向为4、3、2、1、4、3、5、4、3、2、1、5，当分配物理块分别为3，4时，计算缺页次数和缺页率</h5><blockquote><p><img src="/2025/05/23/%E6%B1%A4%E5%B0%8F%E4%B8%B9OS%E4%B9%A6%E5%90%8E%E7%AD%94%E6%A1%88/83355132f4148a1b1f739c2d8608ec0-20220627203203-9g2otxp.png" title="FIFO"><img src="/2025/05/23/%E6%B1%A4%E5%B0%8F%E4%B8%B9OS%E4%B9%A6%E5%90%8E%E7%AD%94%E6%A1%88/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220627204145-20220627204230-m199dmi.jpg" alt="微信图片_20220627204145.jpg" title="LRU"></p></blockquote><h5 id="5-14-LRU算法的硬件支持"><a href="#5-14-LRU算法的硬件支持" class="headerlink" title="5.14 LRU算法的硬件支持"></a>5.14 LRU算法的硬件支持</h5><blockquote><p>需要<strong>寄存器和栈</strong>等硬件支持。<strong>寄存器</strong>用于记录某进程在内存中各页的使用情况，<strong>栈</strong>用于保存当前使用的各个页面的页面号。</p></blockquote><h5 id="5-15-改进型CLOCK算法的基本原理"><a href="#5-15-改进型CLOCK算法的基本原理" class="headerlink" title="5.15 改进型CLOCK算法的基本原理"></a>5.15 改进型CLOCK算法的基本原理</h5><blockquote><p>因为修改过的页面在换出时付出的开销比未被修改过的页面大，在改进型Clock算法中，既考虑页面的使用情况，还要增加置换代价的因素；在选择页面作为淘汰页面时，把<strong>同时满足未使用过和未被修改作为首选淘汰页面</strong>。</p></blockquote><h5 id="5-18-“抖动”产生的原因是什么？"><a href="#5-18-“抖动”产生的原因是什么？" class="headerlink" title="5.18 “抖动”产生的原因是什么？"></a>5.18 “抖动”产生的原因是什么？</h5><blockquote><p>抖动（Thrashing) 就是指当内存中已无空闲空间而又发生缺页中断时，需要从内存中调出一页进程，如果算法不适当，刚被换出的页很快被访问，需重新调入，因此需再选一页调出，而此时被换出的页很快又要被访问，因而又需将它调入，如此频繁更换页面，使得系统把大部分时间用在了页面的调进换出上，而几乎不能完成任何有效的工作，我们称这种现象为”抖动”。</p><p>原因：供不应求（进程需要访问的页面数目大于可用的物理页帧数目）。请求分页系统中的每个进程只能分配到所需全部内存空间的一部分</p></blockquote><h5 id="5-19-什么是工作集，基于什么原理确定"><a href="#5-19-什么是工作集，基于什么原理确定" class="headerlink" title="5.19 什么是工作集，基于什么原理确定"></a>5.19 什么是工作集，基于什么原理确定</h5><blockquote><p>工作集（或驻留集）是指在某段时间间隔内，进程要访问的页面集合。经常被使用的页面需要在工作集中，而长期不被使用的页面要从工作集中被丢弃。为了防止系统出现抖动现象，需要选择合适的工作集大小。</p><p>确定原理：（局部性原理）用程序的过去某段时间内的行为作业程序在将来某段时间内行为的 <strong>近似</strong> 。</p><p>工作原理：让操作系统跟踪每个进程的工作集，并为进程分配大于其工作集的物理块。如果还有空闲物理块，则可以再调一个进程到内存以增加多道程序数。<br>如果所有工作集之和增加以至于超过了可用物理块的总数，那么操作系统会<strong>暂停一个进程</strong>，将其页面调出并且将其物理块分配给其他进程，防止出现抖动现象。</p></blockquote><h5 id="5-20-哪几种方法防止抖动？"><a href="#5-20-哪几种方法防止抖动？" class="headerlink" title="5.20 哪几种方法防止抖动？"></a>5.20 哪几种方法防止抖动？</h5><blockquote><ol><li><strong>局部置换策略</strong> ：预防抖动，当进程发生缺页，只能在分配给自己的内存空间内进行置换。</li><li><strong>把工作集算法融入到处理机调度中</strong> ：融入了工作集算法，多一道检查进程在调度中融入了工作集算法。必须检测每个进程在内存的驻留页面足够多才调入，那些不足的增加新的物理块</li></ol><p>  3.<strong>利用”L&#x3D;S”准则调节缺页率</strong>：</p><pre><code class="hljs">  L是缺页之间的平均时间，S是平均缺页服务时间，用于置换一个页面所需的时间  L&gt;&gt;S说明很少发生缺页，否则说明经常发生缺页，速度也超过了磁盘的处理能力。  只有两者接近的时候才是磁盘与处理机达到最大利用率。</code></pre><ol start="4"><li><strong>选择暂停的进程</strong> :在多道程序度偏高时，系统必须减少多道程序的数目，暂停优先级低的进程。</li></ol></blockquote><h5 id="5-22-为了实现分段式存储管理，应在系统中增加哪些硬件机构？"><a href="#5-22-为了实现分段式存储管理，应在系统中增加哪些硬件机构？" class="headerlink" title="&#x3D;&#x3D;5.22 为了实现分段式存储管理，应在系统中增加哪些硬件机构？&#x3D;&#x3D;"></a>&#x3D;&#x3D;5.22 为了实现分段式存储管理，应在系统中增加哪些硬件机构？&#x3D;&#x3D;</h5><blockquote><p>请求段表机制、缺段中断机制、地址变换机构</p></blockquote><h2 id="第六章·输入输出系统"><a href="#第六章·输入输出系统" class="headerlink" title="第六章·输入输出系统"></a>第六章·输入输出系统</h2><h5 id="6-1-I-O系统的基本功能"><a href="#6-1-I-O系统的基本功能" class="headerlink" title="6.1 I&#x2F;O系统的基本功能"></a>6.1 I&#x2F;O系统的基本功能</h5><blockquote><ol><li>隐藏物理设备的细节</li><li>保证OS与设备的无关性</li><li>提高处理机和I&#x2F;O设备的利用率</li><li>对I&#x2F;O设备进行控制 (驱动程序)</li><li>确保对设备的正确共享 (独占设备&#x2F;共享设备)</li><li>错误处理 (临时性错误&#x2F;永久性错误)</li></ol></blockquote><h5 id="6-2-I-O软件的4个层次"><a href="#6-2-I-O软件的4个层次" class="headerlink" title="6.2 I&#x2F;O软件的4个层次"></a>6.2 I&#x2F;O软件的4个层次</h5><blockquote><p> <strong>用户层I&#x2F;O软件</strong>，实现与用户交互的接口，用户可直接调用该层所提供的、与IO操作有关的库函数对设备进行操作。</p><p> <strong>设备独立性软件</strong>，用于实现用户程序与设备驱动器的统一接口、设备命名、保护以及分配与释放等，为设备管理和数据传送提供必要的存储空间。</p><p> <strong>设备驱动程序</strong>，与硬件直接相关，用于具体实现系统对设备发出的操作指令，驱动I&#x2F;O设备工作的驱动程序。</p><p><strong>中断处理程序</strong>，用于保存被中断进程的CPU环境，转入相应的中断处理程序进行处理，处理完毕再恢复被中断进程的现场后，返回到被中断的进程。</p></blockquote><h5 id="6-3-I-O系统接口与软件-硬件接口分别是什么接口"><a href="#6-3-I-O系统接口与软件-硬件接口分别是什么接口" class="headerlink" title="6.3 I&#x2F;O系统接口与软件&#x2F;硬件接口分别是什么接口"></a>6.3 I&#x2F;O系统接口与软件&#x2F;硬件接口分别是什么接口</h5><blockquote><p><strong>I&#x2F;O系统接口</strong>：作为I&#x2F;O系统与上层系统之间的接口，向上层提供对设备进行操作的抽象I&#x2F;O命令，以方便高层对设备的使用。</p><p><strong>软件&#x2F;硬件接口</strong>：上面是中断处理程序和用于不同设备的设备驱动程序，它的下面是各种设备的控制器。</p></blockquote><h5 id="6-4-与设备无关性的基本含义？为什么设置该层"><a href="#6-4-与设备无关性的基本含义？为什么设置该层" class="headerlink" title="6.4 与设备无关性的基本含义？为什么设置该层"></a>6.4 与设备无关性的基本含义？为什么设置该层</h5><blockquote><p><strong>I&#x2F;O系统分层</strong>：中断处理程序+设备驱动程序+与设备无关的I&#x2F;O软件</p><p>基本含义：应用程序基本使用的物理设备。为实现设备独立性而引入了逻辑设备和物理设备两概念。在应用程序中，使用逻辑设备名称来请求使用某类设备；而系统在实际执行时，还必须使用物理设备名称。</p><p>为了提高OS的可适应性和可扩展性，易于实现I&#x2F;O重定向</p></blockquote><h5 id="6-7-内存I-O映像，如何实现"><a href="#6-7-内存I-O映像，如何实现" class="headerlink" title="6.7 内存I&#x2F;O映像，如何实现"></a>6.7 内存I&#x2F;O映像，如何实现</h5><blockquote><p>外围设备映射到内存空间便于CPU访问</p><p>编址上<strong>不区分</strong>内存单元地址和设备驱动器的寄存器地址，都采用k。k在0~n-1认为是内存地址，k≥n认为是寄存器地址</p></blockquote><h5 id="6-8-为什么说中断时OS赖以生存的基础？"><a href="#6-8-为什么说中断时OS赖以生存的基础？" class="headerlink" title="&#x3D;&#x3D;6.8 为什么说中断时OS赖以生存的基础？&#x3D;&#x3D;"></a>&#x3D;&#x3D;6.8 为什么说中断时OS赖以生存的基础？&#x3D;&#x3D;</h5><blockquote><ol><li>它是多道程序得以实现的基础,没有中断,就不可能实现多道程序,因为<strong>进程切换</strong>是通过中断来完成的</li><li>中断也是<strong>设备管理</strong>的基础,为了提高处理机的利用率和实现CPU和I&#x2F;O设备并执行,也必需有中断支持</li></ol></blockquote><h5 id="6-16-有哪几种I-O控制方式？适用于何种场合？"><a href="#6-16-有哪几种I-O控制方式？适用于何种场合？" class="headerlink" title="6.16 有哪几种I&#x2F;O控制方式？适用于何种场合？"></a>6.16 有哪几种I&#x2F;O控制方式？适用于何种场合？</h5><blockquote><p>程序I&#x2F;O方式，中断驱动I&#x2F;O控制方式，DMA I&#x2F;O控制方式，I&#x2F;O通道控制方式</p><p><strong>程序I&#x2F;O</strong>适用于早期的计算机系统中,并且是无中断的计算机系统</p><p><strong>中断驱动I&#x2F;O</strong>控制方式是普通用于现代的计算机系统中</p><p><strong>DMA I&#x2F;O</strong>控制方式适用于I&#x2F;O设备为块设备时在和主机进行数据交换的一种I&#x2F;O控制方式</p><p>当I&#x2F;O设备和主机进行数据交换是一组数据块时通常采用<strong>I&#x2F;O通道</strong>控制方式,但此时要求系统必须配置相应的通道控制器</p></blockquote><h5 id="6-17-DMA的工作流程"><a href="#6-17-DMA的工作流程" class="headerlink" title="6.17 DMA的工作流程"></a>6.17 DMA的工作流程</h5><blockquote><p>当CPU要从磁盘读入数据块时，先向磁盘控制器发送一条读命令。 </p><p>该命令被送到<strong>命令寄存器CR</strong>中。同时还发送本次要读入数据的<strong>内存起始目标地址，送入内存地址寄存器MAR</strong></p><p>本次要读数据的<strong>字节数送入数据计数器DC</strong>，将磁盘中的源地址直接送入DMA控制器的I&#x2F;O 控制逻辑上。</p><p>然后启动DMA 控制器传送数据，以后CPU 便处理其它任务。整个数据传送过程由DMA控制器控制</p></blockquote><h5 id="6-18-为何引入设备无关性？如何实现设备独立性？"><a href="#6-18-为何引入设备无关性？如何实现设备独立性？" class="headerlink" title="6.18 为何引入设备无关性？如何实现设备独立性？"></a>6.18 为何引入设备无关性？如何实现设备独立性？</h5><blockquote><p>设备分配的灵活性，易于实现I&#x2F;O重定向</p><p>引入逻辑设备与物理设备概念，应用程序使用逻辑设备名请求设备，经过驱动程序的映射转为物理设备名，并向用户层软件提供统一接口</p></blockquote><h5 id="6-21-设备虚拟，及其关键技术"><a href="#6-21-设备虚拟，及其关键技术" class="headerlink" title="6.21 设备虚拟，及其关键技术"></a>6.21 设备虚拟，及其关键技术</h5><blockquote><p>通过虚拟技术可将一台独占设备变换成若干台逻辑设备,供若干个用户(进程)同时使用,通常把这种经过虚拟技术处理后的设备称为虚拟设备</p><p>SPOOLING技术</p></blockquote><h5 id="6-24-引入缓冲的原因"><a href="#6-24-引入缓冲的原因" class="headerlink" title="6.24 引入缓冲的原因"></a>6.24 引入缓冲的原因</h5><blockquote><p>缓和CPU与I&#x2F;O设备之间速度不匹配的矛盾<br>减少对CPU的中断频率<br>解决DMA或通道方式下数据传输的瓶颈问题<br>提高CPU和I&#x2F;O设备之间的并行性</p></blockquote><h5 id="6-25-在单缓冲情况下-为什么系统对一块数据的处理时间是max-C-T-M"><a href="#6-25-在单缓冲情况下-为什么系统对一块数据的处理时间是max-C-T-M" class="headerlink" title="6.25 在单缓冲情况下,为什么系统对一块数据的处理时间是max(C,T)+M"></a>6.25 <strong>在单缓冲情况下,为什么系统对一块数据的处理时间是max(C,T)+M</strong></h5><blockquote><p>因为<strong>用户输入操作</strong>时间T和<strong>CPU计算时间</strong>C可以并行，操作系统将缓冲区数据传送给用户区的时间为M</p></blockquote><h5 id="6-26-为什么在双缓冲情况下-系统对一块数据的处理时间为max-T-C"><a href="#6-26-为什么在双缓冲情况下-系统对一块数据的处理时间为max-T-C" class="headerlink" title="6.26 为什么在双缓冲情况下,系统对一块数据的处理时间为max(T,C)?"></a>6.26 <strong>为什么在双缓冲情况下,系统对一块数据的处理时间为max(T,C)?</strong></h5><blockquote><p>在双缓冲区中,不仅设备的输入操作和CPU的处理操作可以并行,设备的输入操作和数据的传送操作也可以并行</p></blockquote><h5 id="6-31-目前常用的磁盘调度算法有哪几种-每种算法优先考虑的问题是什么"><a href="#6-31-目前常用的磁盘调度算法有哪几种-每种算法优先考虑的问题是什么" class="headerlink" title="6.31 目前常用的磁盘调度算法有哪几种?每种算法优先考虑的问题是什么?"></a>6.31 <strong>目前常用的磁盘调度算法有哪几种?每种算法优先考虑的问题是什么?</strong></h5><blockquote><p>目前常用的磁盘调度算法有FCFS,SSTF,SCAN</p><p>(1)<strong>先来先服务算法</strong>优先考虑进程请求访问磁盘的先后次序;<br>(2)<strong>最短寻道时间优先算法</strong>考虑要求访问的磁道与当前磁头所在磁道距离是否最近;<br>(3)<strong>扫描算法</strong>考虑欲访问的磁道与当前磁道间的距离,更优先考虑磁头当前的移动方向。</p></blockquote><h2 id="第七章·文件管理"><a href="#第七章·文件管理" class="headerlink" title="第七章·文件管理"></a>第七章·文件管理</h2><h5 id="7-1-数据项、记录、文件"><a href="#7-1-数据项、记录、文件" class="headerlink" title="7.1 数据项、记录、文件"></a>7.1 数据项、记录、文件</h5><blockquote><p><strong>数据项</strong>是最低级的数据组织形式，可分为基本数据项和组合数据项。基本数据项是用于描述一个对象某种属性的字符集，是数据组织中可以命名的最小逻辑数据单位，即原子数据，又称为数据元素或字段。组合数据项则由若干个基本数据项构成。</p><p><strong>记录</strong>是一组相关数据项的集合，用于描述一个对象某方面的属性。</p><p><strong>文件</strong>是指有创建者所定义的、具有文件名的一组相关信息的集合。</p><p>表头是4个数据项，一行是一个记录，整个表是一个文件(有结构文件，如txt的叫流式文件)</p><table><thead><tr><th>书名</th><th>作者</th><th>售价</th><th>出版日期</th></tr></thead><tbody><tr><td>操作系统从入门到放弃</td><td>布吉岛</td><td>100</td><td>明天</td></tr><tr><td>如何学废操作系统</td><td>还不几道</td><td>200</td><td>后天</td></tr><tr><td>……</td><td>……</td><td>……</td><td>……</td></tr></tbody></table></blockquote><h5 id="7-2-文件系统的三层模型"><a href="#7-2-文件系统的三层模型" class="headerlink" title="7.2 文件系统的三层模型"></a>7.2 文件系统的三层模型</h5><blockquote><p>第一层：对象及其属性说明(文件、目录、硬盘或磁带存储空间)</p><p>第二层：对对象操纵和管理的软件集合(I&#x2F;o控制层即设备驱动程序、基本文件系统即物理I&#x2F;o层、基本I&#x2F;О管理程序或文件组织模块层、逻辑文件系统层)</p><p>第三层：文件系统接口(命令接口&#x2F;图形化用户接口与程序接口)</p></blockquote><h2 id="第八章·磁盘存储器的管理"><a href="#第八章·磁盘存储器的管理" class="headerlink" title="第八章·磁盘存储器的管理"></a>第八章·磁盘存储器的管理</h2><h5 id="8-1-目前常用的外村有哪些组织方式"><a href="#8-1-目前常用的外村有哪些组织方式" class="headerlink" title="8.1 目前常用的外村有哪些组织方式"></a>8.1 目前常用的外村有哪些组织方式</h5><blockquote><p>外存的组织方式有三种：连续组织方式、链接组织方式、索引组织方式</p></blockquote><h5 id="8-2-连续组织方式所形成的顺序文件主要优缺点？主要应用于？"><a href="#8-2-连续组织方式所形成的顺序文件主要优缺点？主要应用于？" class="headerlink" title="8.2 连续组织方式所形成的顺序文件主要优缺点？主要应用于？"></a>8.2 连续组织方式所形成的顺序文件主要优缺点？主要应用于？</h5><blockquote><p>优点：1.顺序访问容易<br>  2.顺序访问速度快</p><p>缺点：<br>①要求为一个文件分配连续的存储空间，产生出许多外部碎片，严重地降低了外存空间的利用率。如果是定期地利用紧凑方法来消除碎片，则又需花费大量的机器时间。<br>②必须事先知道文件的长度<br>③不能灵活地删除和插入记录<br>④对于那些动态增长的文件，由于事先很难知道文件的最终大小，因而很难为其分配空间，而即使事先知道文件的最终大小，在采用预分配存储空间的方法时，也会使大量的存储空间长期空闲。</p><p>应用场合：它适用于许多资料处理的场合，如<strong>磁带文件</strong>，<strong>打印文件</strong>都是常用的<strong>顺序文件</strong></p></blockquote><h2 id="第九章·操作系统接口"><a href="#第九章·操作系统接口" class="headerlink" title="第九章·操作系统接口"></a>第九章·操作系统接口</h2><h5 id="9-1-操作系统用户接口包括？分别适用于？"><a href="#9-1-操作系统用户接口包括？分别适用于？" class="headerlink" title="9.1 操作系统用户接口包括？分别适用于？"></a>9.1 操作系统用户接口包括？分别适用于？</h5><blockquote><p>操作系统包括四种类型的用户接口：<strong>命令接口</strong>（分为联机与脱机命令接口）、<strong>程序接口</strong>、<strong>图形化用户接口</strong>和<strong>网络用户接口</strong>。</p><p><strong>命令接口和图形化用户接口</strong>支持用户直接通过终端来使用计算机系统，<strong>程序接口</strong>提供给用户在编制程序时使用，<strong>网络用户接口</strong>是面向网络应用的接口。</p></blockquote><h5 id="9-2-联机命令接口由哪些部分构成"><a href="#9-2-联机命令接口由哪些部分构成" class="headerlink" title="9.2 联机命令接口由哪些部分构成"></a>9.2 联机命令接口由哪些部分构成</h5><blockquote><p>联机命令接口由一组<strong>联机命令</strong>、<strong>终端处理程序</strong>和<strong>命令解释程序</strong>构成。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>教材答案</category>
      
    </categories>
    
    
    <tags>
      
      <tag>教材答案</tag>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
