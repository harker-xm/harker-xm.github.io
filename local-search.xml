<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>调制识别HOM去噪方法</title>
    <link href="/2025/05/24/%E8%B0%83%E5%88%B6%E8%AF%86%E5%88%ABHOM%E5%8E%BB%E5%99%AA%E6%96%B9%E6%B3%95/"/>
    <url>/2025/05/24/%E8%B0%83%E5%88%B6%E8%AF%86%E5%88%ABHOM%E5%8E%BB%E5%99%AA%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h3 id="论文复现"><a href="#论文复现" class="headerlink" title="论文复现"></a>论文复现</h3><p>本文章复现的是<a href="https://ieeexplore.ieee.org/author/37086426257">Sofiane Kharbech</a>等，于2020年在IEEE Wireless Communications Letters发表的论文<a href="https://ieeexplore.ieee.org/document/8968406">《Denoising Higher-Order Moments for Blind Digital Modulation Identification in Multiple-Antenna Systems》</a>（多天线系统中数字调制盲识别的高阶矩去噪方法）</p><p>首先编码三个函数文件，分别实现：</p><ol><li><p><code>f_HOS_Extraction.m</code><br> 从接收信号中提取高阶统计量（HOS）</p> <figure class="highlight m"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs m">function HOS<span class="hljs-built_in">=</span>f_HOS_Extraction(M,SNR,K,Nt,Nr,pbee,cfo,phznoise)<br>switch M<br>   case <span class="hljs-number">1</span><br>      x <span class="hljs-built_in">=</span> randi([<span class="hljs-number">0</span>,<span class="hljs-number">1</span>],<span class="hljs-number">1</span>,Nt*K);<br>      x_mod <span class="hljs-built_in">=</span> pskmod(x,<span class="hljs-number">2</span>);<br>   case <span class="hljs-number">2</span><br>      x <span class="hljs-built_in">=</span> randi([<span class="hljs-number">0</span>,<span class="hljs-number">3</span>],<span class="hljs-number">1</span>,Nt*K);<br>      x_mod <span class="hljs-built_in">=</span> pskmod(x,<span class="hljs-number">4</span>);<br>   case <span class="hljs-number">3</span><br>      x <span class="hljs-built_in">=</span> randi([<span class="hljs-number">0</span>,<span class="hljs-number">7</span>],<span class="hljs-number">1</span>,Nt*K);<br>      x_mod <span class="hljs-built_in">=</span> pskmod(x,<span class="hljs-number">8</span>);<br>   case <span class="hljs-number">4</span><br>      x <span class="hljs-built_in">=</span> randi([<span class="hljs-number">0</span>,<span class="hljs-number">3</span>],<span class="hljs-number">1</span>,Nt*K);<br>      x_mod <span class="hljs-built_in">=</span> pammod(x,<span class="hljs-number">4</span>);<br>   case <span class="hljs-number">5</span><br>      x <span class="hljs-built_in">=</span> randi([<span class="hljs-number">0</span>,<span class="hljs-number">7</span>],<span class="hljs-number">1</span>,Nt*K);<br>      x_mod <span class="hljs-built_in">=</span> pammod(x,<span class="hljs-number">8</span>);<br>   case <span class="hljs-number">6</span><br>      x <span class="hljs-built_in">=</span> randi([<span class="hljs-number">0</span>,<span class="hljs-number">15</span>],<span class="hljs-number">1</span>,Nt*K);<br>      x_mod <span class="hljs-built_in">=</span> qammod(x,<span class="hljs-number">16</span>);<br>   otherwise<br>      disp(<span class="hljs-string">&#x27;Unknown modulation type&#x27;</span>);<br>end<br>scale <span class="hljs-built_in">=</span> modnorm(x_mod,<span class="hljs-string">&#x27;avpow&#x27;</span>,<span class="hljs-number">1</span>);   <span class="hljs-comment">% scaling factor</span><br>x_mod <span class="hljs-built_in">=</span> x_mod*scale;                <span class="hljs-comment">% scaling avg. power to 1W</span><br><span class="hljs-comment">%------------------------------------------------&gt; Channel (MIMO + AWGN)</span><br>H <span class="hljs-built_in">=</span> randn(Nr,Nt)+<span class="hljs-number">1</span>i*randn(Nr,Nt);<br>y_mimo <span class="hljs-built_in">=</span> H*reshape(x_mod,Nt,[]);<br>cfo_mat <span class="hljs-built_in">=</span> repmat(exp(<span class="hljs-number">2</span>i*pi*(<span class="hljs-number">1</span>:<span class="hljs-number">1</span>:K)*cfo),Nr,<span class="hljs-number">1</span>);<br>y_mimo <span class="hljs-built_in">=</span> y_mimo.*cfo_mat;<br><span class="hljs-built_in">if</span> phznoise ~<span class="hljs-built_in">=</span><span class="hljs-number">0</span><br>   for cptNr<span class="hljs-built_in">=</span><span class="hljs-number">1</span>:Nr<br>       y_mimo(cptNr,:) <span class="hljs-built_in">=</span> phznoise(y_mimo(cptNr,:).<span class="hljs-string">&#x27;).&#x27;</span>;<br>   end<br>end<br>y_mimo_SNR <span class="hljs-built_in">=</span> awgn(y_mimo,SNR,<span class="hljs-string">&#x27;measured&#x27;</span>);<br>Pb <span class="hljs-built_in">=</span> mean(abs(reshape(y_mimo_SNR-y_mimo,<span class="hljs-number">1</span>,[]).^<span class="hljs-number">2</span>)) + pbee; <span class="hljs-comment">% noise power</span><br><br>R <span class="hljs-built_in">=</span> mean(real(x_mod).^<span class="hljs-number">4</span>) / mean(real(x_mod).^<span class="hljs-number">2</span>);<br>[W,yeg] <span class="hljs-built_in">=</span> f_SCMA(Nt,Nr,y_mimo_SNR,R);<br>Pbf <span class="hljs-built_in">=</span> Pb*W.<span class="hljs-string">&#x27;*conj(W); % power of the filtered noise</span><br><span class="hljs-string"></span><br><span class="hljs-string">% bf = W.&#x27;</span>*(y_mimo_SNR-y_mimo)  <span class="hljs-comment">% fchk</span><br><span class="hljs-comment">% mean(abs(bf(1,:).^2))         % fchk</span><br><br><span class="hljs-comment">%----&gt; HOS extraction</span><br><br>for cpt<span class="hljs-built_in">=</span><span class="hljs-number">1</span>:Nt<br>    HOS(cpt,:) <span class="hljs-built_in">=</span> f_CalcHOS(yeg(cpt,:),Pbf(cpt,cpt));<br>end<br><br></code></pre></td></tr></table></figure></li><li><p><code>f_CalcHOS.m</code><br> 该函数计算输入信号的各种高阶矩和累积量。它计算矩，如m20， m40, m60，以及累积量，如c40， c60等。</p> <figure class="highlight m"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs m"><span class="hljs-comment">% x  : the signal</span><br><span class="hljs-comment">% Pb : the noise power</span><br>function hos<span class="hljs-built_in">=</span>f_CalcHOS(x, Pb)<br>x<span class="hljs-built_in">=</span>x-mean(x);<br><br>m20<span class="hljs-built_in">=</span>real(mean(x.^<span class="hljs-number">2</span>));<br>m22<span class="hljs-built_in">=</span>real(mean(conj(x).^<span class="hljs-number">2</span>));<br>m40<span class="hljs-built_in">=</span>real(mean(x.^<span class="hljs-number">4</span>));<br>m60<span class="hljs-built_in">=</span>real(mean(x.^<span class="hljs-number">6</span>));<br><br>m21y<span class="hljs-built_in">=</span>real(mean(x.*(conj(x))));<br>m41y<span class="hljs-built_in">=</span>real(mean((x.^<span class="hljs-number">3</span>).*(conj(x))));<br>m42y<span class="hljs-built_in">=</span>real(mean((x.^<span class="hljs-number">2</span>).*(conj(x).^<span class="hljs-number">2</span>)));<br>m43y<span class="hljs-built_in">=</span>real(mean(x.*(conj(x).^<span class="hljs-number">3</span>)));<br>m61y<span class="hljs-built_in">=</span>real(mean((x.^<span class="hljs-number">5</span>).*(conj(x))));<br>m62y<span class="hljs-built_in">=</span>real(mean((x.^<span class="hljs-number">4</span>).*(conj(x).^<span class="hljs-number">2</span>)));<br>m63y<span class="hljs-built_in">=</span>real(mean((x.^<span class="hljs-number">3</span>).*(conj(x).^<span class="hljs-number">3</span>)));<br>m84y<span class="hljs-built_in">=</span>real(mean((x.^<span class="hljs-number">4</span>).*(conj(x).^<span class="hljs-number">4</span>)));<br><br><span class="hljs-comment">% denoising</span><br>m21<span class="hljs-built_in">=</span>m21y-Pb;<br>m41<span class="hljs-built_in">=</span>m41y-<span class="hljs-number">3</span>*m20*Pb;<br>m42<span class="hljs-built_in">=</span>m42y-<span class="hljs-number">2</span>*Pb^<span class="hljs-number">2</span>-<span class="hljs-number">4</span>*Pb*m21;<br>m43<span class="hljs-built_in">=</span>m43y-<span class="hljs-number">3</span>*m22*Pb;<br>m61<span class="hljs-built_in">=</span>m61y-<span class="hljs-number">5</span>*m40*Pb;<br>m62<span class="hljs-built_in">=</span>m62y-<span class="hljs-number">12</span>*m20*Pb^<span class="hljs-number">2</span>-<span class="hljs-number">8</span>*m41*Pb;<br>m63<span class="hljs-built_in">=</span>m63y-<span class="hljs-number">18</span>*m21*Pb^<span class="hljs-number">2</span>-<span class="hljs-number">9</span>*m42*Pb-<span class="hljs-number">6</span>*Pb^<span class="hljs-number">3</span>;<br>m84<span class="hljs-built_in">=</span>m84y-<span class="hljs-number">16</span>*m63*Pb-<span class="hljs-number">72</span>*m42*Pb^<span class="hljs-number">2</span>-<span class="hljs-number">96</span>*m21*Pb^<span class="hljs-number">3</span>-<span class="hljs-number">24</span>*Pb^<span class="hljs-number">4</span>;<br><br><span class="hljs-comment">%--------------------------&gt; Cumulants &lt;--------------------------%</span><br><br>c40<span class="hljs-built_in">=</span>m40-<span class="hljs-number">3</span>*(m20.^<span class="hljs-number">2</span>);<br>c60<span class="hljs-built_in">=</span>m60-<span class="hljs-number">15</span>*m20*m40+<span class="hljs-number">30</span>*(m20.^<span class="hljs-number">3</span>);<br><br>c41<span class="hljs-built_in">=</span>m41-<span class="hljs-number">3</span>*m20*m21;<br>c42<span class="hljs-built_in">=</span>m42-(abs(m20).^<span class="hljs-number">2</span>)-<span class="hljs-number">2</span>*(m21.^<span class="hljs-number">2</span>);<br>c61<span class="hljs-built_in">=</span>m61-<span class="hljs-number">5</span>*m21*m40-<span class="hljs-number">10</span>*m20*m41+<span class="hljs-number">30</span>*m21*(m20.^<span class="hljs-number">2</span>);<br>c62<span class="hljs-built_in">=</span>m62-<span class="hljs-number">6</span>*m42*m20-<span class="hljs-number">8</span>*m21*m41-m22*m40+<span class="hljs-number">6</span>*m22*m20^<span class="hljs-number">2</span>+<span class="hljs-number">24</span>*m20*m21^<span class="hljs-number">2</span>;<br>c63<span class="hljs-built_in">=</span>m63-<span class="hljs-number">9</span>*m42*m21+<span class="hljs-number">12</span>*(m21.^<span class="hljs-number">3</span>)-<span class="hljs-number">3</span>*m20*m43-<span class="hljs-number">3</span>*m22*m41+<span class="hljs-number">18</span>*m20*m21*m22;<br><br><span class="hljs-comment">%--------------------------&gt; Normalization &lt;--------------------------%</span><br><br>m40_n<span class="hljs-built_in">=</span>m40/m21^<span class="hljs-number">2</span>;<br>m41_n<span class="hljs-built_in">=</span>m41/m21^<span class="hljs-number">2</span>;<br>m42_n<span class="hljs-built_in">=</span>m42/m21^<span class="hljs-number">2</span>;<br>m60_n<span class="hljs-built_in">=</span>m60/m21^<span class="hljs-number">3</span>;<br>m61_n<span class="hljs-built_in">=</span>m61/m21^<span class="hljs-number">3</span>;<br>m62_n<span class="hljs-built_in">=</span>m62/m21^<span class="hljs-number">3</span>;<br>m63_n<span class="hljs-built_in">=</span>m63/m21^<span class="hljs-number">3</span>;<br>m84_n<span class="hljs-built_in">=</span>m84/m21^<span class="hljs-number">4</span>;<br><br>c40_n<span class="hljs-built_in">=</span>c40/m21^<span class="hljs-number">2</span>;<br>c41_n<span class="hljs-built_in">=</span>c41/m21^<span class="hljs-number">2</span>;<br>c42_n<span class="hljs-built_in">=</span>c42/m21^<span class="hljs-number">2</span>;<br>c60_n<span class="hljs-built_in">=</span>c60/m21^<span class="hljs-number">3</span>;<br>c61_n<span class="hljs-built_in">=</span>c61/m21^<span class="hljs-number">3</span>;<br>c62_n<span class="hljs-built_in">=</span>c62/m21^<span class="hljs-number">3</span>;<br>c63_n<span class="hljs-built_in">=</span>c63/m21^<span class="hljs-number">3</span>;<br><br>m41y_n<span class="hljs-built_in">=</span>m41y/m21y^<span class="hljs-number">2</span>;<br>m42y_n<span class="hljs-built_in">=</span>m42y/m21y^<span class="hljs-number">2</span>;<br>m61y_n<span class="hljs-built_in">=</span>m61y/m21y^<span class="hljs-number">3</span>;<br>m62y_n<span class="hljs-built_in">=</span>m62y/m21y^<span class="hljs-number">3</span>;<br>m63y_n<span class="hljs-built_in">=</span>m63y/m21y^<span class="hljs-number">3</span>;<br>m84y_n<span class="hljs-built_in">=</span>m84y/m21y^<span class="hljs-number">4</span>;<br><br>hos<span class="hljs-built_in">=</span>real([m40_n m41_n m41y_n m42_n m42y_n m60_n m61_n m61y_n m62_n m62y_n m63_n m63y_n m84_n m84y_n ...<br>          c40_n c41_n c42_n c60_n c61_n c62_n c63_n]);<br></code></pre></td></tr></table></figure></li><li><p><code>f_SCMA.m</code><br> 该函数为MIMO系统执行信号盲源分离（BSS）。利用提取的信号特征和噪声特征，对接收信号进行白化变换，然后利用随机梯度下降（SGD）估计BSS的分离矩阵W。</p> <figure class="highlight m"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs m">function [G,yeg]<span class="hljs-built_in">=</span>f_SCMA(Nt,Nr,y_mimo_SNR,R)<br><span class="hljs-comment">%----------------------------------&gt; Pre-processing: batch whitening</span><br>Ry <span class="hljs-built_in">=</span> (y_mimo_SNR*y_mimo_SNR<span class="hljs-string">&#x27;)/size(y_mimo_SNR,2);</span><br><span class="hljs-string">[U,SIG] = eig(Ry);                          % Eigendecomposition</span><br><span class="hljs-string">SIG = SIG(Nr:-1:(Nr-Nt+1),Nr:-1:(Nr-Nt+1)); % Required condition: Nr&gt;=Nt</span><br><span class="hljs-string">U = U(:,Nr:-1:(Nr-Nt+1));</span><br><span class="hljs-string">B = (SIG^-0.5)*U&#x27;</span>; <span class="hljs-comment">% Whitening matrix</span><br>YW <span class="hljs-built_in">=</span> B*y_mimo_SNR; <span class="hljs-comment">% Whited signals</span><br><br><span class="hljs-comment">%----------------------------------&gt; Estimating the separator W    </span><br>W <span class="hljs-built_in">=</span> eye(Nt);                       <span class="hljs-comment">% Initialization</span><br><span class="hljs-comment">% W = toeplitz(1:Nt);</span><br><span class="hljs-comment">% W = toeplitz(1:Nr,1:Nt);</span><br>mu<span class="hljs-built_in">=</span><span class="hljs-number">1</span>e-<span class="hljs-number">2</span>;                           <span class="hljs-comment">% Step size</span><br><span class="hljs-comment">% mu=5e-3;</span><br>for ns<span class="hljs-built_in">=</span><span class="hljs-number">1</span>:size(YW,<span class="hljs-number">2</span>)                <span class="hljs-comment">% Stochastic gradient descent (SGD)</span><br>    YW_ns <span class="hljs-built_in">=</span> YW(:,ns);<br>    z_ns <span class="hljs-built_in">=</span> W.<span class="hljs-string">&#x27;*YW_ns;</span><br><span class="hljs-string">    for n=1:Nt</span><br><span class="hljs-string">        e = (real(z_ns(n)).^2-R).*real(z_ns(n));</span><br><span class="hljs-string">        W(:,n) = W(:,n)-mu.*e.*conj(YW_ns);</span><br><span class="hljs-string">    end</span><br><span class="hljs-string">    W = f_GramSchmidt(W); % Post-processing: orthonormalization</span><br><span class="hljs-string">end</span><br><span class="hljs-string"></span><br><span class="hljs-string">%----------------------------------&gt; Applying BSS</span><br><span class="hljs-string">yeg = W.&#x27;</span>*YW;<br>G <span class="hljs-built_in">=</span> B.<span class="hljs-string">&#x27;*W;</span><br><span class="hljs-string">function Q = f_GramSchmidt(W)</span><br><span class="hljs-string">Q = zeros(size(W));</span><br><span class="hljs-string">Q(:,1) = W(:,1)/norm(W(:,1));</span><br><span class="hljs-string">for i=2:size(W,2)</span><br><span class="hljs-string">    s_proj = 0;</span><br><span class="hljs-string">    for j=1:i-1</span><br><span class="hljs-string">        s_proj = s_proj+((Q(:,j)&#x27;</span>*W(:,i))/(Q(:,j)<span class="hljs-string">&#x27;*Q(:,j)))*Q(:,j);</span><br><span class="hljs-string">    end</span><br><span class="hljs-string">    e = W(:,i)-s_proj;</span><br><span class="hljs-string">    Q(:,i) = e/norm(e);</span><br><span class="hljs-string">end</span><br></code></pre></td></tr></table></figure></li></ol><p>随后，我们需要生成高阶统计（HOS）特征的数据集。模拟各种调制方案下的MIMO传输，计算每个传输信号的HOS特征，并将数据组织成矩阵。生成的数据集是一个三维矩阵（mat_HOS），形状为&#x3D;&#x3D;特征向量 × 样本指标 × MIMO系统的天线指标&#x3D;&#x3D;。</p><figure class="highlight m"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs m"><span class="hljs-comment">% 1) 本文件用于生成指定数字调制方式和传输配置的高阶统计量(HOS)数据集</span><br><span class="hljs-comment">% 2) 生成的数据集名为&#x27;mat_HOS&#x27;，为三维矩阵：</span><br><span class="hljs-comment">%    - 第一维：HOS向量（特征维度）</span><br><span class="hljs-comment">%    - 第二维：样本索引（HOS向量编号）</span><br><span class="hljs-comment">%    - 第三维：天线编号（MIMO系统接收天线）</span><br><span class="hljs-comment">% 3) 若&#x27;rng shuffle&#x27;不可用，使用以下替代方案：</span><br><span class="hljs-comment">% clk=clock;</span><br><span class="hljs-comment">% RandStream.setGlobalStream(RandStream(&#x27;mt19937ar&#x27;,&#x27;Seed&#x27;,str2num(strrep(num2str(clk(4:6)),&#x27; &#x27;,&#x27;&#x27;))*1e3));</span><br><span class="hljs-comment">% 4) 若未自动启用并行处理，执行以下操作：</span><br><span class="hljs-comment">% parpool(&#x27;local&#x27;,3)        % 启动3个本地工作进程</span><br><span class="hljs-comment">% Linux系统可能需要先运行：</span><br><span class="hljs-comment">% ! sudo chmod -R 777 /home/user_name/.matlab/local_cluster_jobs/R2017a</span><br><span class="hljs-comment">% 注：若无并行计算工具箱，需将最内层循环的parfor改为for</span><br><span class="hljs-comment">% 5) 运行结束后保存工作区：</span><br><span class="hljs-comment">% 需保留所有变量，供DetectionResults.m生成结果</span><br>rng shuffle<br>clc<br>clear<br><span class="hljs-comment">%--------------------------------------------&gt; Parameters</span><br>Nt <span class="hljs-built_in">=</span> <span class="hljs-number">2</span>;    <span class="hljs-comment">% 发射天线数量</span><br>Nr <span class="hljs-built_in">=</span> <span class="hljs-number">6</span>;    <span class="hljs-comment">% 接收天线数量</span><br>K <span class="hljs-built_in">=</span> <span class="hljs-number">4000</span>;  <span class="hljs-comment">% 传输的MIMO符号数量</span><br>M <span class="hljs-built_in">=</span> [<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span>]; <span class="hljs-comment">% 调制类型索引（对应不同调制方式）, cf. &#x27;f_HOS_Extraction.m&#x27; for the names</span><br><span class="hljs-comment">% M = [1 2 3];</span><br>SNR <span class="hljs-built_in">=</span> -<span class="hljs-number">2</span>:<span class="hljs-number">1</span>:<span class="hljs-number">15</span>;     <span class="hljs-comment">% 信噪比范围（-2dB到15dB）</span><br>lMC <span class="hljs-built_in">=</span> <span class="hljs-number">2000</span>;        <span class="hljs-comment">% 蒙特卡洛模拟次数</span><br>eestd <span class="hljs-built_in">=</span> <span class="hljs-number">0</span>;         <span class="hljs-comment">% 噪声功率估计误差标准差</span><br>cfo <span class="hljs-built_in">=</span> <span class="hljs-number">0</span>;           <span class="hljs-comment">% 载波频率偏移</span><br><span class="hljs-comment">% cfo = 1e-4;</span><br>phznoise <span class="hljs-built_in">=</span> <span class="hljs-number">0</span>;      <span class="hljs-comment">% 相位噪声模型</span><br><span class="hljs-comment">% phznoise = comm.PhaseNoise(&#x27;Level&#x27;,-3,&#x27;FrequencyOffset&#x27;,2e-3,&#x27;SampleRate&#x27;,1);</span><br><br><span class="hljs-comment">%--------------------------------------------&gt; Main processing</span><br>mat_HOS <span class="hljs-built_in">=</span> []; <span class="hljs-comment">% HOS特征（特征×样本×天线）</span><br>for cptSNR<span class="hljs-built_in">=</span><span class="hljs-number">1</span>:length(SNR)<br>    for cptM<span class="hljs-built_in">=</span><span class="hljs-number">1</span>:length(M)<br>        Pb_ee <span class="hljs-built_in">=</span> eestd*randn(<span class="hljs-number">1</span>,lMC);<br>        parfor cptMC<span class="hljs-built_in">=</span><span class="hljs-number">1</span>:lMC<br>            <span class="hljs-comment">% 特征提取函数</span><br>            HOS <span class="hljs-built_in">=</span> f_HOS_Extraction(M(cptM),SNR(cptSNR),K,Nt,Nr,Pb_ee(cptMC),cfo,phznoise);<br>            <span class="hljs-comment">% 拼接特征矩阵（第三维为天线，第二维为样本）</span><br>            mat_HOS <span class="hljs-built_in">=</span> [mat_HOS; permute(HOS,[<span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span>])];    <br>        end<br>        disp([<span class="hljs-string">&#x27;M = &#x27;</span> num2str(M(cptM)) <span class="hljs-string">&#x27; completed.&#x27;</span>])       <br>    end<br>end<br>mat_HOS <span class="hljs-built_in">=</span> permute(mat_HOS,[<span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span>]);<span class="hljs-comment">% 调整维度为[特征数×样本数×天线数]</span><br>clearvars -except M SNR Nt Nr lMC mat_HOS<br></code></pre></td></tr></table></figure><p>最后，我们使用HOS数据集（mat_HOS）根据计算的特征对调制类型进行分类。它通过绘制正确识别概率（PCI）作为信噪比的函数来评估调制识别的性能。</p><figure class="highlight m"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs m"><span class="hljs-comment">% 1) 本文件用于绘制特定场景下正确识别概率（PCI）随信噪比（SNR）变化曲线</span><br><span class="hljs-comment">% 2) 支持三种特征组合场景：</span><br><span class="hljs-comment">%    - &#x27;仅使用高阶累积量（HOC）&#x27;</span><br><span class="hljs-comment">%    - &#x27;HOC + 未去噪高阶矩（HOM）&#x27;</span><br><span class="hljs-comment">%    - &#x27;HOC + 去噪后HOM&#x27;</span><br><span class="hljs-comment">% 3) 运行前需加载&#x27;GenDataset.m&#x27;生成的所有变量</span><br>HOSth <span class="hljs-built_in">=</span> &#123; <span class="hljs-comment">% Theoretical HOS值，对应论文表2</span><br><span class="hljs-string">&#x27;   &#x27;</span>  <span class="hljs-string">&#x27;B-PSK&#x27;</span> <span class="hljs-string">&#x27;Q-PSK&#x27;</span> <span class="hljs-string">&#x27;8-PSK&#x27;</span> <span class="hljs-string">&#x27;4-ASK&#x27;</span> <span class="hljs-string">&#x27;8-ASK&#x27;</span> <span class="hljs-string">&#x27;16-QAM&#x27;</span>    ;<br><span class="hljs-string">&#x27;M40&#x27;</span>    <span class="hljs-number">1</span>      -<span class="hljs-number">1</span>       <span class="hljs-number">0</span>       <span class="hljs-number">1.64</span>    <span class="hljs-number">1.77</span>    -<span class="hljs-number">0.67</span>     ;<br><span class="hljs-string">&#x27;M41&#x27;</span>    <span class="hljs-number">1</span>       <span class="hljs-number">0</span>       <span class="hljs-number">0</span>       <span class="hljs-number">1.64</span>    <span class="hljs-number">1.77</span>     <span class="hljs-number">0</span>        ;<br><span class="hljs-string">&#x27;M42&#x27;</span>    <span class="hljs-number">1</span>       <span class="hljs-number">1</span>       <span class="hljs-number">1</span>       <span class="hljs-number">1.64</span>    <span class="hljs-number">1.77</span>     <span class="hljs-number">1.32</span>     ;<br><span class="hljs-string">&#x27;M60&#x27;</span>    <span class="hljs-number">1</span>       <span class="hljs-number">0</span>       <span class="hljs-number">0</span>       <span class="hljs-number">2.92</span>    <span class="hljs-number">3.62</span>     <span class="hljs-number">0</span>        ;<br><span class="hljs-string">&#x27;M61&#x27;</span>    <span class="hljs-number">1</span>      -<span class="hljs-number">1</span>       <span class="hljs-number">0</span>       <span class="hljs-number">2.92</span>    <span class="hljs-number">3.62</span>    -<span class="hljs-number">1.32</span>     ;<br><span class="hljs-string">&#x27;M62&#x27;</span>    <span class="hljs-number">1</span>       <span class="hljs-number">0</span>       <span class="hljs-number">0</span>       <span class="hljs-number">2.92</span>    <span class="hljs-number">3.62</span>     <span class="hljs-number">0</span>        ;<br><span class="hljs-string">&#x27;M63&#x27;</span>    <span class="hljs-number">1</span>       <span class="hljs-number">1</span>       <span class="hljs-number">1</span>       <span class="hljs-number">2.92</span>    <span class="hljs-number">3.62</span>     <span class="hljs-number">1.96</span>     ;<br><span class="hljs-string">&#x27;M84&#x27;</span>    <span class="hljs-number">1</span>       <span class="hljs-number">1</span>       <span class="hljs-number">1</span>       <span class="hljs-number">5.25</span>    <span class="hljs-number">7.92</span>     <span class="hljs-number">3.12</span>     ;<br><span class="hljs-string">&#x27;C40&#x27;</span>   -<span class="hljs-number">2</span>      -<span class="hljs-number">1</span>       <span class="hljs-number">0</span>      -<span class="hljs-number">1.36</span>   -<span class="hljs-number">1.42</span>    -<span class="hljs-number">0.68</span>     ;<br><span class="hljs-string">&#x27;C41&#x27;</span>   -<span class="hljs-number">2</span>       <span class="hljs-number">0</span>       <span class="hljs-number">0</span>      -<span class="hljs-number">1.36</span>   -<span class="hljs-number">1.42</span>     <span class="hljs-number">0</span>        ;<br><span class="hljs-string">&#x27;C42&#x27;</span>   -<span class="hljs-number">2</span>      -<span class="hljs-number">1</span>      -<span class="hljs-number">1</span>      -<span class="hljs-number">1.36</span>   -<span class="hljs-number">1.42</span>    -<span class="hljs-number">0.68</span>     ;<br><span class="hljs-string">&#x27;C60&#x27;</span>    <span class="hljs-number">16</span>      <span class="hljs-number">0</span>       <span class="hljs-number">0</span>       <span class="hljs-number">8.32</span>    <span class="hljs-number">7.19</span>     <span class="hljs-number">0</span>        ;<br><span class="hljs-string">&#x27;C61&#x27;</span>    <span class="hljs-number">16</span>      <span class="hljs-number">4</span>       <span class="hljs-number">0</span>       <span class="hljs-number">8.32</span>    <span class="hljs-number">7.19</span>     <span class="hljs-number">2.08</span>     ;<br><span class="hljs-string">&#x27;C62&#x27;</span>    <span class="hljs-number">16</span>      <span class="hljs-number">0</span>       <span class="hljs-number">0</span>       <span class="hljs-number">8.32</span>    <span class="hljs-number">7.19</span>     <span class="hljs-number">0</span>        ;<br><span class="hljs-string">&#x27;C63&#x27;</span>    <span class="hljs-number">16</span>      <span class="hljs-number">4</span>       <span class="hljs-number">4</span>       <span class="hljs-number">8.32</span>    <span class="hljs-number">7.19</span>     <span class="hljs-number">2.08</span>     ;<br>&#125;;<br>HOSth <span class="hljs-built_in">=</span> cell2mat(HOSth(<span class="hljs-number">2</span>:end,<span class="hljs-number">2</span>:end));<br>lSNR <span class="hljs-built_in">=</span> length(SNR); <span class="hljs-comment">% SNR点数</span><br>lM <span class="hljs-built_in">=</span> length(M); <span class="hljs-comment">% 调制类型数</span><br>lMMC <span class="hljs-built_in">=</span> lM*lMC; <span class="hljs-comment">% 总样本数 = 调制类型数*蒙特卡洛次数</span><br>stat <span class="hljs-built_in">=</span> zeros(<span class="hljs-number">4</span>+Nt,lSNR*lMMC); <span class="hljs-comment">% 统计矩阵初始化</span><br>count <span class="hljs-built_in">=</span> <span class="hljs-number">1</span>;<br>for cptSNR<span class="hljs-built_in">=</span><span class="hljs-number">1</span>:lSNR<br>    for cptM<span class="hljs-built_in">=</span><span class="hljs-number">1</span>:lM<br>        for cptMC<span class="hljs-built_in">=</span><span class="hljs-number">1</span>:lMC           <br>            stat(<span class="hljs-number">1</span>,count) <span class="hljs-built_in">=</span> SNR(cptSNR);<span class="hljs-comment">% 记录SNR</span><br>            stat(<span class="hljs-number">2</span>,count) <span class="hljs-built_in">=</span> M(cptM); <span class="hljs-comment">% 记录真实调制索引</span><br>            count <span class="hljs-built_in">=</span> count+<span class="hljs-number">1</span>;      <br>        end<br>    end<br>end<br><span class="hljs-comment">%% 下面的代码使用那种方式就取消注释哪种方式即可</span><br><span class="hljs-comment">% HOSth = HOSth(9:end,:);        % &#x27;HOC only&#x27;时取消注释</span><br>for cptNt<span class="hljs-built_in">=</span><span class="hljs-number">1</span>:Nt<br>    <span class="hljs-comment">% HOC only</span><br>    <span class="hljs-comment">%mat_HOS_cptNt = mat_HOS(15:end,:,cptNt);</span><br>    <span class="hljs-comment">% HOC + 未去噪HOM</span><br>    mat_HOS_cptNt <span class="hljs-built_in">=</span> mat_HOS([<span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">8</span> <span class="hljs-number">10</span> <span class="hljs-number">12</span> <span class="hljs-number">14</span> <span class="hljs-number">15</span> <span class="hljs-number">16</span> <span class="hljs-number">17</span> <span class="hljs-number">18</span> <span class="hljs-number">19</span> <span class="hljs-number">20</span> <span class="hljs-number">21</span>],:,cptNt);<br>    <span class="hljs-comment">% HOC + 去噪HOM</span><br>    <span class="hljs-comment">% mat_HOS_cptNt = mat_HOS([1 2 4 6 7 9 11 13 15 16 17 18 19 20 21],:,cptNt);</span><br>    [~,resUz] <span class="hljs-built_in">=</span> min(pdist2(HOSth<span class="hljs-string">&#x27;,mat_HOS_cptNt&#x27;</span>,<span class="hljs-string">&#x27;euclidean&#x27;</span>)); <span class="hljs-comment">% MD classifier</span><br>    stat(<span class="hljs-number">2</span>+cptNt,:)<span class="hljs-built_in">=</span>resUz;<br>end<br><span class="hljs-comment">% 多天线结果融合</span><br><span class="hljs-built_in">if</span> Nt<span class="hljs-built_in">=</span><span class="hljs-built_in">=</span><span class="hljs-number">1</span><br>   stat(<span class="hljs-number">4</span>,:) <span class="hljs-built_in">=</span> stat(<span class="hljs-number">3</span>,:); <span class="hljs-comment">% 单天线直接复制</span><br><span class="hljs-built_in">else</span><br>   stat(<span class="hljs-number">3</span>+Nt,:) <span class="hljs-built_in">=</span> <span class="hljs-keyword">mode</span>(stat(<span class="hljs-number">3</span>:<span class="hljs-number">2</span>+Nt,:)); <span class="hljs-comment">% frequency (number of occurrences)</span><br>end<br>stat(<span class="hljs-number">4</span>+Nt,:) <span class="hljs-built_in">=</span> double(stat(<span class="hljs-number">2</span>,:)<span class="hljs-built_in">=</span><span class="hljs-built_in">=</span>stat(<span class="hljs-number">3</span>+Nt,:)); <span class="hljs-comment">% 生成二进制正确性标记向量（1=正确，0=错误）</span><br>pci <span class="hljs-built_in">=</span> zeros(<span class="hljs-number">1</span>,lSNR);<br>end_ <span class="hljs-built_in">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-comment">% 按SNR分段统计正确识别率</span><br>for cptSNR<span class="hljs-built_in">=</span><span class="hljs-number">1</span>:lSNR<br>    beg_ <span class="hljs-built_in">=</span> end_+<span class="hljs-number">1</span>;<br>    end_ <span class="hljs-built_in">=</span> beg_+lMMC-<span class="hljs-number">1</span>; <span class="hljs-comment">% 当前SNR对应的数据段</span><br>    pci(cptSNR) <span class="hljs-built_in">=</span> sum(stat(<span class="hljs-number">4</span>+Nt,beg_:end_))/lMMC; <span class="hljs-comment">% 正确率</span><br>end<br>figure<br>plot(SNR,pci,<span class="hljs-string">&#x27;-o&#x27;</span>,<span class="hljs-string">&#x27;LineWidth&#x27;</span>,<span class="hljs-number">1.5</span>)   <span class="hljs-comment">% 添加样式：实线+圆圈标记</span><br>xlabel(<span class="hljs-string">&#x27;SNR&#x27;</span>, <span class="hljs-string">&#x27;FontSize&#x27;</span>, <span class="hljs-number">12</span>)<br>ylabel(<span class="hljs-string">&#x27;正确识别概率&#x27;</span>, <span class="hljs-string">&#x27;FontSize&#x27;</span>, <span class="hljs-number">12</span>)<br>grid on<br>set(gca, <span class="hljs-string">&#x27;FontWeight&#x27;</span>, <span class="hljs-string">&#x27;bold&#x27;</span>)       <span class="hljs-comment">% 坐标轴字体加粗</span><br></code></pre></td></tr></table></figure><p>到这里，对论文的复现就完成了。</p><h3 id="One-More-Thing"><a href="#One-More-Thing" class="headerlink" title="One More Thing"></a>One More Thing</h3><p>如果需要实现对某一信号分类的效果，也就是输入信号x，输出信号的调制方式1-6的效果，可以对代码做如下改进。</p><figure class="highlight m"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><code class="hljs m"><span class="hljs-comment">% 主函数，用于调制方式识别</span><br>function modulation_type <span class="hljs-built_in">=</span> modulate_and_identify(input_signal, SNR, Nt, Nr, K, pbee, cfo, phznoise)<br>    <span class="hljs-comment">% 1. 生成高阶统计量（HOS）</span><br>    HOS <span class="hljs-built_in">=</span> f_HOS_Extraction(input_signal, SNR, K, Nt, Nr, pbee, cfo, phznoise);<br>    <span class="hljs-comment">% 2. 理论HOS值，用于后续匹配</span><br>    HOSth <span class="hljs-built_in">=</span> &#123; <br>        <span class="hljs-string">&#x27;   &#x27;</span>  <span class="hljs-string">&#x27;B-PSK&#x27;</span> <span class="hljs-string">&#x27;Q-PSK&#x27;</span> <span class="hljs-string">&#x27;8-PSK&#x27;</span> <span class="hljs-string">&#x27;4-ASK&#x27;</span> <span class="hljs-string">&#x27;8-ASK&#x27;</span> <span class="hljs-string">&#x27;16-QAM&#x27;</span>;<br>        <span class="hljs-string">&#x27;M40&#x27;</span>   <span class="hljs-number">1</span>     -<span class="hljs-number">1</span>       <span class="hljs-number">0</span>       <span class="hljs-number">1.64</span>   <span class="hljs-number">1.77</span>   -<span class="hljs-number">0.67</span>;<br>        <span class="hljs-string">&#x27;M41&#x27;</span>   <span class="hljs-number">1</span>      <span class="hljs-number">0</span>       <span class="hljs-number">0</span>       <span class="hljs-number">1.64</span>   <span class="hljs-number">1.77</span>    <span class="hljs-number">0</span>;<br>        <span class="hljs-string">&#x27;M42&#x27;</span>   <span class="hljs-number">1</span>      <span class="hljs-number">1</span>       <span class="hljs-number">1</span>       <span class="hljs-number">1.64</span>   <span class="hljs-number">1.77</span>    <span class="hljs-number">1.32</span>;<br>        <span class="hljs-string">&#x27;M60&#x27;</span>   <span class="hljs-number">1</span>      <span class="hljs-number">0</span>       <span class="hljs-number">0</span>       <span class="hljs-number">2.92</span>   <span class="hljs-number">3.62</span>    <span class="hljs-number">0</span>;<br>        <span class="hljs-string">&#x27;M61&#x27;</span>   <span class="hljs-number">1</span>     -<span class="hljs-number">1</span>       <span class="hljs-number">0</span>       <span class="hljs-number">2.92</span>   <span class="hljs-number">3.62</span>   -<span class="hljs-number">1.32</span>;<br>        <span class="hljs-string">&#x27;M62&#x27;</span>   <span class="hljs-number">1</span>      <span class="hljs-number">0</span>       <span class="hljs-number">0</span>       <span class="hljs-number">2.92</span>   <span class="hljs-number">3.62</span>    <span class="hljs-number">0</span>;<br>        <span class="hljs-string">&#x27;M63&#x27;</span>   <span class="hljs-number">1</span>      <span class="hljs-number">1</span>       <span class="hljs-number">1</span>       <span class="hljs-number">2.92</span>   <span class="hljs-number">3.62</span>    <span class="hljs-number">1.96</span>;<br>        <span class="hljs-string">&#x27;M84&#x27;</span>   <span class="hljs-number">1</span>      <span class="hljs-number">1</span>       <span class="hljs-number">1</span>       <span class="hljs-number">5.25</span>   <span class="hljs-number">7.92</span>    <span class="hljs-number">3.12</span>;<br>        <span class="hljs-string">&#x27;C40&#x27;</span>  -<span class="hljs-number">2</span>     -<span class="hljs-number">1</span>       <span class="hljs-number">0</span>      -<span class="hljs-number">1.36</span>  -<span class="hljs-number">1.42</span>   -<span class="hljs-number">0.68</span>;<br>        <span class="hljs-string">&#x27;C41&#x27;</span>  -<span class="hljs-number">2</span>      <span class="hljs-number">0</span>       <span class="hljs-number">0</span>      -<span class="hljs-number">1.36</span>  -<span class="hljs-number">1.42</span>    <span class="hljs-number">0</span>;<br>        <span class="hljs-string">&#x27;C42&#x27;</span>  -<span class="hljs-number">2</span>     -<span class="hljs-number">1</span>      -<span class="hljs-number">1</span>      -<span class="hljs-number">1.36</span>  -<span class="hljs-number">1.42</span>   -<span class="hljs-number">0.68</span>;<br>        <span class="hljs-string">&#x27;C60&#x27;</span>  <span class="hljs-number">16</span>      <span class="hljs-number">0</span>       <span class="hljs-number">0</span>       <span class="hljs-number">8.32</span>   <span class="hljs-number">7.19</span>    <span class="hljs-number">0</span>;<br>        <span class="hljs-string">&#x27;C61&#x27;</span>  <span class="hljs-number">16</span>      <span class="hljs-number">4</span>       <span class="hljs-number">0</span>       <span class="hljs-number">8.32</span>   <span class="hljs-number">7.19</span>    <span class="hljs-number">2.08</span>;<br>        <span class="hljs-string">&#x27;C62&#x27;</span>  <span class="hljs-number">16</span>      <span class="hljs-number">0</span>       <span class="hljs-number">0</span>       <span class="hljs-number">8.32</span>   <span class="hljs-number">7.19</span>    <span class="hljs-number">0</span>;<br>        <span class="hljs-string">&#x27;C63&#x27;</span>  <span class="hljs-number">16</span>      <span class="hljs-number">4</span>       <span class="hljs-number">4</span>       <span class="hljs-number">8.32</span>   <span class="hljs-number">7.19</span>    <span class="hljs-number">2.08</span>;<br>    &#125;;<br>    HOSth <span class="hljs-built_in">=</span> cell2mat(HOSth(<span class="hljs-number">2</span>:end,<span class="hljs-number">2</span>:end));<br>    <span class="hljs-comment">% 3. 使用高阶矩进行调制识别</span><br>    [~, resUz] <span class="hljs-built_in">=</span> min(pdist2(HOSth<span class="hljs-string">&#x27;, HOS&#x27;</span>, <span class="hljs-string">&#x27;euclidean&#x27;</span>)); <span class="hljs-comment">% 最小距离分类法</span><br>    <span class="hljs-comment">% 4. 输出识别结果</span><br>    modulation_type <span class="hljs-built_in">=</span> get_modulation_type(resUz);<br>    disp([<span class="hljs-string">&#x27;识别的调制方式为: &#x27;</span>, modulation_type]);<br>end<br><br><span class="hljs-comment">% 调制方式的映射函数</span><br>function modulation_type <span class="hljs-built_in">=</span> get_modulation_type(index)<br>    modulation_types <span class="hljs-built_in">=</span> &#123;<span class="hljs-string">&#x27;B-PSK&#x27;</span>, <span class="hljs-string">&#x27;Q-PSK&#x27;</span>, <span class="hljs-string">&#x27;8-PSK&#x27;</span>, <span class="hljs-string">&#x27;4-ASK&#x27;</span>, <span class="hljs-string">&#x27;8-ASK&#x27;</span>, <span class="hljs-string">&#x27;16-QAM&#x27;</span>&#125;;<br>    modulation_type <span class="hljs-built_in">=</span> modulation_types&#123;index&#125;; <span class="hljs-comment">% 获取对应的调制方式</span><br>end<br><br><span class="hljs-comment">% HOS提取函数</span><br>function HOS <span class="hljs-built_in">=</span> f_HOS_Extraction(input_signal, SNR, K, Nt, Nr, pbee, cfo, phznoise)<br>    <span class="hljs-comment">% 信号预处理</span><br>    x <span class="hljs-built_in">=</span> input_signal;  <span class="hljs-comment">% 输入信号</span><br>    scale <span class="hljs-built_in">=</span> modnorm(x, <span class="hljs-string">&#x27;avpow&#x27;</span>, <span class="hljs-number">1</span>);   <span class="hljs-comment">% 归一化</span><br>    x_mod <span class="hljs-built_in">=</span> x * scale;  <span class="hljs-comment">% 归一化信号</span><br>    <span class="hljs-comment">% MIMO信道模拟</span><br>    H <span class="hljs-built_in">=</span> randn(Nr, Nt) + <span class="hljs-number">1</span>i * randn(Nr, Nt);<br>    y_mimo <span class="hljs-built_in">=</span> H * reshape(x_mod, Nt, []);<br>    <span class="hljs-comment">% 载波频率偏移（CFO）和相位噪声模型</span><br>    cfo_mat <span class="hljs-built_in">=</span> repmat(exp(<span class="hljs-number">2</span>i * pi * (<span class="hljs-number">1</span>:<span class="hljs-number">1</span>:K) * cfo), Nr, <span class="hljs-number">1</span>);<br>    y_mimo <span class="hljs-built_in">=</span> y_mimo .* cfo_mat;<br>    <span class="hljs-built_in">if</span> phznoise ~<span class="hljs-built_in">=</span> <span class="hljs-number">0</span><br>        for cptNr <span class="hljs-built_in">=</span> <span class="hljs-number">1</span>:Nr<br>            y_mimo(cptNr, :) <span class="hljs-built_in">=</span> phznoise(y_mimo(cptNr, :).<span class="hljs-string">&#x27;);</span><br><span class="hljs-string">        end</span><br><span class="hljs-string">    end</span><br><span class="hljs-string">    % 加噪声</span><br><span class="hljs-string">    y_mimo_SNR = awgn(y_mimo, SNR, &#x27;</span>measured<span class="hljs-string">&#x27;);</span><br><span class="hljs-string">    Pb = mean(abs(reshape(y_mimo_SNR - y_mimo, 1, []).^2)) + pbee; % 噪声功率估计</span><br><span class="hljs-string">    % BSS（盲源分离）</span><br><span class="hljs-string">    R = mean(real(x_mod).^4) / mean(real(x_mod).^2);</span><br><span class="hljs-string">    [W, yeg] = f_SCMA(Nt, Nr, y_mimo_SNR, R);</span><br><span class="hljs-string">    Pbf = Pb * W.&#x27;</span> * conj(W); <span class="hljs-comment">% 滤波后的噪声功率</span><br>    <span class="hljs-comment">% HOS特征提取</span><br>    for cpt <span class="hljs-built_in">=</span> <span class="hljs-number">1</span>:Nt<br>        HOS(cpt, :) <span class="hljs-built_in">=</span> f_CalcHOS(yeg(cpt, :), Pbf(cpt, cpt));<br>    end<br>end<br><br><span class="hljs-comment">% SCMA函数：用于盲源分离</span><br>function [G, yeg] <span class="hljs-built_in">=</span> f_SCMA(Nt, Nr, y_mimo_SNR, R)<br>    Ry <span class="hljs-built_in">=</span> (y_mimo_SNR * y_mimo_SNR<span class="hljs-string">&#x27;) / size(y_mimo_SNR, 2);</span><br><span class="hljs-string">    [U, SIG] = eig(Ry);  % 特征分解</span><br><span class="hljs-string">    SIG = SIG(Nr:-1:(Nr-Nt+1), Nr:-1:(Nr-Nt+1)); % 确保Nr&gt;=Nt</span><br><span class="hljs-string">    U = U(:, Nr:-1:(Nr-Nt+1));</span><br><span class="hljs-string">    B = (SIG^-0.5) * U&#x27;</span>;  <span class="hljs-comment">% 白化矩阵</span><br>    YW <span class="hljs-built_in">=</span> B * y_mimo_SNR;  <span class="hljs-comment">% 白化信号</span><br>    <span class="hljs-comment">% 初始化分离矩阵</span><br>    W <span class="hljs-built_in">=</span> eye(Nt);<br>    mu <span class="hljs-built_in">=</span> <span class="hljs-number">1</span>e-<span class="hljs-number">2</span>;  <span class="hljs-comment">% 步长</span><br>    <span class="hljs-comment">% 随机梯度下降（SGD）算法</span><br>    for ns <span class="hljs-built_in">=</span> <span class="hljs-number">1</span>:size(YW, <span class="hljs-number">2</span>)<br>        YW_ns <span class="hljs-built_in">=</span> YW(:, ns);<br>        z_ns <span class="hljs-built_in">=</span> W.<span class="hljs-string">&#x27; * YW_ns;</span><br><span class="hljs-string">        for n = 1:Nt</span><br><span class="hljs-string">            e = (real(z_ns(n)).^2 - R) .* real(z_ns(n));</span><br><span class="hljs-string">            W(:, n) = W(:, n) - mu * e .* conj(YW_ns);</span><br><span class="hljs-string">        end</span><br><span class="hljs-string">        W = f_GramSchmidt(W); % 正交化处理</span><br><span class="hljs-string">    end</span><br><span class="hljs-string">    yeg = W.&#x27;</span> * YW;<br>    G <span class="hljs-built_in">=</span> B.<span class="hljs-string">&#x27; * W;</span><br><span class="hljs-string">end</span><br><span class="hljs-string"></span><br><span class="hljs-string">% Gram-Schmidt正交化处理</span><br><span class="hljs-string">function Q = f_GramSchmidt(W)</span><br><span class="hljs-string">    Q = zeros(size(W));</span><br><span class="hljs-string">    Q(:, 1) = W(:, 1) / norm(W(:, 1));</span><br><span class="hljs-string"></span><br><span class="hljs-string">    for i = 2:size(W, 2)</span><br><span class="hljs-string">        s_proj = 0;</span><br><span class="hljs-string">        for j = 1:i-1</span><br><span class="hljs-string">            s_proj = s_proj + ((Q(:, j)&#x27;</span> * W(:, i)) / (Q(:, j)<span class="hljs-string">&#x27; * Q(:, j))) * Q(:, j);</span><br><span class="hljs-string">        end</span><br><span class="hljs-string"></span><br><span class="hljs-string">        e = W(:, i) - s_proj;</span><br><span class="hljs-string">        Q(:, i) = e / norm(e);</span><br><span class="hljs-string">    end</span><br><span class="hljs-string">end</span><br><span class="hljs-string"></span><br><span class="hljs-string">% HOS计算函数</span><br><span class="hljs-string">function hos = f_CalcHOS(x, Pb)</span><br><span class="hljs-string">    x = x - mean(x);</span><br><span class="hljs-string"></span><br><span class="hljs-string">    m20 = real(mean(x.^2));</span><br><span class="hljs-string">    m22 = real(mean(conj(x).^2));</span><br><span class="hljs-string">    m40 = real(mean(x.^4));</span><br><span class="hljs-string">    m60 = real(mean(x.^6));</span><br><span class="hljs-string"></span><br><span class="hljs-string">    m21y = real(mean(x .* (conj(x))));</span><br><span class="hljs-string">    m41y = real(mean((x.^3) .* (conj(x))));</span><br><span class="hljs-string">    m42y = real(mean((x.^2) .* (conj(x).^2)));</span><br><span class="hljs-string">    m43y = real(mean(x .* (conj(x).^3)));</span><br><span class="hljs-string">    m61y = real(mean((x.^5) .* (conj(x))));</span><br><span class="hljs-string">    m62y = real(mean((x.^4) .* (conj(x).^2)));</span><br><span class="hljs-string">    m63y = real(mean((x.^3) .* (conj(x).^3)));</span><br><span class="hljs-string">    m84y = real(mean((x.^4) .* (conj(x).^4)));</span><br><span class="hljs-string"></span><br><span class="hljs-string">    m21 = m21y - Pb;</span><br><span class="hljs-string">    m41 = m41y - 3 * m20 * Pb;</span><br><span class="hljs-string">    m42 = m42y - 2 * Pb^2 - 4 * Pb * m21;</span><br><span class="hljs-string">    m43 = m43y - 3 * m22 * Pb;</span><br><span class="hljs-string">    m61 = m61y - 5 * m40 * Pb;</span><br><span class="hljs-string">    m62 = m62y - 12 * m20 * Pb^2 - 8 * m41 * Pb;</span><br><span class="hljs-string">    m63 = m63y - 18 * m21 * Pb^2 - 9 * m42 * Pb - 6 * Pb^3;</span><br><span class="hljs-string">    m84 = m84y - 16 * m63 * Pb - 72 * m42 * Pb^2 - 96 * m21 * Pb^3 - 24 * Pb^4;</span><br><span class="hljs-string"></span><br><span class="hljs-string">    c40 = m40 - 3 * (m20.^2);</span><br><span class="hljs-string">    c60 = m60 - 15 * m20 * m40 + 30 * (m20.^3);</span><br><span class="hljs-string"></span><br><span class="hljs-string">    c41 = m41 - 3 * m20 * m21;</span><br><span class="hljs-string">    c42 = m42 - (abs(m20).^2) - 2 * (m21.^2);</span><br><span class="hljs-string">    c61 = m61 - 5 * m21 * m40 - 10 * m20 * m41 + 30 * m21 * (m20.^2);</span><br><span class="hljs-string">    c62 = m62 - 6 * m42 * m20 - 8 * m21 * m41 - m22 * m40 + 6 * m22 * m20^2 + 24 * m20 * m21^2;</span><br><span class="hljs-string">    c63 = m63 - 9 * m42 * m21 + 12 * (m21.^3) - 3 * m20 * m43 - 3 * m22 * m41 + 18 * m20 * m21 * m22;</span><br><span class="hljs-string"></span><br><span class="hljs-string">    hos = real([m40 m41 m42 m60 m61 m62 m63 m84 c40 c41 c42 c60 c61 c62 c63]);</span><br><span class="hljs-string">end</span><br><span class="hljs-string"></span><br><span class="hljs-string">Nt = 2;       % 发射天线数量</span><br><span class="hljs-string">Nr = 6;       % 接收天线数量</span><br><span class="hljs-string">K = 4000;     % 传输的MIMO符号数量</span><br><span class="hljs-string">SNR = 10;     % 信噪比（dB）</span><br><span class="hljs-string">pbee = 0.01;  % 噪声功率估计误差</span><br><span class="hljs-string">cfo = 1e-4;   % 载波频率偏移</span><br><span class="hljs-string">phznoise = 0; % 相位噪声模型（0代表无相位噪声）</span><br><span class="hljs-string">% 生成一个模拟的输入信号（例如，16-QAM调制）</span><br><span class="hljs-string">M = 6; % 假设已知的调制类型为16-QAM（M = 6）</span><br><span class="hljs-string">x = randi([0, 15], 1, Nt * K); % 生成16-QAM信号的符号</span><br><span class="hljs-string">x_mod = qammod(x, 16);          % 调制为16-QAM信号</span><br><span class="hljs-string">input_signal = x_mod;           % 输入信号</span><br><span class="hljs-string">% 调用调制识别函数</span><br><span class="hljs-string">modulation_type = modulate_and_identify(input_signal, SNR, Nt, Nr, K, pbee, cfo, phznoise);</span><br><span class="hljs-string">% 显示结果</span><br><span class="hljs-string">disp([&#x27;</span>识别的调制方式为: <span class="hljs-string">&#x27;, modulation_type]);</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>论文复现</category>
      
      <category>信号处理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>论文复现</tag>
      
      <tag>信号处理</tag>
      
      <tag>调制识别</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>汤小丹操作系统大学教材书后答案</title>
    <link href="/2025/05/23/%E6%B1%A4%E5%B0%8F%E4%B8%B9OS%E4%B9%A6%E5%90%8E%E7%AD%94%E6%A1%88/"/>
    <url>/2025/05/23/%E6%B1%A4%E5%B0%8F%E4%B8%B9OS%E4%B9%A6%E5%90%8E%E7%AD%94%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<h2 id="第一章·OS引论"><a href="#第一章·OS引论" class="headerlink" title="第一章·OS引论"></a>第一章·OS引论</h2><h5 id="1-1-设计现代OS的主要目标是什么？"><a href="#1-1-设计现代OS的主要目标是什么？" class="headerlink" title="1.1 设计现代OS的主要目标是什么？"></a>1.1 设计现代OS的主要目标是什么？</h5><blockquote><p>有效性 、方便性 、可扩充性 、开放性</p></blockquote><h5 id="1-2-OS-的作用可表现在哪几个方面？"><a href="#1-2-OS-的作用可表现在哪几个方面？" class="headerlink" title="1.2 OS 的作用可表现在哪几个方面？"></a>1.2 OS 的作用可表现在哪几个方面？</h5><blockquote><p>1.OS 作为用户与计算机硬件系统之间的接</p><p>2.作为计算机系统资源的管理者</p><p>3.OS 实现了对计算机资源的抽象</p></blockquote><h5 id="1-3-为什么说操作系统实现了对计算机资源的抽象？"><a href="#1-3-为什么说操作系统实现了对计算机资源的抽象？" class="headerlink" title="1.3 为什么说操作系统实现了对计算机资源的抽象？"></a>1.3 为什么说操作系统实现了对计算机资源的抽象？</h5><blockquote><p>1、<strong>IO设备管理</strong>软件实现了对计算机硬件操作的第一个层次的抽象；</p><p>2、<strong>文件管理软件</strong>实现了对硬件资源操作的第二个层次的抽象；</p><p>3、依此类推，如果在文件管理软件上再覆盖一层<strong>面向用户的窗口软件</strong>，则用户便可再窗口环境下方便地使用计算机，从而形成一台功能更强的虚拟机；</p><p>4、OS是铺设再计算机硬件上的多层软件的集合，它们不仅增强了系统的功能，还<strong>隐藏了对硬件操作的具体细节</strong>，实现了对计算机硬件操作的多个层次的抽象模型；</p></blockquote><h5 id="1-4-推动多道批处理系统形成和发展的主要动力"><a href="#1-4-推动多道批处理系统形成和发展的主要动力" class="headerlink" title="1.4 推动多道批处理系统形成和发展的主要动力"></a>1.4 推动多道批处理系统形成和发展的主要动力</h5><blockquote><p>（1 ）对计算机资源的利用率的追求</p><p>（2 ）方便用户；</p><p>（3 ）器件的不断更新换代；</p><p>（4 ）计算机体系结构的不断发展。</p></blockquote><h5 id="1-6-推动分时系统发展的动力"><a href="#1-6-推动分时系统发展的动力" class="headerlink" title="1.6 推动分时系统发展的动力"></a>1.6 推动分时系统发展的动力</h5><blockquote><p>（1）CPU的分时使用缩短了作业的平均周转时间；</p><p>（2）<strong>人机交互</strong>能力使用户能直接控制自己的作业；</p><p>（3）<strong>主机的共享</strong>使多用户能同时使用同一台计算机，独立地处理自己的作业。</p></blockquote><h5 id="1-7-实现分时系统的关键问题，如何解决？"><a href="#1-7-实现分时系统的关键问题，如何解决？" class="headerlink" title="1.7 实现分时系统的关键问题，如何解决？"></a>1.7 实现分时系统的关键问题，如何解决？</h5><blockquote><p>及时接受，及时处理</p><p>针对及时接收问题<br>设置<strong>多路卡</strong>，使主机能同时接收用户从各个终端上输入的数据；<br><strong>为每个终端配置缓冲区</strong>，暂存用户键入的命令或数据。</p><p>针对及时处理问题<br>应使<strong>所有的用户作业都直接进入内存</strong>，并且为每个作业分配一个时间片，允许作业只在自己的时间片内运行，这样在不长的时间内，能使每个作业都运行一次。</p></blockquote><h5 id="1-11-OS的几大特性，最基本特征"><a href="#1-11-OS的几大特性，最基本特征" class="headerlink" title="1.11 OS的几大特性，最基本特征"></a>1.11 OS的几大特性，最基本特征</h5><blockquote><p>并发性、共享性、虚拟性和异步性；最基本的特征是并发性和共享性。</p></blockquote><h5 id="1-13-什么是时分复用技术-举例说明它能提高资源利用率的根本原因是什么"><a href="#1-13-什么是时分复用技术-举例说明它能提高资源利用率的根本原因是什么" class="headerlink" title="1.13 什么是时分复用技术? 举例说明它能提高资源利用率的根本原因是什么?"></a>1.13 什么是时分复用技术? 举例说明它能提高资源利用率的根本原因是什么?</h5><blockquote><p>将资源在不同的时间片内分配给各进程以使该资源被重复利用，从而提高资源的利用率，使得用户感觉自己独占主机，而处理机在这期间也被充分的利用。</p></blockquote><h5 id="1-14-是什么原因使操作系统具有异步性特征？"><a href="#1-14-是什么原因使操作系统具有异步性特征？" class="headerlink" title="1.14 是什么原因使操作系统具有异步性特征？"></a>1.14 是什么原因使操作系统具有异步性特征？</h5><blockquote><p>一是<strong>进程的异步性</strong>，进程以人们不可预知的速度向前推进，</p><p>二是<strong>程序的不可再现性</strong>，即程序执行的结果有时是不确定的，</p><p>三是<strong>程序执行时间的不可预知性</strong>，即每个程序何时执行，执行顺序以及完成时间是不确定的。</p></blockquote><h5 id="1-15-处理机管理有哪些主要功能？它们的主要任务是什么？"><a href="#1-15-处理机管理有哪些主要功能？它们的主要任务是什么？" class="headerlink" title="1.15 处理机管理有哪些主要功能？它们的主要任务是什么？"></a>1.15 处理机管理有哪些主要功能？它们的主要任务是什么？</h5><blockquote><p><strong>进程管理</strong>：为作业创建进程，撤销已结束进程，控制进程在运行过程中的状态转换。</p><p><strong>进程同步</strong>：为多个进程（含线程）的运行进行协调。</p><p><strong>进程通信</strong>：用来实现在相互合作的进程之间的信息交换。</p><p><strong>处理机调度</strong>：</p><p>（1 ）作业调度。从后备队里按照一定的算法 ，选出若干个作业，为他们分配运行所需</p><p>的资源（首选是分配内存）。</p><p>（2 ）进程调度：从进程的就绪队列中，按照一定算法选出一个进程，把处理机分配给它，并设置运行现场，使进程投入执行。</p></blockquote><h5 id="1-16-内存管理有哪些主要功能-他们的主要任务是什么？"><a href="#1-16-内存管理有哪些主要功能-他们的主要任务是什么？" class="headerlink" title="1.16 内存管理有哪些主要功能? 他们的主要任务是什么？"></a>1.16 内存管理有哪些主要功能? 他们的主要任务是什么？</h5><blockquote><p><strong>内存分配</strong>：为每道程序分配内存。</p><p><strong>内存保护</strong>：确保每道用户程序都只在自己的内存空间运行，彼此互不干扰。</p><p><strong>地址映射</strong>：将地址空间的逻辑地址转换为内存空间与对应的物理地址。</p><p><strong>内存扩充</strong>：用于实现请求调用功能，置换功能等。</p></blockquote><h5 id="1-17-设备管理有哪些主要功能？其主要任务是什么？"><a href="#1-17-设备管理有哪些主要功能？其主要任务是什么？" class="headerlink" title="1.17 设备管理有哪些主要功能？其主要任务是什么？"></a>1.17 设备管理有哪些主要功能？其主要任务是什么？</h5><blockquote><p>缓冲管理、设备分配、设备处理。虚拟设备</p><p>完成用户提出的 I&#x2F;O 请求，为用户分配 I&#x2F;O 设备；提高 CPU 和 I&#x2F;O 设备的利用率；提高 I&#x2F;O 速度；以及方便用户使用 I&#x2F;O 设备 .</p></blockquote><h2 id="第二章·进程的描述与控制"><a href="#第二章·进程的描述与控制" class="headerlink" title="第二章·进程的描述与控制"></a>第二章·进程的描述与控制</h2><h5 id="2-1-什么是前趋图？为什么要引入前趋图？"><a href="#2-1-什么是前趋图？为什么要引入前趋图？" class="headerlink" title="2.1 什么是前趋图？为什么要引入前趋图？"></a>2.1 什么是前趋图？为什么要引入前趋图？</h5><blockquote><p>前趋图 (Precedence Graph) 是一个有向无循环图，记为DAG(DirectedAcyclic Graph) ，用于描述进程之间执行的前后关系。</p></blockquote><h5 id="2-2-画出下面四条语句的前趋图"><a href="#2-2-画出下面四条语句的前趋图" class="headerlink" title="2.2 画出下面四条语句的前趋图:"></a>2.2 画出下面四条语句的前趋图:</h5><pre><code class="hljs">S1=a: =x+y;S2=b:=z+1;S3=c:=a–b ;S4=w:=c+1;</code></pre><p><img src="/2025/05/23/%E6%B1%A4%E5%B0%8F%E4%B8%B9OS%E4%B9%A6%E5%90%8E%E7%AD%94%E6%A1%88/image-20220627211017-rpcrdez.png"></p><h5 id="2-3-什么程序并发执行会产生间断性特征？"><a href="#2-3-什么程序并发执行会产生间断性特征？" class="headerlink" title="2.3 什么程序并发执行会产生间断性特征？"></a>2.3 什么程序并发执行会产生间断性特征？</h5><blockquote><p>程序在并发执行时，由于它们共享系统资源，为完成同一项任务需要相互合作，致使这些并发执行的进程之间，形成了相互制约关系，从而使得进程在执行期间出现间断性。</p></blockquote><h5 id="2-4-程序并发执行时为什么会失去封闭性和可再现性？"><a href="#2-4-程序并发执行时为什么会失去封闭性和可再现性？" class="headerlink" title="&#x3D;&#x3D;2.4 程序并发执行时为什么会失去封闭性和可再现性？&#x3D;&#x3D;"></a>&#x3D;&#x3D;2.4 程序并发执行时为什么会失去封闭性和可再现性？&#x3D;&#x3D;</h5><blockquote><p>程序并发执行时，多个程序共享系统中的各种资源，因而这些资源的状态由多个程序改变</p></blockquote><h5 id="2-6-试从动态性，并发性和独立性上比较进程和程序。"><a href="#2-6-试从动态性，并发性和独立性上比较进程和程序。" class="headerlink" title="2.6 试从动态性，并发性和独立性上比较进程和程序。"></a>2.6 试从动态性，并发性和独立性上比较进程和程序。</h5><blockquote><p>动态性是进程最基本的特性，而程序只是一组有序的指令集合，是静态实体。</p><p>并发性是进程的重要特征，而程序是不能并发执行的。</p><p>独立性是指进程实体是一个能<strong>独立运行</strong>的基本单位，程序不能作为独立单位参加运行。</p></blockquote><h5 id="2-11-试说明进程在三个基本状态之间转换的典型原因。"><a href="#2-11-试说明进程在三个基本状态之间转换的典型原因。" class="headerlink" title="2.11 试说明进程在三个基本状态之间转换的典型原因。"></a>2.11 试说明进程在三个基本状态之间转换的典型原因。</h5><blockquote><p>（1）就绪状态一执行状态：进程分配到CPU资源</p><p>（2）执行状态一就绪状态：时间片用完</p><p>（3）执行状态一阻塞状态：I&#x2F;0请求</p><p>（4）阻塞状态一就绪状态：I&#x2F;0完成</p></blockquote><h5 id="2-18-试说明引起进程阻塞戒被唤醒的主要事件是什么？"><a href="#2-18-试说明引起进程阻塞戒被唤醒的主要事件是什么？" class="headerlink" title="2.18 试说明引起进程阻塞戒被唤醒的主要事件是什么？"></a>2.18 试说明引起进程阻塞戒被唤醒的主要事件是什么？</h5><blockquote><p>a.请求系统服务；b.启动某种操作；c.新数据尚未到达；d.无新工作可做</p></blockquote><h5 id="2-19-为什么要在0S中引入线程"><a href="#2-19-为什么要在0S中引入线程" class="headerlink" title="2.19 为什么要在0S中引入线程?"></a>2.19 为什么要在0S中引入线程?</h5><blockquote><p>减少程序在并发执行时所付出的时空开销，使0S具有更好的并发性，提高CPU的利用率</p><p>&#x3D;&#x3D;进程是分配资源的基本单位，而线程则是系统调度的基本单位&#x3D;&#x3D;</p></blockquote><h5 id="2-20-试说明线程具有哪些属性"><a href="#2-20-试说明线程具有哪些属性" class="headerlink" title="2.20 试说明线程具有哪些属性?"></a>2.20 试说明线程具有哪些属性?</h5><blockquote><p>（1）轻型实体（2) 独立调度和分派的基本单位（3)可并发执行（4)共享进程资源</p></blockquote><h5 id="2-21-试从调度性，并取性，拥有资源及系统开销方面对进程和线程进行比较。"><a href="#2-21-试从调度性，并取性，拥有资源及系统开销方面对进程和线程进行比较。" class="headerlink" title="2.21 试从调度性，并取性，拥有资源及系统开销方面对进程和线程进行比较。"></a>2.21 试从调度性，并取性，拥有资源及系统开销方面对进程和线程进行比较。</h5><blockquote><p>（1)  调度性。线程在0S中作为调度和分派的基本单位，进程只作为资源拥有的基本单位。</p><p>（2）并发性。进程可以并发执行，一个进程的多个线程也可并发执行。</p><p>（3）拥有资源。进程始终是拥有资源的基本单位，线程只拥有运行时必不可少的资源，本身基本不拥有系统资源，但可以访问隶属进程的资源。</p><p>（4）系统开销。操作系统在创建、撤消和切换进程时付出的开销显著大于线程。</p></blockquote><h2 id="第三章·处理机调度与死锁"><a href="#第三章·处理机调度与死锁" class="headerlink" title="第三章·处理机调度与死锁"></a>第三章·处理机调度与死锁</h2><h5 id="3-1-高级调度与低级调度的主要任务？为什么要引入中级调度"><a href="#3-1-高级调度与低级调度的主要任务？为什么要引入中级调度" class="headerlink" title="3.1 高级调度与低级调度的主要任务？为什么要引入中级调度"></a>3.1 高级调度与低级调度的主要任务？为什么要引入中级调度</h5><blockquote><p>（1）高级调度又称为&#x3D;&#x3D;作业调度&#x3D;&#x3D;。它是批处理系统中使用的一种调度。其主要任务是从外存的后备队列上选择一个或多个作业调入内存，并为其<u>创建进程、分配必要的资源，然后再将所创建的进程控制块插入就绪队列中</u>。</p><p>（2）低级调度又称&#x3D;&#x3D;进程调度&#x3D;&#x3D;。它是距离硬件最近的一级调度。其主要任务是从就绪队列上选择一个（或多个）进程，使其获得CPU。</p><p>（3）&#x3D;&#x3D;引入中级调度的目的&#x3D;&#x3D;是为了提高内存利用率和系统吞吐量。其功能是，让那些暂时不能运行的进程不再占用宝贵的内存资源，而是调其到外存上等候。此时的进程状态为挂起状态。当这些进程重新具备运行条件且内存空闲时，由中级调度选择一部分挂起状态的进程调入内存并将其状态变为就绪状态。</p></blockquote><h5 id="3-2-处理机调度算法的目标？-批处理系统的目标？"><a href="#3-2-处理机调度算法的目标？-批处理系统的目标？" class="headerlink" title="3.2 处理机调度算法的目标？ 批处理系统的目标？"></a>3.2 处理机调度算法的目标？ 批处理系统的目标？</h5><blockquote><p>1.资源利用率，公平性，平衡性，策略强制执行。</p><p>2.平均周转时间短，系统吞吐量高，处理机利用率高。</p></blockquote><h5 id="3-6-高响应比优先调度算法？优点？"><a href="#3-6-高响应比优先调度算法？优点？" class="headerlink" title="3.6 高响应比优先调度算法？优点？"></a>3.6 高响应比优先调度算法？优点？</h5><blockquote><p>因为其同时兼顾了等待时间和运行时间，将该两种因素相结合，让优先级高的程序优先运行。</p></blockquote><h5 id="3-8-抢占调度中抢占的原则？"><a href="#3-8-抢占调度中抢占的原则？" class="headerlink" title="3.8 抢占调度中抢占的原则？"></a>3.8 抢占调度中抢占的原则？</h5><blockquote><p>抢占的原则是：</p><pre><code class="hljs">  1. **优先权原则** ：允许优先级高的进程抢优先级低进程的  2. **短进程优先** ：新到的短时间进程，可以抢占当前长进程的处理机。  3. **时间片原则** ：按照时间片来分配时间来，时间结束就要停止该进程的执行，重新等待时间片分配</code></pre></blockquote><h5 id="3-9-选择调度方式和调度算法的准则？"><a href="#3-9-选择调度方式和调度算法的准则？" class="headerlink" title="3.9 选择调度方式和调度算法的准则？"></a>3.9 选择调度方式和调度算法的准则？</h5><blockquote><p>（1）面向<strong>用户</strong>的准则：周转时间短，响应时间快，截止时间的保证，优先权准则。<br>（2）面向<strong>系统</strong>的准则：系统吞吐量高，处理机利用率好，各类资源的平衡利用。</p></blockquote><h5 id="3-12-比较FCFS和SJF两种进程调度算法"><a href="#3-12-比较FCFS和SJF两种进程调度算法" class="headerlink" title="3.12 比较FCFS和SJF两种进程调度算法"></a>3.12 比较FCFS和SJF两种进程调度算法</h5><blockquote><p><strong>相同点</strong> </p><p>性质相同：都是作为一种调度算法 </p><p>作用对象相同：都可以用于作业调度和进程调度 </p><p><strong>不同点</strong> </p><p>算法思想不同： FCFS算法是指进程调度时是从就绪的进程队列中选择一个最先进入该队列的进程，为之分配处理机，使之投入运行的一种调度算法。 </p><pre><code class="hljs">SJF算法是指以作业的长短来计算优先级，作业越短，其优先级越高，越优先将他们调入内存运行。 优缺点相对 FCFS有利于长作业，不利于短作业 SJF有利于短作业，不利于长作业</code></pre></blockquote><h5 id="3-13-如何确定时间片的大小"><a href="#3-13-如何确定时间片的大小" class="headerlink" title="&#x3D;&#x3D;3.13 如何确定时间片的大小&#x3D;&#x3D;"></a>&#x3D;&#x3D;3.13 如何确定时间片的大小&#x3D;&#x3D;</h5><blockquote><p>时间片应略大于一次典型交互所需的时间</p></blockquote><h5 id="3-15-为什么-多级反馈队列调度算法-能较好的满足各方面用户的需求？"><a href="#3-15-为什么-多级反馈队列调度算法-能较好的满足各方面用户的需求？" class="headerlink" title="3.15 为什么 多级反馈队列调度算法 能较好的满足各方面用户的需求？"></a>3.15 为什么 多级反馈队列调度算法 能较好的满足各方面用户的需求？</h5><blockquote><p>用时间片大小来分配队列：也就是每个规定的队列中的进程，无论长短都用相同长度的时间片</p><p>假设当前进程在此队列中的平均分配的时间片用完了，它还没执行完，就把它放到下一个队列的队尾，排队执行下一个队列再给它 <strong>下一个队列所平均分配的时间片</strong> 。</p><pre><code class="hljs">  在**短批处理作业用户**来说，短作业在第一个队列或者第二队列就被执行完了，效率也十分快，对于**长批处理作业用**户来说，它在尽可能不影响其它进程的情况下，不断在两个或者多个队列中运行，也不用担心长时间得不到处理的情况</code></pre></blockquote><h5 id="3-21-什么是最早截止时间优先调度算法？举例"><a href="#3-21-什么是最早截止时间优先调度算法？举例" class="headerlink" title="3.21 什么是最早截止时间优先调度算法？举例"></a>3.21 什么是最早截止时间优先调度算法？举例</h5><blockquote><p>根据任务的截止时间来确定任务的优先级的算法，任务截止时间越早，其优先级愈高。</p></blockquote><h5 id="3-23-“优先级倒置”现象，怎么解决？"><a href="#3-23-“优先级倒置”现象，怎么解决？" class="headerlink" title="&#x3D;&#x3D;3.23 “优先级倒置”现象，怎么解决？&#x3D;&#x3D;"></a>&#x3D;&#x3D;3.23 “优先级倒置”现象，怎么解决？&#x3D;&#x3D;</h5><blockquote><p><strong>优先级倒置</strong>：高优先级进程被低优先级进程延迟或阻塞的现象。</p><p><strong>解决方法</strong>可以是规定进程在进入临界区后，其所占有的处理机不允许被抢占。</p></blockquote><h5 id="3-27-死锁？原因和条件"><a href="#3-27-死锁？原因和条件" class="headerlink" title="3.27 死锁？原因和条件"></a>3.27 死锁？原因和条件</h5><blockquote><p>如果一组进程中的每一个进程都在等待仅该组进程中的其他进程才能引发的事件，那么该组进程是死锁的。</p><p>原因：（1） 因为系统资源不足。</p><pre><code class="hljs">  （2） 进程运行推进的顺序不合适。  （3） 资源分配不当等。</code></pre><p>条件：（1） 互斥：一个资源每次只能被一个进程使用。</p><pre><code class="hljs">  （2） 请求与保持：一个进程因请求资源而阻塞时，对已获得的资源保持不放。  （3） 不可抢占：进程已获得的资源，在末使用完之前，不能强行剥夺。  （4）循环等待：若干进程之间形成一种头尾相接的循环等待资源关系。</code></pre></blockquote><h5 id="3-29-哪些途径预防死锁"><a href="#3-29-哪些途径预防死锁" class="headerlink" title="3.29 哪些途径预防死锁"></a>3.29 哪些途径预防死锁</h5><blockquote><p><strong>破坏</strong>死锁形成条件</p><p>请求和保持：在运行初获得所需资源，后逐步释放并请求新资源</p><p>不可抢占：占用资源的进程的需求不被满足，就释放它的所有资源</p><p>循环等待：所有资源类型线性排序，赋予序号</p></blockquote><h5 id="3-31-银行家算法中出现以下情况"><a href="#3-31-银行家算法中出现以下情况" class="headerlink" title="3.31 银行家算法中出现以下情况"></a>3.31 银行家算法中出现以下情况</h5><table><thead><tr><th align="center">Process</th><th align="center">Allocation(已分配)</th><th align="center">Need(需要)</th><th align="center">Available(可分配)</th></tr></thead><tbody><tr><td align="center">P0</td><td align="center">0032</td><td align="center">0012</td><td align="center">1622</td></tr><tr><td align="center">P1</td><td align="center">1000</td><td align="center">1750</td><td align="center"></td></tr><tr><td align="center">P2</td><td align="center">1354</td><td align="center">2356</td><td align="center"></td></tr><tr><td align="center">P3</td><td align="center">0332</td><td align="center">0652</td><td align="center"></td></tr><tr><td align="center">P4</td><td align="center">0014</td><td align="center">0656</td><td align="center"></td></tr></tbody></table><h6 id="1-状态是否安全"><a href="#1-状态是否安全" class="headerlink" title="1.状态是否安全"></a>1.状态是否安全</h6><h6 id="2-若P2提出请求request-1，2，2，2-，sys能否分配资源给它"><a href="#2-若P2提出请求request-1，2，2，2-，sys能否分配资源给它" class="headerlink" title="2.若P2提出请求request(1，2，2，2)，sys能否分配资源给它"></a>2.若P2提出请求request(1，2，2，2)，sys能否分配资源给它</h6><blockquote><ol><li><p>就是是否有安全序列<br> P0-&gt;P3-&gt;P4-&gt;P1-&gt;P2<br> 安全</p><table><thead><tr><th align="center">Process</th><th align="center">Work(可分配)</th><th align="center">Need(需要)</th><th align="center">Allocation(已分配)</th><th align="center">Work+Allocation(剩余有)</th></tr></thead><tbody><tr><td align="center">P0</td><td align="center">1622</td><td align="center">0012</td><td align="center">0032</td><td align="center">1654</td></tr><tr><td align="center">P3</td><td align="center">1654</td><td align="center">0652</td><td align="center">0332</td><td align="center">1986</td></tr><tr><td align="center">P4</td><td align="center">1986</td><td align="center">0656</td><td align="center">0014</td><td align="center">199 10</td></tr><tr><td align="center">P1</td><td align="center">199 10</td><td align="center">1750</td><td align="center">1000</td><td align="center">299 10</td></tr><tr><td align="center">P2</td><td align="center">299 10</td><td align="center">2356</td><td align="center">1354</td><td align="center">3 12 14 14</td></tr></tbody></table></li><li><p>P2提出(1，2，2，2)<br> (1，2，2，2)≤Need(2，3，5，6)，是合理的<br> (1，2，2，2)≤Available(1，6，2，2)，是可以满足的<br> 1622-1222&#x3D;0400，0400不能得出安全序列，所以不能分配给他</p></li></ol></blockquote><h2 id="第四章·存储器管理"><a href="#第四章·存储器管理" class="headerlink" title="第四章·存储器管理"></a>第四章·存储器管理</h2><h5 id="4-1-为什么配置层次式存储器？"><a href="#4-1-为什么配置层次式存储器？" class="headerlink" title="4.1 为什么配置层次式存储器？"></a>4.1 为什么配置层次式存储器？</h5><blockquote><p>设置多个存储器可以使存储器的两端能够并行工作，设多级存储系统，例如cache能够最大程度提升系统的性能，设置缓冲可以大大减少IO次数。</p><p><img src="/2025/05/23/%E6%B1%A4%E5%B0%8F%E4%B8%B9OS%E4%B9%A6%E5%90%8E%E7%AD%94%E6%A1%88/9b8822896b390d607a14b18a41fb291-20220626164139-53n1x1o.png" title="层次式存储"></p></blockquote><h5 id="4-2-哪几种方式将程序装入内存？分别适用于什么场合？"><a href="#4-2-哪几种方式将程序装入内存？分别适用于什么场合？" class="headerlink" title="4.2 哪几种方式将程序装入内存？分别适用于什么场合？"></a>4.2 哪几种方式将程序装入内存？分别适用于什么场合？</h5><blockquote><ol><li><strong>绝对装入方式</strong> ：用户程序经过编译后，将产生绝对(物理)地址的目标代码。将目标模块装入到内存中事先指定的位置(只适用于单道)</li><li><strong>可重定位装入方式</strong> ：由于在内存中的0号位只有一个，且本身就已存储了大量的程序，它可以根据内存的具体情况将装入到内存的适当位置。（可重定位的所有逻辑地址与实际装入内存后的物理地址不同。）它可以用于多道程序环境。但是它必须要求程序在运行时，不允许程序在运行的时候在内存中移动位置</li><li><strong>动态重定位</strong> ：使用它装入的时，先把它装入模块装入到内存之后，并不是立即把逻辑地址换为物理地址，而是在程序真正要指定的时候才换，为避免速度缓慢，它中间会有一个<strong>重定位寄存器</strong>的支持。</li></ol></blockquote><h5 id="4-7-为何引入动态重定位？如何实现"><a href="#4-7-为何引入动态重定位？如何实现" class="headerlink" title="4.7 为何引入动态重定位？如何实现"></a>4.7 为何引入动态重定位？如何实现</h5><blockquote><p>引入原因：程序在运行过程中经常要在内存中移动位置，为了保证这些被移动了的程序还能正常执行，必须对程序和数据的地址加以修改，即重定位。引入重定位的目的就是为了满足程序的这种需要。<br><strong>实现</strong>：要在不影响指令执行速度的同时实现地址变换，必须有硬件地址变换机构的支持，即须在系统中增设一个<strong>重定位寄存器</strong>，<u>用它来存放程序在内存中的起始地址</u>。程序在执行时，真正访问的内存地址是<u>相对地址与重定位寄存器中的地址相加</u>而形成的。</p></blockquote><h5 id="4-8-基于顺序搜索的动态分区算法，分为哪几种"><a href="#4-8-基于顺序搜索的动态分区算法，分为哪几种" class="headerlink" title="4.8 基于顺序搜索的动态分区算法，分为哪几种"></a>4.8 基于顺序搜索的动态分区算法，分为哪几种</h5><blockquote><p>依次搜索空闲分区链上的空闲分区，去寻找一个其大小都满足要求的分区。</p><p>  1.<strong>首次适应(first fit,FF)算法</strong></p><p>  FF算法要求空闲分区链以地址递增的次序链接，链首开始往后找，直到找到为止，没有就失败返回</p><p>  2.<strong>循环首次适应(next fit,NF)算法</strong></p><p>  每次从上一次找到的空闲区的下一段开始找，设置一个始查寻指针</p><p>  3.<strong>最佳适应(best fit,BF)算法</strong></p><p>  将空闲分区按容量从小到大分配。但是分配后切下来剩下的部分总是最小的。</p><p>  4.<strong>最坏适应(worst fit,WF)算法</strong></p><p>  总挑最大的从中切部分使用，空闲分区按大小从小到大排列，以至于存储器中缺乏大的空闲分区。</p></blockquote><h5 id="4-9-首次适应算法回收内存，可能出现什么情况？如何处理？"><a href="#4-9-首次适应算法回收内存，可能出现什么情况？如何处理？" class="headerlink" title="4.9 首次适应算法回收内存，可能出现什么情况？如何处理？"></a>4.9 首次适应算法回收内存，可能出现什么情况？如何处理？</h5><blockquote><p>1、回收区与插入点的<strong>前一个空闲分区F1相邻接</strong>，此时应将回收区与插入点的前一分区合并，不必为回收分区分配新表项，而只须修改其前一分区F1的大小。</p><p>2、回收区与插入点的<strong>后一个空闲分区F2相邻接</strong>，此时应将两分区合并，形成新的空闲分区，但用回收区的首址作为新空闲分区的首址，大小为两者之和。</p><p>3、回收区同时与插入点的<strong>前、后两个分区邻接</strong>，此时将三个分区合并，使用F1的表项和F1的首址，取消F2的表项,大小为三者之和。</p><p>4、回收区<strong>既不与F1邻接，又不与F2邻接</strong>。这时应为回收区单独建立一新表项,添写回收区的首址和大小，并根据其首址插入到空闲链中的适当位置。</p></blockquote><h5 id="4-10-基于索引搜索的动态分区分配算法，分为哪几种？"><a href="#4-10-基于索引搜索的动态分区分配算法，分为哪几种？" class="headerlink" title="4.10 基于索引搜索的动态分区分配算法，分为哪几种？"></a>4.10 基于索引搜索的动态分区分配算法，分为哪几种？</h5><blockquote><p>为了提高搜索空间的分区的速度，在中大型系统中往往会采用基于索引搜索的动态分区分配算法</p><p>哈希算法、快速适应算法以及伙伴系统</p></blockquote><h5 id="4-11-令buddyk-x-为大小为2k、地址为x的块的伙伴系统地址，写出buddyk-x-的通用表达式"><a href="#4-11-令buddyk-x-为大小为2k、地址为x的块的伙伴系统地址，写出buddyk-x-的通用表达式" class="headerlink" title="&#x3D;&#x3D;4.11 令buddyk(x)为大小为2k、地址为x的块的伙伴系统地址，写出buddyk(x)的通用表达式&#x3D;&#x3D;"></a>&#x3D;&#x3D;4.11 令buddyk(x)为大小为2k、地址为x的块的伙伴系统地址，写出buddyk(x)的通用表达式&#x3D;&#x3D;</h5><blockquote><p>buddy<sub>k</sub>(x) &#x3D; x+2<sup>k</sup> （当x mod 2<sup>k+1</sup>&#x3D;0）</p><p>buddy<sub>k</sub>(x) &#x3D; x-2<sup>k</sup> （当x mod 2<sup>k+1</sup>&#x3D;2<sup>k</sup>）</p></blockquote><h5 id="4-12-分区存储管理常用的分配策略？比较优缺点"><a href="#4-12-分区存储管理常用的分配策略？比较优缺点" class="headerlink" title="4.12 分区存储管理常用的分配策略？比较优缺点"></a>4.12 分区存储管理常用的分配策略？比较优缺点</h5><blockquote><p><strong>首次适应算法</strong>的优缺点：保留了高址部分的大空闲区；低址部分不断被划分，留下许多<strong>碎片</strong>，且每次分区分配查找时都是从低址部分开始，会增加查找时的系统开销。</p><p><strong>循环首次适应算法</strong>的优缺点：使内存中的空闲分区分布得更为均匀，减少了查找时的系统开销；<strong>缺乏大的空闲分区</strong>，从而导致不能装入大型作业。</p><p><strong>最佳适应算法</strong>的优缺点：每次分配给文件的都是最适合该文件大小的分区；内存中留下许多<strong>碎片</strong>。</p><p><strong>最坏适应算法</strong>的优缺点：给文件分配分区后剩下的的空闲区不至于太小，<strong>产生碎片的几率最小</strong>，对中小型文件分配分区操作有利；使存储器中<strong>缺乏大的空闲区</strong>，对大型文件的分区分配不利。</p></blockquote><h5 id="4-13-为什么引入对换？对换的类型？"><a href="#4-13-为什么引入对换？对换的类型？" class="headerlink" title="4.13 为什么引入对换？对换的类型？"></a>4.13 为什么引入对换？对换的类型？</h5><blockquote><p>在多道环境下，一方面，在内存中的某些进程由于某事件尚未发生而被阻塞，但它却占用了大量的内存空间，甚至有时可能出现在内存中所有进程都被阻塞而迫使CPU停止下来等待的情况；</p><p>　　另一方面，却又有着许多作业在外存上等待，因无内存而不能进入内存运行的情况。显然这对系统资源是一种严重的浪费，且使系统吞吐量下降。为了解决这一问题，在操作系统中引入了对换（也称交换）技术。<br>　　可以将整个进程换入、换出（<strong>整体对换</strong>），也可以将进程的一部分（页、段）换入、换出（<strong>页面(分段)对换</strong>）。前者主要用于缓解目前系统中内存的不足，后者主要用于实现虚拟存储。</p></blockquote><h5 id="4-18-什么是页面？什么是物理块？页面大小如何确定？"><a href="#4-18-什么是页面？什么是物理块？页面大小如何确定？" class="headerlink" title="4.18 什么是页面？什么是物理块？页面大小如何确定？"></a>4.18 什么是页面？什么是物理块？页面大小如何确定？</h5><blockquote><p>页面：分页存储管理将进程的<strong>逻辑地址空间</strong>分成若干个页，并为各页加以编号。</p><p>物理块：把内存的<strong>物理地址空间</strong>分成若干个块，并为各块加以编号。</p><p>页面大小应选择适中，且页面大小应该是2的幂，通常为1KB~8KB。</p></blockquote><h5 id="4-19-what-is-页表？页表的作用是什么？"><a href="#4-19-what-is-页表？页表的作用是什么？" class="headerlink" title="4.19 what is 页表？页表的作用是什么？"></a>4.19 what is 页表？页表的作用是什么？</h5><blockquote><p>页表是分页式存储管理使用的数据结构。一个进程分为多少页，它的页表就有多少行。每一行记录进程的一页和它存放的物理块的页号、块号对应关系。页表用于进行地址变换。</p></blockquote><h5 id="4-20-为实现分页存储管理，需要哪些硬件支持？"><a href="#4-20-为实现分页存储管理，需要哪些硬件支持？" class="headerlink" title="&#x3D;&#x3D;4.20 为实现分页存储管理，需要哪些硬件支持？&#x3D;&#x3D;"></a>&#x3D;&#x3D;4.20 为实现分页存储管理，需要哪些硬件支持？&#x3D;&#x3D;</h5><blockquote><p>需要有<strong>页表机制</strong>、<strong>地址变换机构</strong>的硬件支持。</p></blockquote><h5 id="4-22-具有快表时是如何地址变换的"><a href="#4-22-具有快表时是如何地址变换的" class="headerlink" title="&#x3D;&#x3D;4.22 具有快表时是如何地址变换的&#x3D;&#x3D;"></a>&#x3D;&#x3D;4.22 具有快表时是如何地址变换的&#x3D;&#x3D;</h5><blockquote><p>1.系统将有效地址(逻辑地址)中的页号与<strong>页表寄存器</strong>中的内容比较，若<strong>页号太大</strong>，表示访问越界，于是产生<strong>越界中断</strong></p><p>2.IF未出现越界情况，地址变换机构自动地将页号P送入<strong>输入寄存器</strong>，再确定所需要的页是否在<strong>快表(高速缓存)</strong> 中。<br>IF在则直接读出该页所对应的物理块号，并送入<strong>物理地址寄存器</strong>；<br>IF在快表中未找到对应的页表项，需再访问内存中页表，找到后，把读出的页表项存入快表中的一个寄存器单元中，以取代一个老页表项。</p><p>同时，再将<strong>页内地址</strong>直接送入<strong>物理地址寄存器</strong>， 从而完成了从逻辑地址到物理地址的转换。</p><p><img src="/2025/05/23/%E6%B1%A4%E5%B0%8F%E4%B8%B9OS%E4%B9%A6%E5%90%8E%E7%AD%94%E6%A1%88/278c9c9279d5df643f7304e6b781111-20220627154123-lgb7gq5.png"></p></blockquote><h5 id="4-24-具有快表的段页式存储管理系统中，如何实现地址变换？"><a href="#4-24-具有快表的段页式存储管理系统中，如何实现地址变换？" class="headerlink" title="&#x3D;&#x3D;4.24 具有快表的段页式存储管理系统中，如何实现地址变换？&#x3D;&#x3D;"></a>&#x3D;&#x3D;4.24 具有快表的段页式存储管理系统中，如何实现地址变换？&#x3D;&#x3D;</h5><blockquote><p>1.段号与段表寄存器中记录的段表长度比较，判断越界</p><p>2.无越界，段号与段表寄存器的段表始址求出该段的页表始址</p><p>3.页表始址与逻辑地址中的页号求出对应页表项，读出该页所在的物理块号b，再利用块号b和页内地址来构成物理地址。</p><p><img src="/2025/05/23/%E6%B1%A4%E5%B0%8F%E4%B8%B9OS%E4%B9%A6%E5%90%8E%E7%AD%94%E6%A1%88/f6889844895424c7da8655c79b3c933-20220627160250-h16db83.png"></p></blockquote><h5 id="4-26-分页和分段存储管理有何区别"><a href="#4-26-分页和分段存储管理有何区别" class="headerlink" title="4.26 分页和分段存储管理有何区别"></a>4.26 分页和分段存储管理有何区别</h5><blockquote><p>同：分页和分段都采用离散分配的方式，且都要通过地址映射机构来实现地址变换</p><p>区别：<br>1. 页是<strong>信息的物理单位</strong>，分页是为实现离散分配方式，以消减内存的碎片，提高内存的利用率，满足系统管理的需要，而不是用户的需要<br>    段是<strong>信息的逻辑单位</strong>，它含有一组其意义相对完整的信息，目的是为了能更好地满足用户的需要</p><pre><code class="hljs">2. 页的**大小**固定且由系统确定，而段的大小却不固定，决定于用户所编写的程序3. 分页的作业地址空间是**一维**的，而分段的作业地址空间是**二维**的。4. 段是信息的逻辑单位，便于存储保护和信息的共享，页的**保护和共享**受到限制。</code></pre></blockquote><h2 id="第五章·虚拟存储器"><a href="#第五章·虚拟存储器" class="headerlink" title="第五章·虚拟存储器"></a>第五章·虚拟存储器</h2><h5 id="5-1-常规存储器管理方式有哪两大特征？对系统性能有何影响？"><a href="#5-1-常规存储器管理方式有哪两大特征？对系统性能有何影响？" class="headerlink" title="5.1 常规存储器管理方式有哪两大特征？对系统性能有何影响？"></a>5.1 常规存储器管理方式有哪两大特征？对系统性能有何影响？</h5><blockquote><ol><li><strong>一次性</strong> ：是指作业必须一次性全部装到内存中才能开始运行</li><li><strong>驻留性</strong> :也就是在作业装入内存后，整个作业一直在内存中。直到作业结束。</li></ol><p>  上述两大特性使得许多在程序运行中不用或暂时不用的程序(数据)<strong>占据了大量的内存空间</strong>，而一些需要运行的作业又无法再装进运行。</p></blockquote><h5 id="5-2-时间局限性，空间局限性"><a href="#5-2-时间局限性，空间局限性" class="headerlink" title="&#x3D;&#x3D;5.2 时间局限性，空间局限性&#x3D;&#x3D;"></a>&#x3D;&#x3D;5.2 时间局限性，空间局限性&#x3D;&#x3D;</h5><blockquote><p>最近被访问的单元，很可能在不久的将来还要被访问<br>最近被访问的单元，很可能它附近的单元也即将被访问</p></blockquote><h5 id="5-3-虚存特征，最本质特征"><a href="#5-3-虚存特征，最本质特征" class="headerlink" title="5.3 虚存特征，最本质特征"></a>5.3 虚存特征，最本质特征</h5><blockquote><ul><li><strong>多次性</strong> ：是指无需在作业运行时一次性地全部装入内存，而是允许被分成多次调入内存运行。（利用了局部性原理）</li><li>对换性（交换性）：是指无需在作业运行时一直常驻内存，而是允许在作业的运行过程中，进行换进和换出。</li><li>虚拟性：是指从逻辑上扩充内存的容量，使用户所看到的的内存容量，远大于实际的内存容量。</li></ul></blockquote><h5 id="5-4-虚存需要哪些硬件支持？"><a href="#5-4-虚存需要哪些硬件支持？" class="headerlink" title="5.4  虚存需要哪些硬件支持？"></a>5.4  虚存需要哪些硬件支持？</h5><blockquote><p>请求分页的页表机制+缺页中断机构+地址变换机构</p></blockquote><h5 id="5-5-实现虚存的关键技术"><a href="#5-5-实现虚存的关键技术" class="headerlink" title="5.5 实现虚存的关键技术"></a>5.5 实现虚存的关键技术</h5><blockquote><p><img src="/2025/05/23/%E6%B1%A4%E5%B0%8F%E4%B8%B9OS%E4%B9%A6%E5%90%8E%E7%AD%94%E6%A1%88/94d5227f4647b9b45e0134b6bee9bba-20220627162414-dfxz0pf.png"><img src="/2025/05/23/%E6%B1%A4%E5%B0%8F%E4%B8%B9OS%E4%B9%A6%E5%90%8E%E7%AD%94%E6%A1%88/a184f24cf5b06131769ab2b75e695ea-20220627162441-4lii2lh.png" alt="a184f24cf5b06131769ab2b75e695ea.png"></p></blockquote><h5 id="5-7-缺页中断机构与一般的中断有何区别？"><a href="#5-7-缺页中断机构与一般的中断有何区别？" class="headerlink" title="5.7 缺页中断机构与一般的中断有何区别？"></a>5.7 缺页中断机构与一般的中断有何区别？</h5><blockquote><p>（1）在<strong>指令执行期间</strong>产生和处理中断信号，CPU通常在一条指令执行完后检查是否有中断请求。而缺页中断是在指令执行期间，发现所要访问的指令或数据不在内存时产生和处理的。</p><p>（2）<strong>一条指令</strong>在执行期间可能产生<strong>多次</strong>缺页中断。如一条读取数据的多字节指令，指令本身跨越两个页面，若指令后一部分所在页面和数据所在页面均不在内存，则该指令的执行至少产生两次缺页中断。</p></blockquote><h5 id="5-8-请求分页系统地址变换过程"><a href="#5-8-请求分页系统地址变换过程" class="headerlink" title="5.8 请求分页系统地址变换过程"></a>5.8 请求分页系统地址变换过程</h5><blockquote><p><img src="/2025/05/23/%E6%B1%A4%E5%B0%8F%E4%B8%B9OS%E4%B9%A6%E5%90%8E%E7%AD%94%E6%A1%88/image-20220627171237-p6cx0e5.png"></p><p>新增操作</p><ol><li>请求调页（查找页表项时对状态位进行判断）</li><li>页面置换（若内存块没空间给外存调入，就用页面置换算法置换一个页面出去）</li><li>操作时要修改页表项</li></ol></blockquote><h5 id="5-12-在请求分页系统有哪几种页面置换算法"><a href="#5-12-在请求分页系统有哪几种页面置换算法" class="headerlink" title="5.12 在请求分页系统有哪几种页面置换算法"></a>5.12 在请求分页系统有哪几种页面置换算法</h5><blockquote><p>先进先出FIFO、最近最少使用LFU、最佳置换OPT、最近最久未使用LRU、CLOCK、改进型CLOCK</p></blockquote><h5 id="5-13-用FIFO，假设页面走向为4、3、2、1、4、3、5、4、3、2、1、5，当分配物理块分别为3，4时，计算缺页次数和缺页率"><a href="#5-13-用FIFO，假设页面走向为4、3、2、1、4、3、5、4、3、2、1、5，当分配物理块分别为3，4时，计算缺页次数和缺页率" class="headerlink" title="5.13 用FIFO，假设页面走向为4、3、2、1、4、3、5、4、3、2、1、5，当分配物理块分别为3，4时，计算缺页次数和缺页率"></a>5.13 用FIFO，假设页面走向为4、3、2、1、4、3、5、4、3、2、1、5，当分配物理块分别为3，4时，计算缺页次数和缺页率</h5><blockquote><p><img src="/2025/05/23/%E6%B1%A4%E5%B0%8F%E4%B8%B9OS%E4%B9%A6%E5%90%8E%E7%AD%94%E6%A1%88/83355132f4148a1b1f739c2d8608ec0-20220627203203-9g2otxp.png" title="FIFO"><img src="/2025/05/23/%E6%B1%A4%E5%B0%8F%E4%B8%B9OS%E4%B9%A6%E5%90%8E%E7%AD%94%E6%A1%88/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220627204145-20220627204230-m199dmi.jpg" alt="微信图片_20220627204145.jpg" title="LRU"></p></blockquote><h5 id="5-14-LRU算法的硬件支持"><a href="#5-14-LRU算法的硬件支持" class="headerlink" title="5.14 LRU算法的硬件支持"></a>5.14 LRU算法的硬件支持</h5><blockquote><p>需要<strong>寄存器和栈</strong>等硬件支持。<strong>寄存器</strong>用于记录某进程在内存中各页的使用情况，<strong>栈</strong>用于保存当前使用的各个页面的页面号。</p></blockquote><h5 id="5-15-改进型CLOCK算法的基本原理"><a href="#5-15-改进型CLOCK算法的基本原理" class="headerlink" title="5.15 改进型CLOCK算法的基本原理"></a>5.15 改进型CLOCK算法的基本原理</h5><blockquote><p>因为修改过的页面在换出时付出的开销比未被修改过的页面大，在改进型Clock算法中，既考虑页面的使用情况，还要增加置换代价的因素；在选择页面作为淘汰页面时，把<strong>同时满足未使用过和未被修改作为首选淘汰页面</strong>。</p></blockquote><h5 id="5-18-“抖动”产生的原因是什么？"><a href="#5-18-“抖动”产生的原因是什么？" class="headerlink" title="5.18 “抖动”产生的原因是什么？"></a>5.18 “抖动”产生的原因是什么？</h5><blockquote><p>抖动（Thrashing) 就是指当内存中已无空闲空间而又发生缺页中断时，需要从内存中调出一页进程，如果算法不适当，刚被换出的页很快被访问，需重新调入，因此需再选一页调出，而此时被换出的页很快又要被访问，因而又需将它调入，如此频繁更换页面，使得系统把大部分时间用在了页面的调进换出上，而几乎不能完成任何有效的工作，我们称这种现象为”抖动”。</p><p>原因：供不应求（进程需要访问的页面数目大于可用的物理页帧数目）。请求分页系统中的每个进程只能分配到所需全部内存空间的一部分</p></blockquote><h5 id="5-19-什么是工作集，基于什么原理确定"><a href="#5-19-什么是工作集，基于什么原理确定" class="headerlink" title="5.19 什么是工作集，基于什么原理确定"></a>5.19 什么是工作集，基于什么原理确定</h5><blockquote><p>工作集（或驻留集）是指在某段时间间隔内，进程要访问的页面集合。经常被使用的页面需要在工作集中，而长期不被使用的页面要从工作集中被丢弃。为了防止系统出现抖动现象，需要选择合适的工作集大小。</p><p>确定原理：（局部性原理）用程序的过去某段时间内的行为作业程序在将来某段时间内行为的 <strong>近似</strong> 。</p><p>工作原理：让操作系统跟踪每个进程的工作集，并为进程分配大于其工作集的物理块。如果还有空闲物理块，则可以再调一个进程到内存以增加多道程序数。<br>如果所有工作集之和增加以至于超过了可用物理块的总数，那么操作系统会<strong>暂停一个进程</strong>，将其页面调出并且将其物理块分配给其他进程，防止出现抖动现象。</p></blockquote><h5 id="5-20-哪几种方法防止抖动？"><a href="#5-20-哪几种方法防止抖动？" class="headerlink" title="5.20 哪几种方法防止抖动？"></a>5.20 哪几种方法防止抖动？</h5><blockquote><ol><li><strong>局部置换策略</strong> ：预防抖动，当进程发生缺页，只能在分配给自己的内存空间内进行置换。</li><li><strong>把工作集算法融入到处理机调度中</strong> ：融入了工作集算法，多一道检查进程在调度中融入了工作集算法。必须检测每个进程在内存的驻留页面足够多才调入，那些不足的增加新的物理块</li></ol><p>  3.<strong>利用”L&#x3D;S”准则调节缺页率</strong>：</p><pre><code class="hljs">  L是缺页之间的平均时间，S是平均缺页服务时间，用于置换一个页面所需的时间  L&gt;&gt;S说明很少发生缺页，否则说明经常发生缺页，速度也超过了磁盘的处理能力。  只有两者接近的时候才是磁盘与处理机达到最大利用率。</code></pre><ol start="4"><li><strong>选择暂停的进程</strong> :在多道程序度偏高时，系统必须减少多道程序的数目，暂停优先级低的进程。</li></ol></blockquote><h5 id="5-22-为了实现分段式存储管理，应在系统中增加哪些硬件机构？"><a href="#5-22-为了实现分段式存储管理，应在系统中增加哪些硬件机构？" class="headerlink" title="&#x3D;&#x3D;5.22 为了实现分段式存储管理，应在系统中增加哪些硬件机构？&#x3D;&#x3D;"></a>&#x3D;&#x3D;5.22 为了实现分段式存储管理，应在系统中增加哪些硬件机构？&#x3D;&#x3D;</h5><blockquote><p>请求段表机制、缺段中断机制、地址变换机构</p></blockquote><h2 id="第六章·输入输出系统"><a href="#第六章·输入输出系统" class="headerlink" title="第六章·输入输出系统"></a>第六章·输入输出系统</h2><h5 id="6-1-I-O系统的基本功能"><a href="#6-1-I-O系统的基本功能" class="headerlink" title="6.1 I&#x2F;O系统的基本功能"></a>6.1 I&#x2F;O系统的基本功能</h5><blockquote><ol><li>隐藏物理设备的细节</li><li>保证OS与设备的无关性</li><li>提高处理机和I&#x2F;O设备的利用率</li><li>对I&#x2F;O设备进行控制 (驱动程序)</li><li>确保对设备的正确共享 (独占设备&#x2F;共享设备)</li><li>错误处理 (临时性错误&#x2F;永久性错误)</li></ol></blockquote><h5 id="6-2-I-O软件的4个层次"><a href="#6-2-I-O软件的4个层次" class="headerlink" title="6.2 I&#x2F;O软件的4个层次"></a>6.2 I&#x2F;O软件的4个层次</h5><blockquote><p> <strong>用户层I&#x2F;O软件</strong>，实现与用户交互的接口，用户可直接调用该层所提供的、与IO操作有关的库函数对设备进行操作。</p><p> <strong>设备独立性软件</strong>，用于实现用户程序与设备驱动器的统一接口、设备命名、保护以及分配与释放等，为设备管理和数据传送提供必要的存储空间。</p><p> <strong>设备驱动程序</strong>，与硬件直接相关，用于具体实现系统对设备发出的操作指令，驱动I&#x2F;O设备工作的驱动程序。</p><p><strong>中断处理程序</strong>，用于保存被中断进程的CPU环境，转入相应的中断处理程序进行处理，处理完毕再恢复被中断进程的现场后，返回到被中断的进程。</p></blockquote><h5 id="6-3-I-O系统接口与软件-硬件接口分别是什么接口"><a href="#6-3-I-O系统接口与软件-硬件接口分别是什么接口" class="headerlink" title="6.3 I&#x2F;O系统接口与软件&#x2F;硬件接口分别是什么接口"></a>6.3 I&#x2F;O系统接口与软件&#x2F;硬件接口分别是什么接口</h5><blockquote><p><strong>I&#x2F;O系统接口</strong>：作为I&#x2F;O系统与上层系统之间的接口，向上层提供对设备进行操作的抽象I&#x2F;O命令，以方便高层对设备的使用。</p><p><strong>软件&#x2F;硬件接口</strong>：上面是中断处理程序和用于不同设备的设备驱动程序，它的下面是各种设备的控制器。</p></blockquote><h5 id="6-4-与设备无关性的基本含义？为什么设置该层"><a href="#6-4-与设备无关性的基本含义？为什么设置该层" class="headerlink" title="6.4 与设备无关性的基本含义？为什么设置该层"></a>6.4 与设备无关性的基本含义？为什么设置该层</h5><blockquote><p><strong>I&#x2F;O系统分层</strong>：中断处理程序+设备驱动程序+与设备无关的I&#x2F;O软件</p><p>基本含义：应用程序基本使用的物理设备。为实现设备独立性而引入了逻辑设备和物理设备两概念。在应用程序中，使用逻辑设备名称来请求使用某类设备；而系统在实际执行时，还必须使用物理设备名称。</p><p>为了提高OS的可适应性和可扩展性，易于实现I&#x2F;O重定向</p></blockquote><h5 id="6-7-内存I-O映像，如何实现"><a href="#6-7-内存I-O映像，如何实现" class="headerlink" title="6.7 内存I&#x2F;O映像，如何实现"></a>6.7 内存I&#x2F;O映像，如何实现</h5><blockquote><p>外围设备映射到内存空间便于CPU访问</p><p>编址上<strong>不区分</strong>内存单元地址和设备驱动器的寄存器地址，都采用k。k在0~n-1认为是内存地址，k≥n认为是寄存器地址</p></blockquote><h5 id="6-8-为什么说中断时OS赖以生存的基础？"><a href="#6-8-为什么说中断时OS赖以生存的基础？" class="headerlink" title="&#x3D;&#x3D;6.8 为什么说中断时OS赖以生存的基础？&#x3D;&#x3D;"></a>&#x3D;&#x3D;6.8 为什么说中断时OS赖以生存的基础？&#x3D;&#x3D;</h5><blockquote><ol><li>它是多道程序得以实现的基础,没有中断,就不可能实现多道程序,因为<strong>进程切换</strong>是通过中断来完成的</li><li>中断也是<strong>设备管理</strong>的基础,为了提高处理机的利用率和实现CPU和I&#x2F;O设备并执行,也必需有中断支持</li></ol></blockquote><h5 id="6-16-有哪几种I-O控制方式？适用于何种场合？"><a href="#6-16-有哪几种I-O控制方式？适用于何种场合？" class="headerlink" title="6.16 有哪几种I&#x2F;O控制方式？适用于何种场合？"></a>6.16 有哪几种I&#x2F;O控制方式？适用于何种场合？</h5><blockquote><p>程序I&#x2F;O方式，中断驱动I&#x2F;O控制方式，DMA I&#x2F;O控制方式，I&#x2F;O通道控制方式</p><p><strong>程序I&#x2F;O</strong>适用于早期的计算机系统中,并且是无中断的计算机系统</p><p><strong>中断驱动I&#x2F;O</strong>控制方式是普通用于现代的计算机系统中</p><p><strong>DMA I&#x2F;O</strong>控制方式适用于I&#x2F;O设备为块设备时在和主机进行数据交换的一种I&#x2F;O控制方式</p><p>当I&#x2F;O设备和主机进行数据交换是一组数据块时通常采用<strong>I&#x2F;O通道</strong>控制方式,但此时要求系统必须配置相应的通道控制器</p></blockquote><h5 id="6-17-DMA的工作流程"><a href="#6-17-DMA的工作流程" class="headerlink" title="6.17 DMA的工作流程"></a>6.17 DMA的工作流程</h5><blockquote><p>当CPU要从磁盘读入数据块时，先向磁盘控制器发送一条读命令。 </p><p>该命令被送到<strong>命令寄存器CR</strong>中。同时还发送本次要读入数据的<strong>内存起始目标地址，送入内存地址寄存器MAR</strong></p><p>本次要读数据的<strong>字节数送入数据计数器DC</strong>，将磁盘中的源地址直接送入DMA控制器的I&#x2F;O 控制逻辑上。</p><p>然后启动DMA 控制器传送数据，以后CPU 便处理其它任务。整个数据传送过程由DMA控制器控制</p></blockquote><h5 id="6-18-为何引入设备无关性？如何实现设备独立性？"><a href="#6-18-为何引入设备无关性？如何实现设备独立性？" class="headerlink" title="6.18 为何引入设备无关性？如何实现设备独立性？"></a>6.18 为何引入设备无关性？如何实现设备独立性？</h5><blockquote><p>设备分配的灵活性，易于实现I&#x2F;O重定向</p><p>引入逻辑设备与物理设备概念，应用程序使用逻辑设备名请求设备，经过驱动程序的映射转为物理设备名，并向用户层软件提供统一接口</p></blockquote><h5 id="6-21-设备虚拟，及其关键技术"><a href="#6-21-设备虚拟，及其关键技术" class="headerlink" title="6.21 设备虚拟，及其关键技术"></a>6.21 设备虚拟，及其关键技术</h5><blockquote><p>通过虚拟技术可将一台独占设备变换成若干台逻辑设备,供若干个用户(进程)同时使用,通常把这种经过虚拟技术处理后的设备称为虚拟设备</p><p>SPOOLING技术</p></blockquote><h5 id="6-24-引入缓冲的原因"><a href="#6-24-引入缓冲的原因" class="headerlink" title="6.24 引入缓冲的原因"></a>6.24 引入缓冲的原因</h5><blockquote><p>缓和CPU与I&#x2F;O设备之间速度不匹配的矛盾<br>减少对CPU的中断频率<br>解决DMA或通道方式下数据传输的瓶颈问题<br>提高CPU和I&#x2F;O设备之间的并行性</p></blockquote><h5 id="6-25-在单缓冲情况下-为什么系统对一块数据的处理时间是max-C-T-M"><a href="#6-25-在单缓冲情况下-为什么系统对一块数据的处理时间是max-C-T-M" class="headerlink" title="6.25 在单缓冲情况下,为什么系统对一块数据的处理时间是max(C,T)+M"></a>6.25 <strong>在单缓冲情况下,为什么系统对一块数据的处理时间是max(C,T)+M</strong></h5><blockquote><p>因为<strong>用户输入操作</strong>时间T和<strong>CPU计算时间</strong>C可以并行，操作系统将缓冲区数据传送给用户区的时间为M</p></blockquote><h5 id="6-26-为什么在双缓冲情况下-系统对一块数据的处理时间为max-T-C"><a href="#6-26-为什么在双缓冲情况下-系统对一块数据的处理时间为max-T-C" class="headerlink" title="6.26 为什么在双缓冲情况下,系统对一块数据的处理时间为max(T,C)?"></a>6.26 <strong>为什么在双缓冲情况下,系统对一块数据的处理时间为max(T,C)?</strong></h5><blockquote><p>在双缓冲区中,不仅设备的输入操作和CPU的处理操作可以并行,设备的输入操作和数据的传送操作也可以并行</p></blockquote><h5 id="6-31-目前常用的磁盘调度算法有哪几种-每种算法优先考虑的问题是什么"><a href="#6-31-目前常用的磁盘调度算法有哪几种-每种算法优先考虑的问题是什么" class="headerlink" title="6.31 目前常用的磁盘调度算法有哪几种?每种算法优先考虑的问题是什么?"></a>6.31 <strong>目前常用的磁盘调度算法有哪几种?每种算法优先考虑的问题是什么?</strong></h5><blockquote><p>目前常用的磁盘调度算法有FCFS,SSTF,SCAN</p><p>(1)<strong>先来先服务算法</strong>优先考虑进程请求访问磁盘的先后次序;<br>(2)<strong>最短寻道时间优先算法</strong>考虑要求访问的磁道与当前磁头所在磁道距离是否最近;<br>(3)<strong>扫描算法</strong>考虑欲访问的磁道与当前磁道间的距离,更优先考虑磁头当前的移动方向。</p></blockquote><h2 id="第七章·文件管理"><a href="#第七章·文件管理" class="headerlink" title="第七章·文件管理"></a>第七章·文件管理</h2><h5 id="7-1-数据项、记录、文件"><a href="#7-1-数据项、记录、文件" class="headerlink" title="7.1 数据项、记录、文件"></a>7.1 数据项、记录、文件</h5><blockquote><p><strong>数据项</strong>是最低级的数据组织形式，可分为基本数据项和组合数据项。基本数据项是用于描述一个对象某种属性的字符集，是数据组织中可以命名的最小逻辑数据单位，即原子数据，又称为数据元素或字段。组合数据项则由若干个基本数据项构成。</p><p><strong>记录</strong>是一组相关数据项的集合，用于描述一个对象某方面的属性。</p><p><strong>文件</strong>是指有创建者所定义的、具有文件名的一组相关信息的集合。</p><p>表头是4个数据项，一行是一个记录，整个表是一个文件(有结构文件，如txt的叫流式文件)</p><table><thead><tr><th>书名</th><th>作者</th><th>售价</th><th>出版日期</th></tr></thead><tbody><tr><td>操作系统从入门到放弃</td><td>布吉岛</td><td>100</td><td>明天</td></tr><tr><td>如何学废操作系统</td><td>还不几道</td><td>200</td><td>后天</td></tr><tr><td>……</td><td>……</td><td>……</td><td>……</td></tr></tbody></table></blockquote><h5 id="7-2-文件系统的三层模型"><a href="#7-2-文件系统的三层模型" class="headerlink" title="7.2 文件系统的三层模型"></a>7.2 文件系统的三层模型</h5><blockquote><p>第一层：对象及其属性说明(文件、目录、硬盘或磁带存储空间)</p><p>第二层：对对象操纵和管理的软件集合(I&#x2F;o控制层即设备驱动程序、基本文件系统即物理I&#x2F;o层、基本I&#x2F;О管理程序或文件组织模块层、逻辑文件系统层)</p><p>第三层：文件系统接口(命令接口&#x2F;图形化用户接口与程序接口)</p></blockquote><h2 id="第八章·磁盘存储器的管理"><a href="#第八章·磁盘存储器的管理" class="headerlink" title="第八章·磁盘存储器的管理"></a>第八章·磁盘存储器的管理</h2><h5 id="8-1-目前常用的外村有哪些组织方式"><a href="#8-1-目前常用的外村有哪些组织方式" class="headerlink" title="8.1 目前常用的外村有哪些组织方式"></a>8.1 目前常用的外村有哪些组织方式</h5><blockquote><p>外存的组织方式有三种：连续组织方式、链接组织方式、索引组织方式</p></blockquote><h5 id="8-2-连续组织方式所形成的顺序文件主要优缺点？主要应用于？"><a href="#8-2-连续组织方式所形成的顺序文件主要优缺点？主要应用于？" class="headerlink" title="8.2 连续组织方式所形成的顺序文件主要优缺点？主要应用于？"></a>8.2 连续组织方式所形成的顺序文件主要优缺点？主要应用于？</h5><blockquote><p>优点：1.顺序访问容易<br>  2.顺序访问速度快</p><p>缺点：<br>①要求为一个文件分配连续的存储空间，产生出许多外部碎片，严重地降低了外存空间的利用率。如果是定期地利用紧凑方法来消除碎片，则又需花费大量的机器时间。<br>②必须事先知道文件的长度<br>③不能灵活地删除和插入记录<br>④对于那些动态增长的文件，由于事先很难知道文件的最终大小，因而很难为其分配空间，而即使事先知道文件的最终大小，在采用预分配存储空间的方法时，也会使大量的存储空间长期空闲。</p><p>应用场合：它适用于许多资料处理的场合，如<strong>磁带文件</strong>，<strong>打印文件</strong>都是常用的<strong>顺序文件</strong></p></blockquote><h2 id="第九章·操作系统接口"><a href="#第九章·操作系统接口" class="headerlink" title="第九章·操作系统接口"></a>第九章·操作系统接口</h2><h5 id="9-1-操作系统用户接口包括？分别适用于？"><a href="#9-1-操作系统用户接口包括？分别适用于？" class="headerlink" title="9.1 操作系统用户接口包括？分别适用于？"></a>9.1 操作系统用户接口包括？分别适用于？</h5><blockquote><p>操作系统包括四种类型的用户接口：<strong>命令接口</strong>（分为联机与脱机命令接口）、<strong>程序接口</strong>、<strong>图形化用户接口</strong>和<strong>网络用户接口</strong>。</p><p><strong>命令接口和图形化用户接口</strong>支持用户直接通过终端来使用计算机系统，<strong>程序接口</strong>提供给用户在编制程序时使用，<strong>网络用户接口</strong>是面向网络应用的接口。</p></blockquote><h5 id="9-2-联机命令接口由哪些部分构成"><a href="#9-2-联机命令接口由哪些部分构成" class="headerlink" title="9.2 联机命令接口由哪些部分构成"></a>9.2 联机命令接口由哪些部分构成</h5><blockquote><p>联机命令接口由一组<strong>联机命令</strong>、<strong>终端处理程序</strong>和<strong>命令解释程序</strong>构成。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>教材答案</category>
      
    </categories>
    
    
    <tags>
      
      <tag>教材答案</tag>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
